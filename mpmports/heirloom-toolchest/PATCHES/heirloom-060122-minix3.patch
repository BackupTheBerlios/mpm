Common subdirectories: heirloom-060122/LICENSE and heirloom-060122-patched/LICENSE
Only in heirloom-060122-patched: Makefile
Only in heirloom-060122-patched: NOTES.minix
Common subdirectories: heirloom-060122/_install and heirloom-060122-patched/_install
Only in heirloom-060122-patched/_install: Makefile
diff -c heirloom-060122/_install/install_ucb.c heirloom-060122-patched/_install/install_ucb.c
*** heirloom-060122/_install/install_ucb.c Sun May 29 12:55:38 2005
--- heirloom-060122-patched/_install/install_ucb.c Tue Oct 17 14:49:36 2006
***************
*** 151,158 ****
  	size_t	bufsize;
  	ssize_t	rsz, wo, wt;
  
! 	if ((bufsize = ssp->st_blksize) < dsp->st_blksize)
! 		if ((bufsize = dsp->st_blksize) <= 0)
  			bufsize = 512;
  	buf = smalloc(bufsize);
  	while ((rsz = read(sfd, buf, bufsize)) > 0) {
--- 151,160 ----
  	size_t	bufsize;
  	ssize_t	rsz, wo, wt;
  
! #ifndef _MINIX
! 	if ((bufsize = ssp->st_blksize) < dsp->st_blksize)
! 		if ((bufsize = dsp->st_blksize) <= 0)
! #endif
  			bufsize = 512;
  	buf = smalloc(bufsize);
  	while ((rsz = read(sfd, buf, bufsize)) > 0) {
***************
*** 267,272 ****
--- 269,277 ----
  	if (check(src, tgt, dsp, &sst) != OKAY)
  		return;
  	unlink(tgt);
+ #ifdef _MINIX
+ #define fchmod(a,b) (1)
+ #endif
  	if ((dfd = creat(tgt, 0700)) < 0 || fchmod(dfd, 0700) < 0 ||
  			fstat(dfd, &nst) < 0) {
  		fprintf(stderr, "%s: %s: %s\n", progname, src,
Common subdirectories: heirloom-060122/banner and heirloom-060122-patched/banner
Only in heirloom-060122-patched/banner: Makefile
Common subdirectories: heirloom-060122/basename and heirloom-060122-patched/basename
Only in heirloom-060122-patched/basename: Makefile
Common subdirectories: heirloom-060122/bc and heirloom-060122-patched/bc
Only in heirloom-060122-patched/bc: Makefile
diff -c heirloom-060122/bc/bc.y heirloom-060122-patched/bc/bc.y
*** heirloom-060122/bc/bc.y Sun Jul  3 01:05:49 2005
--- heirloom-060122-patched/bc/bc.y Tue Oct 17 14:52:16 2006
***************
*** 80,85 ****
--- 80,88 ----
  #undef	getc
  #define	getc(f)		_IO_getc_unlocked(f)
  #endif
+ #ifdef _MINIX
+ #define LINE_MAX 2048   /* POSIX 2 LINE_MAX */
+ #endif
  %}
  %right '='
  %left '+' '-'
Common subdirectories: heirloom-060122/bdiff and heirloom-060122-patched/bdiff
Only in heirloom-060122-patched/bdiff: Makefile
diff -c heirloom-060122/bdiff/bdiff.c heirloom-060122-patched/bdiff/bdiff.c
*** heirloom-060122/bdiff/bdiff.c Sat Jul  2 13:50:31 2005
--- heirloom-060122-patched/bdiff/bdiff.c Tue Oct 17 15:01:07 2006
***************
*** 56,61 ****
--- 56,70 ----
  
  #define	ONSIG	16
  
+ #ifdef _MINIX
+ #define sigset(a,b) signal(a,b)
+ #define LONGLONG long
+ #define P_LLD "%ld"
+ #else
+ #define LONGLONG long long
+ #define P_LLD "%lld"
+ #endif
+ 
  /*
   *	This program segments two files into pieces of <= seglim lines
   *	(which is passed as a third argument or defaulted to some number)
***************
*** 403,409 ****
  		default:
  			lp = satoi(lp, &num);
  			num += linenum;
! 			printf("%lld", (long long)num);
  		}
  	}
  }
--- 412,418 ----
  		default:
  			lp = satoi(lp, &num);
  			num += linenum;
! 			printf(P_LLD, (LONGLONG)num);
  		}
  	}
  }
***************
*** 412,425 ****
  addgen(char **lpp, size_t *bufsizp, size_t *buflenp, FILE *fp)
  {
  	off_t oldline;
! 	printf("%llda%lld", (long long)linenum, (long long)linenum+1);
  
  	/* Save lines of new file. */
  	oldline = linenum + 1;
  	saverest(lpp, bufsizp, buflenp, fp);
  
  	if (oldline < linenum)
! 		printf(",%lld\n", (long long)linenum);
  	else
  		printf("\n");
  
--- 421,434 ----
  addgen(char **lpp, size_t *bufsizp, size_t *buflenp, FILE *fp)
  {
  	off_t oldline;
! 	printf(P_LLD "a" P_LLD, (LONGLONG)linenum, (LONGLONG)linenum+1);
  
  	/* Save lines of new file. */
  	oldline = linenum + 1;
  	saverest(lpp, bufsizp, buflenp, fp);
  
  	if (oldline < linenum)
! 		printf("," P_LLD "\n", (LONGLONG)linenum);
  	else
  		printf("\n");
  
***************
*** 434,449 ****
  {
  	off_t savenum;
  
! 	printf("%lld", (long long)linenum+1);
  	savenum = linenum;
  
  	/* Save lines of old file. */
  	saverest(lpp, bufsizp, buflenp, fp);
  
  	if (savenum +1 != linenum)
! 		printf(",%lldd%lld\n", (long long)linenum, (long long)savenum);
! 	else
! 		printf("d%lld\n", (long long)savenum);
  
  	/* Output saved lines, as 'diff' would.  */
  	putsave(lpp, bufsizp, buflenp, '<');
--- 443,458 ----
  {
  	off_t savenum;
  
! 	printf(P_LLD, (LONGLONG)linenum+1);
  	savenum = linenum;
  
  	/* Save lines of old file. */
  	saverest(lpp, bufsizp, buflenp, fp);
  
  	if (savenum +1 != linenum)
! 		printf("," P_LLD "d" P_LLD "\n", (LONGLONG)linenum, (LONGLONG)savenum);
! 	else
! 		printf("d" P_LLD "\n", (LONGLONG)savenum);
  
  	/* Output saved lines, as 'diff' would.  */
  	putsave(lpp, bufsizp, buflenp, '<');
Common subdirectories: heirloom-060122/bfs and heirloom-060122-patched/bfs
Only in heirloom-060122-patched/bfs: Makefile
diff -c heirloom-060122/bfs/bfs.c heirloom-060122-patched/bfs/bfs.c
*** heirloom-060122/bfs/bfs.c Sat Jul  2 13:50:54 2005
--- heirloom-060122-patched/bfs/bfs.c Tue Oct 17 16:11:20 2006
***************
*** 68,73 ****
--- 68,81 ----
  #define	BFSTRU	-1L
  #define	BFSBUF	512
  
+ #ifdef _MINIX
+ #define P_LLD "%ld"
+ #define LONGLONG long
+ #else
+ #define P_LLD "%lld"
+ #define LONGLONG long long
+ #endif
+ 
  struct Comd {
  	int Cnumadr;
  	long Cadr[2];
***************
*** 111,117 ****
  static char verbose = 1;	/* 1=print # of bytes read in; 0=silent. */
  static char *varray[10];	/* Holds xv cmd parameters. */
  static size_t varraysize[10];
! static long long outcnt;
  static char strtmp[PATH_MAX+32];
  static int mb_cur_max;
  static int errcnt;
--- 119,125 ----
  static char verbose = 1;	/* 1=print # of bytes read in; 0=silent. */
  static char *varray[10];	/* Holds xv cmd parameters. */
  static size_t varraysize[10];
! static LONGLONG outcnt;
  static char strtmp[PATH_MAX+32];
  static int mb_cur_max;
  static int errcnt;
***************
*** 119,125 ****
  static void reset(int);
  static void begin(struct Comd *p);
  static int  bigopen(const char *file);
! static void sizeprt(long long blk, int off);
  static long bigread(long l, char **rec, size_t *recsize);
  static int gcomd(struct Comd *p, int k);
  static int fcomd(struct Comd *p);
--- 127,133 ----
  static void reset(int);
  static void begin(struct Comd *p);
  static int  bigopen(const char *file);
! static void sizeprt(LONGLONG blk, int off);
  static long bigread(long l, char **rec, size_t *recsize);
  static int gcomd(struct Comd *p, int k);
  static int fcomd(struct Comd *p);
***************
*** 390,399 ****
  }
  
  static void
! sizeprt(long long blk, int off)
! {
! 	if (verbose)
! 		printf("%lld", 512*blk+off);
  }
  
  static off_t saveblk = -1;
--- 398,407 ----
  }
  
  static void
! sizeprt(LONGLONG blk, int off)
! {
! 	if (verbose)
! 		printf(P_LLD, 512*blk+off);
  }
  
  static off_t saveblk = -1;
***************
*** 859,865 ****
  		out(line, n);
  	}
  	if (verbose)
! 		printf("%lld\n", outcnt);
  	close(fd);
  
  	outfildes = savefd;
--- 867,873 ----
  		out(line, n);
  	}
  	if (verbose)
! 		printf(P_LLD "\n", outcnt);
  	close(fd);
  
  	outfildes = savefd;
Common subdirectories: heirloom-060122/build and heirloom-060122-patched/build
Only in heirloom-060122-patched/build: Makefile
diff -c heirloom-060122/build/Makefile.mk heirloom-060122-patched/build/Makefile.mk
*** heirloom-060122/build/Makefile.mk Thu Mar 10 16:11:29 2005
--- heirloom-060122-patched/build/Makefile.mk Tue Oct 17 15:41:10 2006
***************
*** 1,17 ****
  all: maninst crossln genintro
  
  maninst: maninst.sh mk.config
! 	<maninst.sh >maninst sed ' \
! 		s,@DEFLIB@,$(DEFLIB),g; \
! 		s,@SPELLHIST@,$(SPELLHIST),g; \
! 		s,@MAGIC@,$(MAGIC),g; \
! 		s,@DFLDIR@,$(DFLDIR),g; \
! 		s,@DEFBIN@,$(DEFBIN),g; \
! 		s,@SV3BIN@,$(SV3BIN),g; \
! 		s,@S42BIN@,$(S42BIN),g; \
! 		s,@SUSBIN@,$(SUSBIN),g; \
! 		s,@SU3BIN@,$(SU3BIN),g; \
! 		s,@UCBBIN@,$(UCBBIN),g'
  	chmod 755 maninst
  
  crossln: crossln.sh
--- 1,7 ----
  all: maninst crossln genintro
  
  maninst: maninst.sh mk.config
! 	<maninst.sh >maninst sed 's,@DEFLIB@,$(DEFLIB),g; s,@SPELLHIST@,$(SPELLHIST),g; s,@MAGIC@,$(MAGIC),g; s,@DFLDIR@,$(DFLDIR),g; s,@DEFBIN@,$(DEFBIN),g; s,@SV3BIN@,$(SV3BIN),g; s,@S42BIN@,$(S42BIN),g; s,@SUSBIN@,$(SUSBIN),g; s,@SU3BIN@,$(SU3BIN),g; s,@UCBBIN@,$(UCBBIN),g'
  	chmod 755 maninst
  
  crossln: crossln.sh
Only in heirloom-060122-patched/build: crossln
Only in heirloom-060122-patched/build: genintro
Only in heirloom-060122-patched/build: maninst
diff -c heirloom-060122/build/mk.config heirloom-060122-patched/build/mk.config
*** heirloom-060122/build/mk.config Sun Jan 22 21:48:04 2006
--- heirloom-060122-patched/build/mk.config Fri Oct 20 22:52:09 2006
***************
*** 19,25 ****
  # Root directory. Mainly useful for package building; leave empty for
  # normal installation.
  #
! ROOT =
  
  #
  # Location for binaries that have no special personality. This location
--- 19,25 ----
  # Root directory. Mainly useful for package building; leave empty for
  # normal installation.
  #
! ROOT = $(DESTDIR)
  
  #
  # Location for binaries that have no special personality. This location
***************
*** 73,90 ****
  # Location for default files. Make sure that this directory is accessible
  # to all users.
  #
! DFLDIR = /etc/default
  
  #
  # Location for the spell history file (contains misspelled words for
  # all users; set to /dev/null to disable).
  #
! SPELLHIST = /var/adm/spellhist
  
  #
  # Location for the su logfile.
  #
! SULOG = /var/log/sulog
  
  #
  # Where to store the file command's magic. Note that the existing
--- 73,90 ----
  # Location for default files. Make sure that this directory is accessible
  # to all users.
  #
! DFLDIR = /usr/etc/default
  
  #
  # Location for the spell history file (contains misspelled words for
  # all users; set to /dev/null to disable).
  #
! SPELLHIST = /usr/adm/spellhist
  
  #
  # Location for the su logfile.
  #
! SULOG = /usr/log/sulog
  
  #
  # Where to store the file command's magic. Note that the existing
***************
*** 113,119 ****
  # does not supply our needs. Use -ltermcap instead and add -DUSE_TERMCAP
  # to CPPFLAGS.
  #
! LCURS = -lcurses
  
  #
  # Socket library, necessary on Solaris and Open UNIX. If your system has
--- 113,119 ----
  # does not supply our needs. Use -ltermcap instead and add -DUSE_TERMCAP
  # to CPPFLAGS.
  #
! LCURS = -L/usr/gnu/lib -lncurses
  
  #
  # Socket library, necessary on Solaris and Open UNIX. If your system has
***************
*** 135,149 ****
  # zlib or don't want to use it; you need it only if you want to use inflate
  # compression when creating zip files with cpio.
  #
! LIBZ = -Wl,-Bstatic -lz -Wl,-Bdynamic
  USE_ZLIB = 1
  
  #
  # The name of the bzip2 library, and whether to use it. The library is only
  # needed to read and write bzip2 compressed parts of zip files with cpio.
  #
! #LIBBZ2 = -Wl,-Bstatic -lbz2 -Wl,-Bdynamic
! USE_BZLIB = 0
  
  #
  # Compiler and linker flags. HOSTCC is for cross compiling.
--- 135,149 ----
  # zlib or don't want to use it; you need it only if you want to use inflate
  # compression when creating zip files with cpio.
  #
! LIBZ = -L/usr/local/lib -lz
  USE_ZLIB = 1
  
  #
  # The name of the bzip2 library, and whether to use it. The library is only
  # needed to read and write bzip2 compressed parts of zip files with cpio.
  #
! LIBBZ2 = -L/usr/local/lib -lbz2
! USE_BZLIB = 1
  
  #
  # Compiler and linker flags. HOSTCC is for cross compiling.
***************
*** 152,170 ****
  #CC = $(HOME)/src/diet gcc
  CC = cc
  HOSTCC = $(CC)
! WERROR = -Werror
! WARN = -Wchar-subscripts -Wformat -Wno-format-y2k -Wimplicit \
! 	-Wmissing-braces -Wsequence-point -Wreturn-type -Wtrigraphs \
! 	-Wunused-function -Wunused-label -Wunused-variable -Wunused-value \
! 	-Wuninitialized -Wmultichar -Wpointer-arith \
! 	-Wdeclaration-after-statement $(WERROR)
  #WARN = -Wchar-subscripts -Wimplicit \
  #	-Wmissing-braces -Wreturn-type -Wtrigraphs \
  #	-Wuninitialized -Wmultichar -Wpointer-arith -Werror
! WARN=
! 
! LD = $(CC)
! LDFLAGS =
  
  #
  # Flags for the C preprocessor.
--- 152,171 ----
  #CC = $(HOME)/src/diet gcc
  CC = cc
  HOSTCC = $(CC)
! WERROR =
! #WERROR = -Werror
! #WARN = -Wchar-subscripts -Wformat -Wno-format-y2k -Wimplicit \
! #	-Wmissing-braces -Wsequence-point -Wreturn-type -Wtrigraphs \
! #	-Wunused-function -Wunused-label -Wunused-variable -Wunused-value \
! #	-Wuninitialized -Wmultichar -Wpointer-arith \
! #	-Wdeclaration-after-statement $(WERROR)
  #WARN = -Wchar-subscripts -Wimplicit \
  #	-Wmissing-braces -Wreturn-type -Wtrigraphs \
  #	-Wuninitialized -Wmultichar -Wpointer-arith -Werror
! WARN= -wo
! 
! LD = $(CC)
! LDFLAGS = -stack 4m -s
  
  #
  # Flags for the C preprocessor.
***************
*** 175,181 ****
  # On AIX, -D_MTEXTEND_H should be added if mtextend.h is not found.
  # On NetBSD, add -DUSE_TERMCAP.
  #
! CPPFLAGS = -D_GNU_SOURCE
  
  #
  # CFLAGS, CFLAGS2, CFLAGSS, and CFLAGSU make it possible to give special
--- 176,182 ----
  # On AIX, -D_MTEXTEND_H should be added if mtextend.h is not found.
  # On NetBSD, add -DUSE_TERMCAP.
  #
! CPPFLAGS = -D_MINIX=1 -D_POSIX_SOURCE=1 -I/usr/gnu/include/ncurses -I/usr/gnu/include -I/usr/local/include
  
  #
  # CFLAGS, CFLAGS2, CFLAGSS, and CFLAGSU make it possible to give special
***************
*** 196,210 ****
  # compiler mode (which is the default) until this issue is properly
  # handled by the system vendor.
  #
! CFLAGS = -O -fomit-frame-pointer $(WARN)
! CFLAGS2 = -O2 -fomit-frame-pointer $(WARN)
! CFLAGSS = -Os -fomit-frame-pointer $(WARN)
! CFLAGSU = -O2 -fomit-frame-pointer -funroll-loops $(WARN)
  
  #
  # Binaries are stripped with this command after installation.
  #
! STRIP = strip -s -R .comment -R .note
  
  #
  # The define for large file support in 32-bit environments.
--- 197,211 ----
  # compiler mode (which is the default) until this issue is properly
  # handled by the system vendor.
  #
! CFLAGS = -O  $(WARN)
! CFLAGS2 = -O  $(WARN)
! CFLAGSS = -O  $(WARN)
! CFLAGSU = -O   $(WARN)
  
  #
  # Binaries are stripped with this command after installation.
  #
! STRIP = strip
  
  #
  # The define for large file support in 32-bit environments.
***************
*** 218,224 ****
  #
  # On FreeBSD, NetBSD, and OpenBSD, no such define is necessary.
  #
! LARGEF = -D_FILE_OFFSET_BITS=64L
  
  #
  # Use this if you prefer symbolic links between installed files.
--- 219,226 ----
  #
  # On FreeBSD, NetBSD, and OpenBSD, no such define is necessary.
  #
! #LARGEF = -D_FILE_OFFSET_BITS=64L
! LARGEF =
  
  #
  # Use this if you prefer symbolic links between installed files.
***************
*** 239,245 ****
  # Lex implementations known to work with the Heirloom Toolchest are
  # most derivatives of the original Unix lex and flex.
  #
! LEX = lex
  
  #
  # Whether to use the supplied widechar emulation library. This should
--- 241,247 ----
  # Lex implementations known to work with the Heirloom Toolchest are
  # most derivatives of the original Unix lex and flex.
  #
! LEX = /usr/local/bin/flex
  
  #
  # Whether to use the supplied widechar emulation library. This should
***************
*** 250,270 ****
  # - NetBSD 1.x, because it lacks wctype_t/wctrans_t etc. in wctype.h.
  # - OpenBSD
  #
! #IWCHAR = -I../libwchar
! #LWCHAR = -L../libwchar -lwchar
  
  #
  # Crypt library. -lcrypt is okay for everything except HP-UX, AIX, NetBSD,
  # and old versions of diet libc.
  #
! LCRYPT=-lcrypt
  
  #
  # Run ranlib if it is in the current path. This should take care
  # of most situations. On Mac OS X, you need to uncomment "ranlib -c".
  #
! RANLIB=(hash ranlib) >/dev/null 2>&1 || exit 0; ranlib
! #RANLIB=ranlib -c
  
  #
  # Don't change the rest of this file unless you really know what you are
--- 252,273 ----
  # - NetBSD 1.x, because it lacks wctype_t/wctrans_t etc. in wctype.h.
  # - OpenBSD
  #
! IWCHAR = -I../libwchar
! LWCHAR = -L../libwchar -lwchar
  
  #
  # Crypt library. -lcrypt is okay for everything except HP-UX, AIX, NetBSD,
  # and old versions of diet libc.
  #
! #LCRYPT=-lcrypt
  
  #
  # Run ranlib if it is in the current path. This should take care
  # of most situations. On Mac OS X, you need to uncomment "ranlib -c".
  #
! #RANLIB=(hash ranlib) >/dev/null 2>&1 || exit 0; ranlib
! #RANLIB=ranlib -c
! RANLIB=:
  
  #
  # Don't change the rest of this file unless you really know what you are
Common subdirectories: heirloom-060122/cal and heirloom-060122-patched/cal
Only in heirloom-060122-patched/cal: Makefile
diff -c heirloom-060122/cal/cal.c heirloom-060122-patched/cal/cal.c
*** heirloom-060122/cal/cal.c Sun May 29 12:55:38 2005
--- heirloom-060122-patched/cal/cal.c Tue Oct 17 15:34:51 2006
***************
*** 48,54 ****
  #include	<libgen.h>
  #include	<stdlib.h>
  #include	<locale.h>
! #include	<langinfo.h>
  #include	<string.h>
  #include	<wchar.h>
  #include	<limits.h>
--- 48,58 ----
  #include	<libgen.h>
  #include	<stdlib.h>
  #include	<locale.h>
! #ifndef _MINIX
! #include	<langinfo.h>
! #else
! #include    "fake_langinfo.h"
! #endif
  #include	<string.h>
  #include	<wchar.h>
  #include	<limits.h>
Only in heirloom-060122-patched/cal: fake_langinfo.h
Common subdirectories: heirloom-060122/calendar and heirloom-060122-patched/calendar
Only in heirloom-060122-patched/calendar: Makefile
diff -c heirloom-060122/calendar/Makefile.mk heirloom-060122-patched/calendar/Makefile.mk
*** heirloom-060122/calendar/Makefile.mk Sat May  1 16:58:02 2004
--- heirloom-060122-patched/calendar/Makefile.mk Tue Oct 17 15:40:27 2006
***************
*** 1,10 ****
  all: calendar calprog
  
  calendar: calendar.sh
! 	echo '#!$(SHELL)' | cat - calendar.sh | sed ' \
! 		s,@DEFBIN@,$(DEFBIN),g; \
! 		s,@SV3BIN@,$(SV3BIN),g; \
! 		s,@DEFLIB@,$(DEFLIB),g' >calendar
  	chmod 755 calendar
  
  calprog: calprog.o
--- 1,7 ----
  all: calendar calprog
  
  calendar: calendar.sh
! 	echo '#!$(SHELL)' | cat - calendar.sh | sed 's,@DEFBIN@,$(DEFBIN),g; s,@SV3BIN@,$(SV3BIN),g; s,@DEFLIB@,$(DEFLIB),g' >calendar
  	chmod 755 calendar
  
  calprog: calprog.o
diff -c heirloom-060122/calendar/calprog.c heirloom-060122-patched/calendar/calprog.c
*** heirloom-060122/calendar/calprog.c Sun May 29 12:55:38 2005
--- heirloom-060122-patched/calendar/calprog.c Tue Oct 17 15:42:13 2006
***************
*** 53,59 ****
  #include <stdlib.h>
  #include <stdio.h>
  #include <locale.h>
! #include <langinfo.h>
  #include <wctype.h>
  #include <wchar.h>
  
--- 53,63 ----
  #include <stdlib.h>
  #include <stdio.h>
  #include <locale.h>
! #ifndef _MINIX
! #include <langinfo.h>
! #else
! #include "../cal/fake_langinfo.h"
! #endif
  #include <wctype.h>
  #include <wchar.h>
  
Common subdirectories: heirloom-060122/cat and heirloom-060122-patched/cat
Only in heirloom-060122-patched/cat: Makefile
Common subdirectories: heirloom-060122/chmod and heirloom-060122-patched/chmod
Only in heirloom-060122-patched/chmod: Makefile
Common subdirectories: heirloom-060122/chown and heirloom-060122-patched/chown
Only in heirloom-060122-patched/chown: Makefile
diff -c heirloom-060122/chown/chown.c heirloom-060122-patched/chown/chown.c
*** heirloom-060122/chown/chown.c Sun May 29 12:55:38 2005
--- heirloom-060122-patched/chown/chown.c Tue Oct 17 16:03:32 2006
***************
*** 143,148 ****
--- 143,152 ----
  	int	(*chownfn)(const char *, uid_t, gid_t);
  	int	(*statfn)(const char *, struct stat *);
  
+ #ifdef _MINIX
+ #define lchown chown
+ #endif
+ 
  	chownfn = hflag || Rflag && HLPflag == 'P' ? lchown : chown;
  	statfn = hflag || Rflag && HLPflag == 'P' ? lstat : stat;
  	if (statfn(path, &ost) < 0) {
Common subdirectories: heirloom-060122/cksum and heirloom-060122-patched/cksum
Only in heirloom-060122-patched/cksum: Makefile
diff -c heirloom-060122/cksum/cksum.c heirloom-060122-patched/cksum/cksum.c
*** heirloom-060122/cksum/cksum.c Sun May 29 12:55:38 2005
--- heirloom-060122-patched/cksum/cksum.c Tue Oct 17 16:08:02 2006
***************
*** 57,62 ****
--- 57,70 ----
  #include <string.h>
  #include <errno.h>
  
+ #ifdef _MINIX
+ #define LONGLONG long
+ #define P_LLU "%lu"
+ #else
+ #define LONGLONG long long
+ #define P_LLU "%llu"
+ #endif
+ 
  static char	*progname;
  
  static const uint32_t crctab[] = {
***************
*** 121,127 ****
  	int	fd;
  	ssize_t	sz, i;
  	char	buf[4096];
! 	unsigned long long	nbytes, n;
  	uint32_t	s = 0;
  
  	if (name) {
--- 129,135 ----
  	int	fd;
  	ssize_t	sz, i;
  	char	buf[4096];
! 	unsigned LONGLONG	nbytes, n;
  	uint32_t	s = 0;
  
  	if (name) {
***************
*** 147,153 ****
  		s = (s << 8) ^ crctab[(s >> 24) ^ c];
  	}
  	s = ~s;
! 	printf("%u %llu", (unsigned)s, nbytes);
  	if(name)
  		printf(" %s", name);
  	printf("\n");
--- 155,161 ----
  		s = (s << 8) ^ crctab[(s >> 24) ^ c];
  	}
  	s = ~s;
! 	printf("%u " P_LLU, (unsigned)s, nbytes);
  	if(name)
  		printf(" %s", name);
  	printf("\n");
Common subdirectories: heirloom-060122/cmp and heirloom-060122-patched/cmp
Only in heirloom-060122-patched/cmp: Makefile
diff -c heirloom-060122/cmp/cmp.c heirloom-060122-patched/cmp/cmp.c
*** heirloom-060122/cmp/cmp.c Sun May 29 12:55:38 2005
--- heirloom-060122-patched/cmp/cmp.c Tue Oct 17 17:23:32 2006
***************
*** 41,47 ****
  #include	<stdio.h>
  #include	<string.h>
  #include	<stdlib.h>
! #include	<malloc.h>
  #include	<errno.h>
  #include	<libgen.h>
  #include	<limits.h>
--- 41,49 ----
  #include	<stdio.h>
  #include	<string.h>
  #include	<stdlib.h>
! #ifndef _MINIX
! #include	<malloc.h>
! #endif
  #include	<errno.h>
  #include	<libgen.h>
  #include	<limits.h>
***************
*** 57,66 ****
  #define	BLKSIZE		8192
  #define	IOSIZE		(SSIZE_MAX > BLKSIZE ? BLKSIZE : SSIZE_MAX)
  
  struct	file {
  	char	f_buf[IOSIZE];		/* input buffer */
  	struct stat	f_st;		/* fstat(f_fd) */
! 	long long	f_off;		/* offset of f_buf in file */
  	char	*f_cur;			/* current position in buffer */
  	char	*f_max;			/* highest valid position in buffer+1 */
  	const char	*f_nam;		/* file name */
--- 59,83 ----
  #define	BLKSIZE		8192
  #define	IOSIZE		(SSIZE_MAX > BLKSIZE ? BLKSIZE : SSIZE_MAX)
  
+ #ifdef _MINIX
+ #define LONGLONG long
+ #define P_LLD "%ld"
+ #define P_6LLD "%6ld"
+ #define P_022LLO "%022lo"
+ #define P_011LLO "%011lo"
+ #define strtoll(a,b,c) strtol(a,b,c)
+ #else
+ #define LONGLONG long long
+ #define P_LLD "%lld"
+ #define P_6LLD "%6lld"
+ #define P_022LLO "%022llo"
+ #define P_011LLO "%011llo"
+ #endif
+ 
  struct	file {
  	char	f_buf[IOSIZE];		/* input buffer */
  	struct stat	f_st;		/* fstat(f_fd) */
! 	LONGLONG	f_off;		/* offset of f_buf in file */
  	char	*f_cur;			/* current position in buffer */
  	char	*f_max;			/* highest valid position in buffer+1 */
  	const char	*f_nam;		/* file name */
***************
*** 94,104 ****
  printbe64(const char *s, int max)
  {
  	int	i;
! 	unsigned long long	u = 0;
! 
! 	for (i = 0; i < max; i++)
! 		u += (unsigned long long)(s[i]&0377) << 8*(7-i);
! 	printf("%022llo", u);
  }
  
  static void
--- 111,121 ----
  printbe64(const char *s, int max)
  {
  	int	i;
! 	unsigned LONGLONG	u = 0;
! 
! 	for (i = 0; i < max; i++)
! 		u += (unsigned LONGLONG)(s[i]&0377) << 8*(7-i);
! 	printf(P_022LLO, u);
  }
  
  static void
***************
*** 155,161 ****
  static int
  wprnt(struct file *f1, struct file *f2)
  {
! 	long long	offs = offset(f1) - 1;
  	int	mod = offs % 8;
  	int	eof = 0, diff, max;
  
--- 172,178 ----
  static int
  wprnt(struct file *f1, struct file *f2)
  {
! 	LONGLONG	offs = offset(f1) - 1;
  	int	mod = offs % 8;
  	int	eof = 0, diff, max;
  
***************
*** 172,178 ****
  		max = f2->f_max - f2->f_cur;
  	else
  		max = 8;
! 	printf("%011llo: ", offs / 8);
  	printbe64(f1->f_cur, max);
  	putchar(' ');
  	printbe64(f2->f_cur, max);
--- 189,195 ----
  		max = f2->f_max - f2->f_cur;
  	else
  		max = 8;
! 	printf(P_011LLO ": ", offs / 8);
  	printbe64(f1->f_cur, max);
  	putchar(' ');
  	printbe64(f2->f_cur, max);
***************
*** 197,203 ****
  {
  	int	c1, c2;
  	unsigned	i;
! 	long long	line = 1;
  
  	for (;;) {
  		c1 = bread(f1);
--- 214,220 ----
  {
  	int	c1, c2;
  	unsigned	i;
! 	LONGLONG	line = 1;
  
  	for (;;) {
  		c1 = bread(f1);
***************
*** 241,255 ****
  			else if (c2 == EOF)
  				eofon(f2);
  			else if (lflag) {
! 				printf("%6lld %3o %3o\n", (long long)offset(f1),
  				c1, c2);
  				errcnt = 1;
  			} else {
  				if (sflag == 0)
! 					printf("%s %s differ: char %lld,"
! 							" line %lld\n",
! 						f1->f_nam, f2->f_nam,
! 						(long long)offset(f1),
  						line);
  				exit(1);
  			}
--- 258,272 ----
  			else if (c2 == EOF)
  				eofon(f2);
  			else if (lflag) {
! 				printf(P_6LLD "%3o %3o\n", (LONGLONG)offset(f1),
  				c1, c2);
  				errcnt = 1;
  			} else {
  				if (sflag == 0)
! 					printf("%s %s differ: char " P_LLD ","
! 							" line " P_LLD "\n",
! 						f1->f_nam, f2->f_nam,
! 						(LONGLONG)offset(f1),
  						line);
  				exit(1);
  			}
***************
*** 296,302 ****
  static void
  setskip(struct file *f, const char *skipstring)
  {
! 	long long	skip;
  	ssize_t	rsz;
  
  	skip = strtoll(skipstring, NULL, *skipstring == '0' ? 8 : 10);
--- 313,319 ----
  static void
  setskip(struct file *f, const char *skipstring)
  {
! 	LONGLONG	skip;
  	ssize_t	rsz;
  
  	skip = strtoll(skipstring, NULL, *skipstring == '0' ? 8 : 10);
Common subdirectories: heirloom-060122/col and heirloom-060122-patched/col
Only in heirloom-060122-patched/col: Makefile
diff -c heirloom-060122/col/col.c heirloom-060122-patched/col/col.c
*** heirloom-060122/col/col.c Sun May 29 12:55:38 2005
--- heirloom-060122-patched/col/col.c Tue Oct 17 17:39:45 2006
***************
*** 64,69 ****
--- 64,70 ----
  # define RLF '\013'
  # define SI '\017'
  # define SO '\016'
+ #ifndef _MINIX
  # define CMASK	0x00000000ffffffffLL
  # define EOFC	0x0000010000000000LL
  # define TRANS	0x1000000000000000LL
***************
*** 75,95 ****
  # define CHRMSK 0x000000ff00000000LL
  # define CHRSHF	32
  
  # define nextc(c, cp, m)	(mb_cur_max > 1 ? \
  		((cp) = ib_getw(input, &(c), &(m)), \
  		 (cp) == NULL ? EOFC : \
! 		 (c) == WEOF ? ((long long)(*(cp)&0377)<<CHRSHF)|ILLSEQ : \
! 		 iswprint(c) ? (c)|((long long)wcwidth(c)<<COLSHF)|ISPRNT : \
  		 (c)) : \
  		((c) = ib_get(input), \
  		 (c) == EOF ? EOFC : \
! 		 isprint(c) ? (c)|(1LL<<COLSHF)|ISPRNT : \
  		 (c)))
  
  # define slbuff(n)	(line+(n)+128 >= LINELN ? growsbuff((n)+128) : lbuff);
  
! static long long *page[PL];
! static long long *lbuff;
  static long	line, LINELN;
  static int bflag, xflag, fflag, pflag;
  static int half;
--- 76,117 ----
  # define CHRMSK 0x000000ff00000000LL
  # define CHRSHF	32
  
+ #define LONGLONG long long
+ #define LONGLONG_1LL 1LL
+ 
+ #else
+ 
+ # define CMASK	0x000000ffL
+ # define EOFC	0x00001000L
+ # define TRANS	0x10000000L
+ # define GREEK	0x20000000L
+ # define ILLSEQ	0x40000000L
+ # define ISPRNT	0x80000000L
+ # define COLMSK	0x0f000000L
+ # define COLSHF	24
+ # define CHRMSK 0x00ff0000L
+ # define CHRSHF	8
+ 
+ #define LONGLONG long
+ #define LONGLONG_1LL 1L
+ 
+ #endif
+ 
  # define nextc(c, cp, m)	(mb_cur_max > 1 ? \
  		((cp) = ib_getw(input, &(c), &(m)), \
  		 (cp) == NULL ? EOFC : \
! 		 (c) == WEOF ? ((LONGLONG)(*(cp)&0377)<<CHRSHF)|ILLSEQ : \
! 		 iswprint(c) ? (c)|((LONGLONG)wcwidth(c)<<COLSHF)|ISPRNT : \
  		 (c)) : \
  		((c) = ib_get(input), \
  		 (c) == EOF ? EOFC : \
! 		 isprint(c) ? (c)|(LONGLONG_1LL<<COLSHF)|ISPRNT : \
  		 (c)))
  
  # define slbuff(n)	(line+(n)+128 >= LINELN ? growsbuff((n)+128) : lbuff);
  
! static LONGLONG *page[PL];
! static LONGLONG *lbuff;
  static long	line, LINELN;
  static int bflag, xflag, fflag, pflag;
  static int half;
***************
*** 100,123 ****
  static struct iblok	*input;
  static int	mb_cur_max;
  
! static long long	space[] = { ' ' | (1LL<<COLSHF) | ISPRNT, '\0' };
! 
! static void	outc(long long);
! static void	store(int);
! static void	fetch(int);
! static void	emit(long long *, int);
! static void	incr(void);
! static void	decr(void);
! static size_t	lllen(const long long *);
! static long long	*llcpy(long long *, const long long *);
! static long long	*growsbuff(size_t);
  
  int
  main (int argc, char **argv)
  {
  	int i;
! 	long long greek;
! 	long long c;
  	wint_t	wc;
  	char	*mp;
  
--- 122,145 ----
  static struct iblok	*input;
  static int	mb_cur_max;
  
! static LONGLONG	space[] = { ' ' | (LONGLONG_1LL<<COLSHF) | ISPRNT, '\0' };
! 
! static void	outc(LONGLONG);
! static void	store(int);
! static void	fetch(int);
! static void	emit(LONGLONG *, int);
! static void	incr(void);
! static void	decr(void);
! static size_t	lllen(const LONGLONG *);
! static LONGLONG	*llcpy(LONGLONG *, const LONGLONG *);
! static LONGLONG	*growsbuff(size_t);
  
  int
  main (int argc, char **argv)
  {
  	int i;
! 	LONGLONG greek;
! 	LONGLONG c;
  	wint_t	wc;
  	char	*mp;
  
***************
*** 266,272 ****
  }
  
  static void
! outc (register long long c)
  {
  	int i, v, w;
  	size_t n;
--- 288,294 ----
  }
  
  static void
! outc (register LONGLONG c)
  {
  	int i, v, w;
  	size_t n;
***************
*** 280,286 ****
  		slbuff(0);
  		switch (lbuff[line]) {
  		case '\0':
! 			lbuff[line] = ' ' | ISPRNT | (1LL<<COLSHF);
  			lp++;
  			break;
  
--- 302,308 ----
  		slbuff(0);
  		switch (lbuff[line]) {
  		case '\0':
! 			lbuff[line] = ' ' | ISPRNT | (LONGLONG_1LL<<COLSHF);
  			lp++;
  			break;
  
***************
*** 311,317 ****
  					n * sizeof *lbuff);
  			n = lp - cp;
  			while (n--)
! 				lbuff[line++] = ' '|ISPRNT|(1LL<<COLSHF);
  			lp = cp;
  		}
  		v = (c&COLMSK)>>COLSHF;
--- 333,339 ----
  					n * sizeof *lbuff);
  			n = lp - cp;
  			while (n--)
! 				lbuff[line++] = ' '|ISPRNT|(LONGLONG_1LL<<COLSHF);
  			lp = cp;
  		}
  		v = (c&COLMSK)>>COLSHF;
***************
*** 323,329 ****
  					n * sizeof *lbuff);
  			n = w - v;
  			while (n--)
! 				lbuff[++line] = ' '|ISPRNT|(1LL<<COLSHF);
  		} else {
  			n = 1;
  			while (lbuff[line+n] = lbuff[line+v-w+n])
--- 345,351 ----
  					n * sizeof *lbuff);
  			n = w - v;
  			while (n--)
! 				lbuff[++line] = ' '|ISPRNT|(LONGLONG_1LL<<COLSHF);
  		} else {
  			n = 1;
  			while (lbuff[line+n] = lbuff[line+v-w+n])
***************
*** 356,362 ****
  					n * sizeof *lbuff);
  			n = w - v;
  			while (n--)
! 				lbuff[++line] = ' '|ISPRNT|(1LL<<COLSHF)|TRANS;
  		} else {
  			n = 1;
  			while (lbuff[line+n] = lbuff[line+v-w+n])
--- 378,384 ----
  					n * sizeof *lbuff);
  			n = w - v;
  			while (n--)
! 				lbuff[++line] = ' '|ISPRNT|(LONGLONG_1LL<<COLSHF)|TRANS;
  		} else {
  			n = 1;
  			while (lbuff[line+n] = lbuff[line+v-w+n])
***************
*** 384,390 ****
  static void
  fetch(int lno)
  {
! 	register long long *p;
  	size_t	n;
  
  	lno %= PL;
--- 406,412 ----
  static void
  fetch(int lno)
  {
! 	register LONGLONG *p;
  	size_t	n;
  
  	lno %= PL;
***************
*** 400,411 ****
  	}
  }
  static void
! emit (long long *s, int lineno)
  {
  	static int cline = 0;
  	register int ncp, i;
! 	register long long *p;
! 	static long long gflag = 0;
  
  	if (*s) {
  		while (cline < lineno - 1) {
--- 422,433 ----
  	}
  }
  static void
! emit (LONGLONG *s, int lineno)
  {
  	static int cline = 0;
  	register int ncp, i;
! 	register LONGLONG *p;
! 	static LONGLONG gflag = 0;
  
  	if (*s) {
  		while (cline < lineno - 1) {
***************
*** 488,494 ****
  }
  
  static size_t
! lllen(const long long *lp)
  {
  	size_t	n = 0;
  
--- 510,516 ----
  }
  
  static size_t
! lllen(const LONGLONG *lp)
  {
  	size_t	n = 0;
  
***************
*** 497,512 ****
  	return n;
  }
  
! static long long
! *llcpy(long long *dst, const long long *sp)
! {
! 	long long	*dp = dst;
  
  	while (*dp++ = *sp++);
  	return dst;
  }
  
! static long long *
  growsbuff(size_t n)
  {
  	if ((lbuff = realloc(lbuff, (line+n) * sizeof *lbuff)) == NULL) {
--- 519,534 ----
  	return n;
  }
  
! static LONGLONG
! *llcpy(LONGLONG *dst, const LONGLONG *sp)
! {
! 	LONGLONG	*dp = dst;
  
  	while (*dp++ = *sp++);
  	return dst;
  }
  
! static LONGLONG *
  growsbuff(size_t n)
  {
  	if ((lbuff = realloc(lbuff, (line+n) * sizeof *lbuff)) == NULL) {
Common subdirectories: heirloom-060122/comm and heirloom-060122-patched/comm
Only in heirloom-060122-patched/comm: Makefile
Common subdirectories: heirloom-060122/copy and heirloom-060122-patched/copy
Only in heirloom-060122-patched/copy: Makefile
diff -c heirloom-060122/copy/copy.c heirloom-060122-patched/copy/copy.c
*** heirloom-060122/copy/copy.c Sun May 29 12:55:38 2005
--- heirloom-060122-patched/copy/copy.c Tue Oct 17 22:15:30 2006
***************
*** 41,47 ****
  #include <stdio.h>
  #include <string.h>
  #include <stdlib.h>
! #include <malloc.h>
  #include <errno.h>
  #include <libgen.h>
  #include <limits.h>
--- 41,49 ----
  #include <stdio.h>
  #include <string.h>
  #include <stdlib.h>
! #ifndef _MINIX
! #include <malloc.h>
! #endif
  #include <errno.h>
  #include <libgen.h>
  #include <limits.h>
***************
*** 50,56 ****
  #include <stdarg.h>
  #include "sfile.h"
  #include "memalign.h"
! 
  #ifndef	S_IFDOOR
  #define	S_IFDOOR	0xD000
  #endif
--- 52,69 ----
  #include <stdarg.h>
  #include "sfile.h"
  #include "memalign.h"
! #include "realpath.h"
! 
! #ifdef _MINIX
! #define LONGLONG long
! #define lchown chown
! #else
! #define LONGLONG long long
! #endif
! 
! #ifndef S_IFSOCK
! #define S_IFSOCK    0140000
! #endif
  #ifndef	S_IFDOOR
  #define	S_IFDOOR	0xD000
  #endif
***************
*** 349,355 ****
  	static long	pagesize;
  	static char	*buf = NULL;
  	static size_t	bufsize;
! 	long long	blksize;
  	ssize_t	rsz, wo, wt;
  
  #ifdef	__linux__
--- 362,368 ----
  	static long	pagesize;
  	static char	*buf = NULL;
  	static size_t	bufsize;
! 	LONGLONG	blksize;
  	ssize_t	rsz, wo, wt;
  
  #ifdef	__linux__
***************
*** 365,371 ****
  #endif	/* __linux__ */
  	if (pagesize == 0 && (pagesize = sysconf(_SC_PAGESIZE)) <= 0)
  		pagesize = 4096;
! 	if ((blksize = sp->st_blksize) <= 0)
  		blksize = 512;
  	if (bufsize < blksize) {
  		free(buf);
--- 378,386 ----
  #endif	/* __linux__ */
  	if (pagesize == 0 && (pagesize = sysconf(_SC_PAGESIZE)) <= 0)
  		pagesize = 4096;
! #ifndef _MINIX
! 	if ((blksize = sp->st_blksize) <= 0)
! #endif
  		blksize = 512;
  	if (bufsize < blksize) {
  		free(buf);
***************
*** 485,490 ****
--- 500,509 ----
  	va_start(ap, fmt);
  	vfprintf(stderr, fmt, ap);
  	va_end(ap);
+ 
+     fflush(stdout);
+     fflush(stderr);
+ 
  	if (read(0, &c, 1) == 1) {
  		yes = (c == 'y' || c == 'Y') ? OKAY : STOP;
  		while (c != '\n' && read(0, &c, 1) == 1);
Common subdirectories: heirloom-060122/cp and heirloom-060122-patched/cp
Only in heirloom-060122-patched/cp: Makefile
diff -c heirloom-060122/cp/cp.c heirloom-060122-patched/cp/cp.c
*** heirloom-060122/cp/cp.c Sun Jan 22 18:37:59 2006
--- heirloom-060122-patched/cp/cp.c Tue Oct 17 22:12:32 2006
***************
*** 51,57 ****
  #include	<stdio.h>
  #include	<string.h>
  #include	<stdlib.h>
! #include	<malloc.h>
  #include	<errno.h>
  #include	<libgen.h>
  #include	<limits.h>
--- 51,59 ----
  #include	<stdio.h>
  #include	<string.h>
  #include	<stdlib.h>
! #ifndef _MINIX
! #include	<malloc.h>
! #endif
  #include	<errno.h>
  #include	<libgen.h>
  #include	<limits.h>
***************
*** 61,66 ****
--- 63,71 ----
  #include	"memalign.h"
  #include	"alloca.h"
  
+ #ifndef S_IFSOCK
+ #define S_IFSOCK    0140000
+ #endif
  #ifndef	S_IFDOOR
  #define	S_IFDOOR	0xD000		/* Solaris door */
  #endif
***************
*** 71,76 ****
--- 76,102 ----
  #define	S_IFNWK		0x9000		/* HP-UX network special file */
  #endif
  
+ #ifdef _MINIX
+ #define LONGLONG long
+ 
+ struct rusage {
+     struct timeval ru_utime;
+     struct timeval ru_stime;
+ };
+ 
+ #define RUSAGE_SELF 0
+ 
+ static int getrusage(int who, struct rusage *usage) {
+     return gettimeofday(&usage->ru_utime, NULL) + \
+            gettimeofday(&usage->ru_stime, NULL);
+ }
+ 
+ #define lchown(a,b,c) chown(a,b,c)
+ 
+ #else
+ #define LONGLONG long long
+ #endif
+ 
  static enum {
  	PERS_CP,
  	PERS_MV,
***************
*** 340,345 ****
--- 366,374 ----
  	enum okay yes = STOP;
  	char c;
  
+     fflush(stdout);
+     fflush(stderr);
+ 
  	if (read(0, &c, 1) == 1) {
  		yes = (c == 'y' || c == 'Y') ? OKAY : STOP;
  		while (c != '\n' && read(0, &c, 1) == 1);
***************
*** 395,409 ****
  
  static size_t
  balign(const struct stat *ssp, const struct stat *dsp,
! 		long long size, size_t prefd)
  {
  	int	n, m;
  	size_t	s;
  
  	n = (ssp->st_mode&S_IFMT) == S_IFREG && ssp->st_blksize >= 0 ?
  		ssp->st_blksize : 512;
  	m = (dsp->st_mode&S_IFMT) == S_IFREG && dsp->st_blksize >= 0 ?
  		dsp->st_blksize : 512;
  	if (prefd <= size && prefd % n == 0 && prefd % m == 0)
  		return prefd;
  	else if (n % m == 0)
--- 424,442 ----
  
  static size_t
  balign(const struct stat *ssp, const struct stat *dsp,
! 		LONGLONG size, size_t prefd)
  {
  	int	n, m;
  	size_t	s;
  
+ #ifdef _MINIX
+     n = m = 512;
+ #else
  	n = (ssp->st_mode&S_IFMT) == S_IFREG && ssp->st_blksize >= 0 ?
  		ssp->st_blksize : 512;
  	m = (dsp->st_mode&S_IFMT) == S_IFREG && dsp->st_blksize >= 0 ?
  		dsp->st_blksize : 512;
+ #endif
  	if (prefd <= size && prefd % n == 0 && prefd % m == 0)
  		return prefd;
  	else if (n % m == 0)
***************
*** 440,446 ****
  
  #ifdef	__linux__
  	if (!bflag && !Dflag && ssp->st_size > 0) {
! 		long long	sent;
  
  		if ((sent = sfile(dfd, sfd, ssp->st_mode, ssp->st_size)) ==
  				ssp->st_size)
--- 473,479 ----
  
  #ifdef	__linux__
  	if (!bflag && !Dflag && ssp->st_size > 0) {
! 		LONGLONG	sent;
  
  		if ((sent = sfile(dfd, sfd, ssp->st_mode, ssp->st_size)) ==
  				ssp->st_size)
***************
*** 549,555 ****
  	struct stat stbuf;
  	mode_t mode;
  	int sfd, dfd;
! 	float	f, s, t;
  	struct timeval	tv1, tv2;
  	struct rusage	ru1, ru2;
  
--- 582,588 ----
  	struct stat stbuf;
  	mode_t mode;
  	int sfd, dfd;
!     double f, s, t;
  	struct timeval	tv1, tv2;
  	struct rusage	ru1, ru2;
  
***************
*** 593,610 ****
  	if (sflag) {
  		gettimeofday(&tv2, NULL);
  		getrusage(RUSAGE_SELF, &ru2);
! #define	tv2f(tv)	((tv).tv_sec + (float)(tv).tv_usec / 1000000)
! 		f = tv2f(tv2) - tv2f(tv1);
! 		s = (float)ssp->st_size / (2<<19);
  		t = f ? s / f : s;
  		printf("                 ****** %s File Information ******\n"
  		       "        Input file              :       %s\n"
  		       "        Output file             :       %s\n"
! 		       "        Real Time (secs)        : %14.6f\n"
! 		       "        User Time (secs)        : %14.6f\n"
! 		       "        System Time (secs)      : %14.6f\n"
! 		       "        File Size (MB)          : %14.6f\n"
! 		       "        Transfer Rate (MB/s)    : %14.6f\n",
  		       progname, src, tgt,
  		       f,
  		       tv2f(ru2.ru_utime) - tv2f(ru1.ru_utime),
--- 626,643 ----
  	if (sflag) {
  		gettimeofday(&tv2, NULL);
  		getrusage(RUSAGE_SELF, &ru2);
! #define	tv2f(tv)	((tv).tv_sec + (double)(tv).tv_usec / 1000000)
! 		f = tv2f(tv2) - tv2f(tv1);
! 		s = (double)ssp->st_size / (2<<19);
  		t = f ? s / f : s;
  		printf("                 ****** %s File Information ******\n"
  		       "        Input file              :       %s\n"
  		       "        Output file             :       %s\n"
! 		       "        Real Time (secs)        : %14.6lf\n"
! 		       "        User Time (secs)        : %14.6lf\n"
! 		       "        System Time (secs)      : %14.6lf\n"
! 		       "        File Size (MB)          : %14.6lf\n"
! 		       "        Transfer Rate (MB/s)    : %14.6lf\n",
  		       progname, src, tgt,
  		       f,
  		       tv2f(ru2.ru_utime) - tv2f(ru1.ru_utime),
Common subdirectories: heirloom-060122/cpio and heirloom-060122-patched/cpio
Only in heirloom-060122-patched/cpio: Makefile
diff -c heirloom-060122/cpio/cpio.c heirloom-060122-patched/cpio/cpio.c
*** heirloom-060122/cpio/cpio.c Sun Jan 22 18:38:45 2006
--- heirloom-060122-patched/cpio/cpio.c Tue Oct 17 22:57:51 2006
***************
*** 46,52 ****
  #include <sys/wait.h>
  #include <fcntl.h>
  #include <stdlib.h>
! #include <malloc.h>
  #include <string.h>
  #include <unistd.h>
  #include <signal.h>
--- 46,54 ----
  #include <sys/wait.h>
  #include <fcntl.h>
  #include <stdlib.h>
! #ifndef _MINIX
! #include <malloc.h>
! #endif
  #include <string.h>
  #include <unistd.h>
  #include <signal.h>
***************
*** 77,83 ****
  
  #if defined (__linux__) || defined (__sun) || defined (__FreeBSD__) || \
  	defined (__hpux) || defined (_AIX) || defined (__NetBSD__) || \
! 	defined (__OpenBSD__) || defined (__DragonFly__) || defined (__APPLE__)
  #include <sys/mtio.h>
  #else	/* SVR4.2MP */
  #include <sys/scsi.h>
--- 79,86 ----
  
  #if defined (__linux__) || defined (__sun) || defined (__FreeBSD__) || \
  	defined (__hpux) || defined (_AIX) || defined (__NetBSD__) || \
! 	defined (__OpenBSD__) || defined (__DragonFly__) || defined (__APPLE__) ||\
!     defined (_MINIX)
  #include <sys/mtio.h>
  #else	/* SVR4.2MP */
  #include <sys/scsi.h>
***************
*** 116,121 ****
--- 119,127 ----
   * a variety of other reasons anyway, so this should not be of much
   * concern.
   */
+ #ifdef _MINIX
+ #define S_IFSOCK 0140000
+ #endif
  #if	S_IFIFO	!= 0010000 || \
  	S_IFCHR	!= 0020000 || \
  	S_IFDIR	!= 0040000 || \
***************
*** 254,259 ****
--- 260,266 ----
  		((uint32_t)(cp[1]&0377) << 24);
  }
  
+ #ifndef _MINIX
  static uint64_t
  ple64(const char *cp)
  {
***************
*** 279,284 ****
--- 286,292 ----
  		((uint64_t)(cp[1]&0377) << 48) +
  		((uint64_t)(cp[0]&0377) << 56);
  }
+ #endif
  
  static void
  le16p(uint16_t n, char *cp)
***************
*** 321,326 ****
--- 329,335 ----
  	cp[1] = (n&0xff000000) >> 24;
  }
  
+ #ifndef _MINIX
  static void
  le64p(uint64_t n, char *cp)
  {
***************
*** 346,351 ****
--- 355,361 ----
  	cp[1] = (n&0x00ff000000000000LL) >> 48;
  	cp[0] = (n&0xff00000000000000LL) >> 56;
  }
+ #endif
  
  #define	TNAMSIZ	100
  #define	TPFXSIZ	155
***************
*** 578,586 ****
  static struct	zipstuff {		/* stuff for central directory at EOF */
  	struct zipstuff	*zs_next;
  	char	*zs_name;		/* file name */
! 	long long	zs_size;	/* file size */
! 	long long	zs_relative;	/* offset of local header */
! 	long long	zs_csize;	/* compressed size */
  	uint32_t	zs_crc32;	/* CRC */
  	time_t		zs_mtime;	/* modification time */
  	enum cmethod	zs_cmethod;	/* compression method */
--- 588,596 ----
  static struct	zipstuff {		/* stuff for central directory at EOF */
  	struct zipstuff	*zs_next;
  	char	*zs_name;		/* file name */
! 	LONGLONG	zs_size;	/* file size */
! 	LONGLONG	zs_relative;	/* offset of local header */
! 	LONGLONG	zs_csize;	/* compressed size */
  	uint32_t	zs_crc32;	/* CRC */
  	time_t		zs_mtime;	/* modification time */
  	enum cmethod	zs_cmethod;	/* compression method */
***************
*** 731,743 ****
  static uint32_t		fakedev;	/* fake device for single link inodes */
  static uint32_t		fakeino;	/* fake inode for single link inodes */
  static uint32_t		harddev;	/* fake device used for hard links */
! static unsigned long long	maxsize;/* maximum size for format */
! static unsigned long long	maxrdev;/* maximum st_rdev for format */
! static unsigned long long	maxmajor;/* maximum major(st_rdev) for format */
! static unsigned long long	maxminor;/* maximum minor(st_rdev) for format */
! static unsigned long long	maxuid;	/* maximum user id for format */
! static unsigned long long	maxgid;	/* maximum group id for format */
! static unsigned long long	maxnlink;/* maximum link count for format */
  static int		mt;		/* magtape file descriptor */
  static int		mfl;		/* magtape flags */
  static struct stat	mtst;		/* fstat() on mt */
--- 741,753 ----
  static uint32_t		fakedev;	/* fake device for single link inodes */
  static uint32_t		fakeino;	/* fake inode for single link inodes */
  static uint32_t		harddev;	/* fake device used for hard links */
! static unsigned LONGLONG	maxsize;/* maximum size for format */
! static unsigned LONGLONG	maxrdev;/* maximum st_rdev for format */
! static unsigned LONGLONG	maxmajor;/* maximum major(st_rdev) for format */
! static unsigned LONGLONG	maxminor;/* maximum minor(st_rdev) for format */
! static unsigned LONGLONG	maxuid;	/* maximum user id for format */
! static unsigned LONGLONG	maxgid;	/* maximum group id for format */
! static unsigned LONGLONG	maxnlink;/* maximum link count for format */
  static int		mt;		/* magtape file descriptor */
  static int		mfl;		/* magtape flags */
  static struct stat	mtst;		/* fstat() on mt */
***************
*** 774,787 ****
  int			Vflag;		/* special verbose */
  int			sixflag;	/* 6th Edition archives */
  int			action;		/* -i -o -p */
! long long		errcnt;		/* error status */
! static unsigned long long	maxpath;/* maximum path length with -i */
  static uint32_t		maxino;		/* maximum inode number with -i */
  static uid_t		myuid;		/* user id of caller */
  static gid_t		mygid;		/* group id of caller */
! static long long	blocks;		/* copying statistics: full blocks */
! static long long	bytes;		/* copying statistics: partial blocks */
! static long long	nwritten;	/* bytes written to archive */
  static off_t		aoffs;		/* offset in archive */
  static off_t		poffs;		/* physical offset in archive */
  static int		tapeblock = -1;	/* physical tape block size */
--- 784,797 ----
  int			Vflag;		/* special verbose */
  int			sixflag;	/* 6th Edition archives */
  int			action;		/* -i -o -p */
! LONGLONG		errcnt;		/* error status */
! static unsigned LONGLONG	maxpath;/* maximum path length with -i */
  static uint32_t		maxino;		/* maximum inode number with -i */
  static uid_t		myuid;		/* user id of caller */
  static gid_t		mygid;		/* group id of caller */
! static LONGLONG	blocks;		/* copying statistics: full blocks */
! static LONGLONG	bytes;		/* copying statistics: partial blocks */
! static LONGLONG	nwritten;	/* bytes written to archive */
  static off_t		aoffs;		/* offset in archive */
  static off_t		poffs;		/* physical offset in archive */
  static int		tapeblock = -1;	/* physical tape block size */
***************
*** 805,811 ****
  static enum {
  	PO_NONE		= 0,
  	PO_LINKDATA	= 01,		/* include link data in type 2 */
! 	PO_TIMES	= 02,		/* create atime and mtime fields */
  } pax_oflag;				/* recognized -o options */
  
  static void	copyout(int (*)(const char *, struct stat *));
--- 815,821 ----
  static enum {
  	PO_NONE		= 0,
  	PO_LINKDATA	= 01,		/* include link data in type 2 */
! 	PO_TIMES	= 02		/* create atime and mtime fields */
  } pax_oflag;				/* recognized -o options */
  
  static void	copyout(int (*)(const char *, struct stat *));
***************
*** 865,881 ****
  			int (*)(struct file *, const char *, int));
  static int	indata(struct file *, const char *, int);
  static int	totrailer(void);
! static long long	rdoct(const char *, int);
! static long long	rdhex(const char *, int);
! static ssize_t	mread(void);
! static void	mstat(void);
! static int	skippad(unsigned long long, int);
  static int	allzero(const char *, int);
  static const char	*getuser(uid_t);
  static const char	*getgroup(gid_t);
  static struct glist	*want(struct file *, struct glist **);
  static void	patfile(void);
! static int	ckodd(long long, int, const char *, const char *);
  static int	rname(char **, size_t *);
  static int	redirect(const char *, const char *);
  static char	*tnameof(struct tar_header *, char *);
--- 875,891 ----
  			int (*)(struct file *, const char *, int));
  static int	indata(struct file *, const char *, int);
  static int	totrailer(void);
! static LONGLONG	rdoct(const char *, int);
! static LONGLONG	rdhex(const char *, int);
! static ssize_t	mread(void);
! static void	mstat(void);
! static int	skippad(unsigned LONGLONG, int);
  static int	allzero(const char *, int);
  static const char	*getuser(uid_t);
  static const char	*getgroup(gid_t);
  static struct glist	*want(struct file *, struct glist **);
  static void	patfile(void);
! static int	ckodd(LONGLONG, int, const char *, const char *);
  static int	rname(char **, size_t *);
  static int	redirect(const char *, const char *);
  static char	*tnameof(struct tar_header *, char *);
***************
*** 904,921 ****
  static void	mkdostime(time_t, char *, char *);
  static ssize_t	ziprxtra(struct file *, struct zip_header *);
  static void	ziptrailer(void);
! static void	zipdefer(const char *, struct stat *, long long,
! 			uint32_t, long long, const struct zip_header *);
! static int	zipwrite(int, const char *, struct stat *,
! 			union bincpio *, size_t, uint32_t, uint32_t,
! 			uint32_t *, long long *);
! static int	zipwtemp(int, const char *, struct stat *,
! 			union bincpio *, size_t, uint32_t, uint32_t,
! 			uint32_t *, long long *);
  #if USE_ZLIB
  static int	zipwdesc(int, const char *, struct stat *,
  			union bincpio *, size_t, uint32_t, uint32_t,
! 			uint32_t *, long long *);
  #endif	/* USE_ZLIB */
  static int	zipwxtra(const char *, struct stat *, uint32_t, uint32_t);
  static void	zipinfo(struct file *);
--- 914,931 ----
  static void	mkdostime(time_t, char *, char *);
  static ssize_t	ziprxtra(struct file *, struct zip_header *);
  static void	ziptrailer(void);
! static void	zipdefer(const char *, struct stat *, LONGLONG,
! 			uint32_t, LONGLONG, const struct zip_header *);
! static int	zipwrite(int, const char *, struct stat *,
! 			union bincpio *, size_t, uint32_t, uint32_t,
! 			uint32_t *, LONGLONG *);
! static int	zipwtemp(int, const char *, struct stat *,
! 			union bincpio *, size_t, uint32_t, uint32_t,
! 			uint32_t *, LONGLONG *);
  #if USE_ZLIB
  static int	zipwdesc(int, const char *, struct stat *,
  			union bincpio *, size_t, uint32_t, uint32_t,
! 			uint32_t *, LONGLONG *);
  #endif	/* USE_ZLIB */
  static int	zipwxtra(const char *, struct stat *, uint32_t, uint32_t);
  static void	zipinfo(struct file *);
***************
*** 926,932 ****
  static enum paxrec	tgetrec(char **, char **, char **);
  static void	wrpax(const char *, const char *, struct stat *);
  static void	addrec(char **, long *, long *,
! 			const char *, const char *, long long);
  static void	paxnam(struct tar_header *, const char *);
  static char	*sequence(void);
  static char	*joinpath(const char *, char *);
--- 936,942 ----
  static enum paxrec	tgetrec(char **, char **, char **);
  static void	wrpax(const char *, const char *, struct stat *);
  static void	addrec(char **, long *, long *,
! 			const char *, const char *, LONGLONG);
  static void	paxnam(struct tar_header *, const char *);
  static char	*sequence(void);
  static char	*joinpath(const char *, char *);
***************
*** 1253,1267 ****
  	}
  	if (((st->st_mode&S_IFMT)==S_IFBLK||(st->st_mode&S_IFMT)==S_IFCHR) &&
  		(maxrdev &&
! 			(unsigned long long)st->st_rdev > maxrdev ||
! 		maxmajor &&
! 			(unsigned long long)major(st->st_rdev) > maxmajor ||
! 		maxminor &&
! 			(unsigned long long)minor(st->st_rdev) > maxminor)) {
  		cantsup(1, file);
  		return 1;
  	}
! 	if ((unsigned long long)st->st_uid > maxuid) {
  		if (cray_eflag) {
  			cantsup(1, file);
  			return 1;
--- 1263,1277 ----
  	}
  	if (((st->st_mode&S_IFMT)==S_IFBLK||(st->st_mode&S_IFMT)==S_IFCHR) &&
  		(maxrdev &&
! 			(unsigned LONGLONG)st->st_rdev > maxrdev ||
! 		maxmajor &&
! 			(unsigned LONGLONG)major(st->st_rdev) > maxmajor ||
! 		maxminor &&
! 			(unsigned LONGLONG)minor(st->st_rdev) > maxminor)) {
  		cantsup(1, file);
  		return 1;
  	}
! 	if ((unsigned LONGLONG)st->st_uid > maxuid) {
  		if (cray_eflag) {
  			cantsup(1, file);
  			return 1;
***************
*** 1270,1281 ****
  		st->st_uid = 60001;
  		if ((st->st_mode&S_IFMT) == S_IFREG && st->st_mode & 0111)
  			st->st_mode &= ~(mode_t)S_ISUID;
! 		if ((unsigned long long)st->st_gid > maxgid) {
  			st->st_gid = 60001;
  			if ((st->st_mode&S_IFMT)==S_IFREG && st->st_mode&0010)
  				st->st_mode &= ~(mode_t)S_ISGID;
  		}
! 	} else if ((unsigned long long)st->st_gid > maxgid) {
  		if (cray_eflag) {
  			cantsup(1, file);
  			return 1;
--- 1280,1291 ----
  		st->st_uid = 60001;
  		if ((st->st_mode&S_IFMT) == S_IFREG && st->st_mode & 0111)
  			st->st_mode &= ~(mode_t)S_ISUID;
! 		if ((unsigned LONGLONG)st->st_gid > maxgid) {
  			st->st_gid = 60001;
  			if ((st->st_mode&S_IFMT)==S_IFREG && st->st_mode&0010)
  				st->st_mode &= ~(mode_t)S_ISGID;
  		}
! 	} else if ((unsigned LONGLONG)st->st_gid > maxgid) {
  		if (cray_eflag) {
  			cantsup(1, file);
  			return 1;
***************
*** 1441,1454 ****
  {
  	union bincpio bc;
  	int fd = -1;
! 	long long size;
! 	int pad, i;
! 	ssize_t rsz = 0, wsz = 0, hsz, fsz, psz;
! 	long long remsz, relative, nlink;
! 	long long Kbase = 0, Krest = 0, Ksize = 0;
! 	struct hdr_cpio	K2hdr;
! 	uint32_t	crc = 0;
! 	long long	csize = 0;
  	char	*file;
  	char	*symblink = NULL;
  	int	failure = 1;
--- 1451,1464 ----
  {
  	union bincpio bc;
  	int fd = -1;
! 	LONGLONG size;
! 	int pad, i;
! 	ssize_t rsz = 0, wsz = 0, hsz, fsz, psz;
! 	LONGLONG remsz, relative, nlink;
! 	LONGLONG Kbase = 0, Krest = 0, Ksize = 0;
! 	struct hdr_cpio	K2hdr;
! 	uint32_t	crc = 0;
! 	LONGLONG	csize = 0;
  	char	*file;
  	char	*symblink = NULL;
  	int	failure = 1;
***************
*** 1481,1487 ****
  		symblink[size] = '\0';
  	} else
  		size = 0;
! 	nlink = ((unsigned long long)st->st_nlink>maxnlink ?
  			maxnlink : st->st_nlink);
  	if (fmttype & TYP_NCPIO) {
  		long	size1;
--- 1491,1497 ----
  		symblink[size] = '\0';
  	} else
  		size = 0;
! 	nlink = ((unsigned LONGLONG)st->st_nlink>maxnlink ?
  			maxnlink : st->st_nlink);
  	if (fmttype & TYP_NCPIO) {
  		long	size1;
***************
*** 1559,1565 ****
  		 * To avoid gcc's stupid 'comparison is always false due to
  		 * limited range of data type' warning.
  		 */
! 		unsigned long long	gcccrap;
  		pad = 2;
  		if (fmttype & TYP_BE) {
  			be16p(mag_bin, bc.Hdr.c_magic);
--- 1569,1575 ----
  		 * To avoid gcc's stupid 'comparison is always false due to
  		 * limited range of data type' warning.
  		 */
! 		unsigned LONGLONG	gcccrap;
  		pad = 2;
  		if (fmttype & TYP_BE) {
  			be16p(mag_bin, bc.Hdr.c_magic);
***************
*** 1606,1613 ****
  		if (fmttype & TYP_SGI &&
  				(((st->st_mode&S_IFMT) == S_IFBLK ||
  				 (st->st_mode&S_IFMT) == S_IFCHR) &&
! 				((unsigned long long)major(st->st_rdev)>0xFF ||
! 				 (unsigned long long)minor(st->st_rdev)>0xFF) ||
  				(gcccrap = st->st_rdev) > 0177777)) {
  			uint32_t	rdev;
  			rdev = (minor(st->st_rdev) & 0x0003FFFF) +
--- 1616,1623 ----
  		if (fmttype & TYP_SGI &&
  				(((st->st_mode&S_IFMT) == S_IFBLK ||
  				 (st->st_mode&S_IFMT) == S_IFCHR) &&
! 				((unsigned LONGLONG)major(st->st_rdev)>0xFF ||
! 				 (unsigned LONGLONG)minor(st->st_rdev)>0xFF) ||
  				(gcccrap = st->st_rdev) > 0177777)) {
  			uint32_t	rdev;
  			rdev = (minor(st->st_rdev) & 0x0003FFFF) +
***************
*** 1651,1657 ****
  		sprintf(bc.Bdr.b_gid, "%7.7lo", (long)st->st_gid);
  		sprintf(bc.Bdr.b_size, "%11.11llo",
  				(st->st_mode&S_IFMT) == S_IFREG && !zerolink ?
! 				(long long)st->st_size&077777777777LL : 0LL);
  		sprintf(bc.Bdr.b_mtime, "%11.11lo", (long)st->st_mtime);
  		sprintf(bc.Bdr.b_rdev, "%7.7lo", (long)st->st_rdev);
  		strcpy(&bc.data[SIZEOF_bar_header], file);
--- 1661,1667 ----
  		sprintf(bc.Bdr.b_gid, "%7.7lo", (long)st->st_gid);
  		sprintf(bc.Bdr.b_size, "%11.11llo",
  				(st->st_mode&S_IFMT) == S_IFREG && !zerolink ?
! 				(LONGLONG)st->st_size&077777777777LL : 0LL);
  		sprintf(bc.Bdr.b_mtime, "%11.11lo", (long)st->st_mtime);
  		sprintf(bc.Bdr.b_rdev, "%7.7lo", (long)st->st_rdev);
  		strcpy(&bc.data[SIZEOF_bar_header], file);
***************
*** 1722,1728 ****
  				(st->st_mode&S_IFMT) == S_IFREG &&
  				(!zerolink || fmttype == FMT_PAX &&
  				 	pax_oflag & PO_LINKDATA) ?
! 				(long long)st->st_size&077777777777LL : 0LL);
  			if (fmttype & TYP_PAX &&
  					(st->st_mode&S_IFMT) == S_IFREG &&
  					st->st_size > 077777777777LL &&
--- 1732,1738 ----
  				(st->st_mode&S_IFMT) == S_IFREG &&
  				(!zerolink || fmttype == FMT_PAX &&
  				 	pax_oflag & PO_LINKDATA) ?
! 				(LONGLONG)st->st_size&077777777777LL : 0LL);
  			if (fmttype & TYP_PAX &&
  					(st->st_mode&S_IFMT) == S_IFREG &&
  					st->st_size > 077777777777LL &&
***************
*** 1769,1781 ****
  				msg(1, 0, "could not get group information "
  						"for %s\n", realfile);
  			if (fmttype == FMT_GNUTAR &&
! 					(unsigned long long)major(st->st_rdev)
  					> 077777777) {
  				be64p(major(st->st_rdev), bc.Tdr.t_devmajor);
  				bc.Tdr.t_devmajor[0] |= 0200;
  			} else {
  				if (fmttype == FMT_SUN &&
! 					(unsigned long long)major(st->st_rdev)
  						> 077777777 &&
  						((st->st_mode&S_IFMT)==S_IFBLK||
  						 (st->st_mode&S_IFMT)==S_IFCHR))
--- 1779,1791 ----
  				msg(1, 0, "could not get group information "
  						"for %s\n", realfile);
  			if (fmttype == FMT_GNUTAR &&
! 					(unsigned LONGLONG)major(st->st_rdev)
  					> 077777777) {
  				be64p(major(st->st_rdev), bc.Tdr.t_devmajor);
  				bc.Tdr.t_devmajor[0] |= 0200;
  			} else {
  				if (fmttype == FMT_SUN &&
! 					(unsigned LONGLONG)major(st->st_rdev)
  						> 077777777 &&
  						((st->st_mode&S_IFMT)==S_IFBLK||
  						 (st->st_mode&S_IFMT)==S_IFCHR))
***************
*** 1784,1796 ****
  					(int)major(st->st_rdev)&07777777);
  			}
  			if (fmttype == FMT_GNUTAR &&
! 					(unsigned long long)minor(st->st_rdev)
  					> 077777777) {
  				be64p(minor(st->st_rdev), bc.Tdr.t_devminor);
  				bc.Tdr.t_devminor[0] |= 0200;
  			} else {
  				if (fmttype == FMT_SUN &&
! 					(unsigned long long)minor(st->st_rdev)
  						> 077777777 &&
  						((st->st_mode&S_IFMT)==S_IFBLK||
  						 (st->st_mode&S_IFMT)==S_IFCHR))
--- 1794,1806 ----
  					(int)major(st->st_rdev)&07777777);
  			}
  			if (fmttype == FMT_GNUTAR &&
! 					(unsigned LONGLONG)minor(st->st_rdev)
  					> 077777777) {
  				be64p(minor(st->st_rdev), bc.Tdr.t_devminor);
  				bc.Tdr.t_devminor[0] |= 0200;
  			} else {
  				if (fmttype == FMT_SUN &&
! 					(unsigned LONGLONG)minor(st->st_rdev)
  						> 077777777 &&
  						((st->st_mode&S_IFMT)==S_IFBLK||
  						 (st->st_mode&S_IFMT)==S_IFCHR))
***************
*** 2676,2682 ****
  		return 0;
  #ifdef	__linux__
  	if (f->f_st.st_size > 0) {
! 		long long	sent;
  
  		sent = sfile(tfd, f->f_fd, f->f_st.st_mode, f->f_st.st_size);
  		blocks += (sent + 0777) >> 9;
--- 2686,2692 ----
  		return 0;
  #ifdef	__linux__
  	if (f->f_st.st_size > 0) {
! 		LONGLONG	sent;
  
  		sent = sfile(tfd, f->f_fd, f->f_st.st_mode, f->f_st.st_size);
  		blocks += (sent + 0777) >> 9;
***************
*** 3629,3635 ****
  {
  	long	namlen, l1, l2, rd, hsz;
  	static long	attempts;
! 	long long	skipped = 0;
  
  	if (fmttype & TYP_TAR) {
  		if (f->f_name)
--- 3639,3645 ----
  {
  	long	namlen, l1, l2, rd, hsz;
  	static long	attempts;
! 	LONGLONG	skipped = 0;
  
  	if (fmttype & TYP_TAR) {
  		if (f->f_name)
***************
*** 4156,4162 ****
  		 * of the name are non-null.
  		 */
  		struct cray_hdr	*Cp = (struct cray_hdr *)blkbuf;
! 		long long	mtime, namesize;
  		fmttype = FMT_CRAY;
  		mtime = pbe64(Cp->C_mtime - CRAY_PARAMSZ);
  		namesize = pbe64(Cp->C_namesize - CRAY_PARAMSZ);
--- 4166,4172 ----
  		 * of the name are non-null.
  		 */
  		struct cray_hdr	*Cp = (struct cray_hdr *)blkbuf;
! 		LONGLONG	mtime, namesize;
  		fmttype = FMT_CRAY;
  		mtime = pbe64(Cp->C_mtime - CRAY_PARAMSZ);
  		namesize = pbe64(Cp->C_namesize - CRAY_PARAMSZ);
***************
*** 4264,4270 ****
  	char	*buf;
  	size_t	bufsize;
  	struct stat	ts;
! 	long long	size;
  	ssize_t	rd;
  	uint32_t	ssum = 0, usum = 0;
  	int	val = 0;
--- 4274,4280 ----
  	char	*buf;
  	size_t	bufsize;
  	struct stat	ts;
! 	LONGLONG	size;
  	ssize_t	rd;
  	uint32_t	ssum = 0, usum = 0;
  	int	val = 0;
***************
*** 4327,4333 ****
  skipfile(struct file *f)
  {
  	char	b[4096];
! 	long long	size;
  	ssize_t	rd;
  
  	if (fmttype & TYP_TAR && ((f->f_st.st_mode&S_IFMT) == S_IFLNK ||
--- 4337,4343 ----
  skipfile(struct file *f)
  {
  	char	b[4096];
! 	LONGLONG	size;
  	ssize_t	rd;
  
  	if (fmttype & TYP_TAR && ((f->f_st.st_mode&S_IFMT) == S_IFLNK ||
***************
*** 4483,4493 ****
  	return 1;
  }
  
! static long long
  rdoct(const char *data, int len)
  {
  	int	i;
! 	long long	val = 0;
  
  	for (i = 0; i < len && data[i] == ' '; i++);
  	for ( ; i < len && data[i] && data[i] != ' '; i++) {
--- 4493,4503 ----
  	return 1;
  }
  
! static LONGLONG
  rdoct(const char *data, int len)
  {
  	int	i;
! 	LONGLONG	val = 0;
  
  	for (i = 0; i < len && data[i] == ' '; i++);
  	for ( ; i < len && data[i] && data[i] != ' '; i++) {
***************
*** 4497,4507 ****
  	return val;
  }
  
! static long long
  rdhex(const char *data, int len)
  {
  	int	i;
! 	long long	val = 0;
  
  	for (i = 0; i < len && data[i] == ' '; i++);
  	for ( ; i < len && data[i] && data[i] != ' '; i++) {
--- 4507,4517 ----
  	return val;
  }
  
! static LONGLONG
  rdhex(const char *data, int len)
  {
  	int	i;
! 	LONGLONG	val = 0;
  
  	for (i = 0; i < len && data[i] == ' '; i++);
  	for ( ; i < len && data[i] && data[i] != ' '; i++) {
***************
*** 4753,4759 ****
   * Skip tape data such that size becomes aligned to pad.
   */
  static int
! skippad(unsigned long long size, int pad)
  {
  	char	b[512];
  	int	to;
--- 4763,4769 ----
   * Skip tape data such that size becomes aligned to pad.
   */
  static int
! skippad(unsigned LONGLONG size, int pad)
  {
  	char	b[512];
  	int	to;
***************
*** 4966,4972 ****
  }
  
  static int
! ckodd(long long size, int mod, const char *str, const char *fn)
  {
  	if (size % mod) {
  		msg(3, 0, "Cannot swap %s of \"%s\", odd number of %s\n",
--- 4976,4982 ----
  }
  
  static int
! ckodd(LONGLONG size, int mod, const char *str, const char *fn)
  {
  	if (size % mod) {
  		msg(3, 0, "Cannot swap %s of \"%s\", odd number of %s\n",
***************
*** 5550,5555 ****
--- 5560,5567 ----
  zipreaddesc(struct file *f)
  {
  	if (f->f_oflag & OF_ZIP64) {
+ #ifdef _MINIX
+ #else
  		struct	zipddesc64	zd64;
  		bread((char *)&zd64, SIZEOF_zipddesc64);
  		if (memcmp(zd64.zd_signature, mag_zipdds, sizeof mag_zipdds))
***************
*** 5559,5564 ****
--- 5571,5577 ----
  			0xFFFFFFFFFFFFFFFFULL;
  		f->f_csize = ple64(zd64.zd_csize) &
  			0xFFFFFFFFFFFFFFFFULL;
+ #endif
  	} else {
  		struct	zipddesc zd;
  		bread((char *)&zd, SIZEOF_zipddesc);
***************
*** 5758,5764 ****
  	struct zipstuff	*zs;
  	struct zipcentral	zc;
  	struct zipend	ze;
! 	long long	cpstart, cpend, entries = 0;
  	size_t	sz;
  
  	cpstart = nwritten;
--- 5771,5777 ----
  	struct zipstuff	*zs;
  	struct zipcentral	zc;
  	struct zipend	ze;
! 	LONGLONG	cpstart, cpend, entries = 0;
  	size_t	sz;
  
  	cpstart = nwritten;
***************
*** 5852,5859 ****
   * Store the data later needed for the central directory.
   */
  static void
! zipdefer(const char *fn, struct stat *st, long long relative,
! 		uint32_t crc, long long csize, const struct zip_header *zh)
  {
  	struct zipstuff	*zp;
  
--- 5865,5872 ----
   * Store the data later needed for the central directory.
   */
  static void
! zipdefer(const char *fn, struct stat *st, LONGLONG relative,
! 		uint32_t crc, LONGLONG csize, const struct zip_header *zh)
  {
  	struct zipstuff	*zp;
  
***************
*** 5883,5889 ****
   */
  static int
  zipwrite(int fd, const char *fn, struct stat *st, union bincpio *bp, size_t sz,
! 		uint32_t dev, uint32_t ino, uint32_t *crc, long long *csize)
  {
  #if USE_ZLIB
  	struct z_stream_s	z;
--- 5896,5902 ----
   */
  static int
  zipwrite(int fd, const char *fn, struct stat *st, union bincpio *bp, size_t sz,
! 		uint32_t dev, uint32_t ino, uint32_t *crc, LONGLONG *csize)
  {
  #if USE_ZLIB
  	struct z_stream_s	z;
***************
*** 5984,5990 ****
   */
  static int
  zipwtemp(int fd, const char *fn, struct stat *st, union bincpio *bp, size_t sz,
! 		uint32_t dev, uint32_t ino, uint32_t *crc, long long *csize)
  {
  	static int	tf = -1;
  	static char	tlate[] = "/var/tmp/cpioXXXXXX";
--- 5997,6003 ----
   */
  static int
  zipwtemp(int fd, const char *fn, struct stat *st, union bincpio *bp, size_t sz,
! 		uint32_t dev, uint32_t ino, uint32_t *crc, LONGLONG *csize)
  {
  	static int	tf = -1;
  	static char	tlate[] = "/var/tmp/cpioXXXXXX";
***************
*** 5994,6000 ****
  #endif	/* USE_ZLIB || USE_BZLIB */
  	struct zextra_64	zf;
  	struct zextra_64	*zfp = 0;
! 	long long	size = st->st_size;
  	const char	*sname;
  	int	cuse, sf;
  	ssize_t	rd;
--- 6007,6013 ----
  #endif	/* USE_ZLIB || USE_BZLIB */
  	struct zextra_64	zf;
  	struct zextra_64	*zfp = 0;
! 	LONGLONG	size = st->st_size;
  	const char	*sname;
  	int	cuse, sf;
  	ssize_t	rd;
***************
*** 6177,6188 ****
   */
  static int
  zipwdesc(int fd, const char *fn, struct stat *st, union bincpio *bp, size_t sz,
! 		uint32_t dev, uint32_t ino, uint32_t *crc, long long *csize)
  {
  	struct zextra_64	zf;
  	struct zextra_64	*zfp = 0;
  	char	ibuf[32768], obuf[32768];
! 	long long	size = st->st_size;
  	ssize_t	rd;
  	struct z_stream_s	z;
  	int	cuse;
--- 6190,6201 ----
   */
  static int
  zipwdesc(int fd, const char *fn, struct stat *st, union bincpio *bp, size_t sz,
! 		uint32_t dev, uint32_t ino, uint32_t *crc, LONGLONG *csize)
  {
  	struct zextra_64	zf;
  	struct zextra_64	*zfp = 0;
  	char	ibuf[32768], obuf[32768];
! 	LONGLONG	size = st->st_size;
  	ssize_t	rd;
  	struct z_stream_s	z;
  	int	cuse;
***************
*** 6366,6372 ****
  zipunbz2(struct file *f, const char *tgt, int tfd, int doswap, uint32_t *crc)
  {
  	bz_stream	bs;
! 	long long	isize = f->f_csize;
  	char	ibuf[4096], obuf[8192];
  	int	in, on, val = 0, ok;
  
--- 6379,6385 ----
  zipunbz2(struct file *f, const char *tgt, int tfd, int doswap, uint32_t *crc)
  {
  	bz_stream	bs;
! 	LONGLONG	isize = f->f_csize;
  	char	ibuf[4096], obuf[8192];
  	int	in, on, val = 0, ok;
  
***************
*** 6419,6425 ****
  struct	blasthow {
  	struct file	*bh_f;
  	const char	*bh_tgt;
! 	long long	bh_isize;
  	uint32_t	*bh_crc;
  	int		bh_tfd;
  	int		bh_doswap;
--- 6432,6438 ----
  struct	blasthow {
  	struct file	*bh_f;
  	const char	*bh_tgt;
! 	LONGLONG	bh_isize;
  	uint32_t	*bh_crc;
  	int		bh_tfd;
  	int		bh_doswap;
***************
*** 6620,6626 ****
  {
  	char	*keyword, *value;
  	char	*block, *bp;
! 	long long	n;
  	enum paxrec	pr;
  
  	n = rdoct(tp->t_size, 12);
--- 6633,6639 ----
  {
  	char	*keyword, *value;
  	char	*block, *bp;
! 	LONGLONG	n;
  	enum paxrec	pr;
  
  	n = rdoct(tp->t_size, 12);
***************
*** 6739,6745 ****
  	union bincpio	bc;
  	char	*pdata = NULL;
  	long	psize = 0, pcur = 0;
! 	long long	blocks;
  
  	memset(bc.data, 0, 512);
  	if (paxrec & PR_ATIME)
--- 6752,6758 ----
  	union bincpio	bc;
  	char	*pdata = NULL;
  	long	psize = 0, pcur = 0;
! 	LONGLONG	blocks;
  
  	memset(bc.data, 0, 512);
  	if (paxrec & PR_ATIME)
***************
*** 6783,6789 ****
  
  static void
  addrec(char **pdata, long *psize, long *pcur,
! 		const char *keyword, const char *sval, long long lval)
  {
  	char	dval[25], xval[25];
  	long	od, d, r;
--- 6796,6802 ----
  
  static void
  addrec(char **pdata, long *psize, long *pcur,
! 		const char *keyword, const char *sval, LONGLONG lval)
  {
  	char	dval[25], xval[25];
  	long	od, d, r;
***************
*** 6835,6841 ****
  sequence(void)
  {
  	static char	buf[25];
! 	static long long	d;
  
  	sprintf(buf, "%10.10lld", ++d);
  	return buf;
--- 6848,6854 ----
  sequence(void)
  {
  	static char	buf[25];
! 	static LONGLONG	d;
  
  	sprintf(buf, "%10.10lld", ++d);
  	return buf;
Only in heirloom-060122-patched/cpio: cpio.c~
diff -c heirloom-060122/cpio/cpio.h heirloom-060122-patched/cpio/cpio.h
*** heirloom-060122/cpio/cpio.h Sun Feb  6 11:58:52 2005
--- heirloom-060122-patched/cpio/cpio.h Tue Oct 17 23:00:13 2006
***************
*** 31,36 ****
--- 31,48 ----
  #include <sys/stat.h>
  #include <inttypes.h>
  
+ #ifdef _MINIX
+ #define LONGLONG long
+ #define LONGLONG_0LL    0L
+ #define MAX_LONGLONG    0x7fffffffL
+ #define MAX_ULONGLONG   0xffffffffL
+ #else
+ #define LONGLONG long long
+ #define LONGLONG_0LL    0LL
+ #define MAX_LONGLONG    0x7fffffffffffffffLL
+ #define MAX_ULONGLONG   0xffffffffffffffffLL
+ #endif
+ 
  enum	{
  	FMT_NONE	= 00000000,	/* no format chosen yet */
  
***************
*** 88,94 ****
  	C_ENHDEFLD	= 9,
  	C_DCLIMPLODED	= 10,
  	C_PKRESERVED	= 11,
! 	C_BZIP2		= 12,
  };
  
  /*
--- 100,106 ----
  	C_ENHDEFLD	= 9,
  	C_DCLIMPLODED	= 10,
  	C_PKRESERVED	= 11,
! 	C_BZIP2		= 12
  };
  
  /*
***************
*** 96,108 ****
   */
  struct	file {
  	struct stat	f_st;		/* file stat */
! 	long long	f_rmajor;	/* st_rdev major */
! 	long long	f_rminor;	/* st_rdev minor */
! 	long long	f_dsize;	/* display size */
! 	long long	f_csize;	/* compressed size */
! 	long long	f_Kbase;	/* base size for -K */
! 	long long	f_Krest;	/* rest size for -K */
! 	long long	f_Ksize;	/* faked -K size field */
  	char		*f_name;	/* file name */
  	size_t		f_nsiz;		/* file name size */
  	char		*f_lnam;	/* link name */
--- 108,120 ----
   */
  struct	file {
  	struct stat	f_st;		/* file stat */
! 	LONGLONG	f_rmajor;	/* st_rdev major */
! 	LONGLONG	f_rminor;	/* st_rdev minor */
! 	LONGLONG	f_dsize;	/* display size */
! 	LONGLONG	f_csize;	/* compressed size */
! 	LONGLONG	f_Kbase;	/* base size for -K */
! 	LONGLONG	f_Krest;	/* rest size for -K */
! 	LONGLONG	f_Ksize;	/* faked -K size field */
  	char		*f_name;	/* file name */
  	size_t		f_nsiz;		/* file name size */
  	char		*f_lnam;	/* link name */
***************
*** 164,170 ****
  extern int		Vflag;
  extern int		sixflag;
  extern int		action;
! extern long long	errcnt;
  extern int		blksiz;
  extern int		sysv3;
  extern int		printsev;
--- 176,182 ----
  extern int		Vflag;
  extern int		sixflag;
  extern int		action;
! extern LONGLONG	errcnt;
  extern int		blksiz;
  extern int		sysv3;
  extern int		printsev;
Only in heirloom-060122-patched/cpio: cpio.h~
Common subdirectories: heirloom-060122/csplit and heirloom-060122-patched/csplit
Only in heirloom-060122-patched/csplit: Makefile
diff -c heirloom-060122/csplit/csplit.c heirloom-060122-patched/csplit/csplit.c
*** heirloom-060122/csplit/csplit.c Sun May 29 12:55:39 2005
--- heirloom-060122-patched/csplit/csplit.c Wed Oct 18 01:13:10 2006
***************
*** 71,81 ****
  
  #include <iblok.h>
  
! static struct	arg {
! 	long long	a_no;
! 	long long	a_nx;
! 	long long	a_ro;
! 	long long	a_once;
  	const char	*a_op;
  	const char	*a_rp;
  #if defined (SUS) || defined (SU3)
--- 71,90 ----
  
  #include <iblok.h>
  
! #ifdef _MINIX
! #define LONGLONG long
! #define P_LLD "%ld"
! #define strtoll strtol
! #else
! #define LONGLONG long long
! #define P_LLD "%lld"
! #endif
! 
! static struct	arg {
! 	LONGLONG	a_no;
! 	LONGLONG	a_nx;
! 	LONGLONG	a_ro;
! 	LONGLONG	a_once;
  	const char	*a_op;
  	const char	*a_rp;
  #if defined (SUS) || defined (SU3)
***************
*** 98,104 ****
  static void	msg(int, const char *, ...);
  static void	scan(char *);
  static void	csplit(const char *);
! static int 	match(const char *, long long, long long *, int *);
  static FILE	*nextfile(void);
  static const char	*makename(int, int);
  static void	delfiles(void);
--- 107,113 ----
  static void	msg(int, const char *, ...);
  static void	scan(char *);
  static void	csplit(const char *);
! static int 	match(const char *, LONGLONG, LONGLONG *, int *);
  static FILE	*nextfile(void);
  static const char	*makename(int, int);
  static void	delfiles(void);
***************
*** 178,184 ****
  scan(char *s)
  {
  	static int	ncur = -1;
! 	long long	c;
  	char	*sp, *x;
  #if defined (SUS) || defined (SU3)
  	int	reflags;
--- 187,193 ----
  scan(char *s)
  {
  	static int	ncur = -1;
! 	LONGLONG	c;
  	char	*sp, *x;
  #if defined (SUS) || defined (SU3)
  	int	reflags;
***************
*** 241,247 ****
  	FILE	*op = NULL;
  	char	*line = 0, c = 0;
  	size_t	linesize = 0, linelen;
! 	long long	lineno = 0, oln = 1, xln = 1,
  			bytes = 0, noffs = 0, on, brks = 0;
  
  	if ((ip = fn[0] == '-' && fn[1] == '\0' ? ib_alloc(0, 0) :
--- 250,256 ----
  	FILE	*op = NULL;
  	char	*line = 0, c = 0;
  	size_t	linesize = 0, linelen;
! 	LONGLONG	lineno = 0, oln = 1, xln = 1,
  			bytes = 0, noffs = 0, on, brks = 0;
  
  	if ((ip = fn[0] == '-' && fn[1] == '\0' ? ib_alloc(0, 0) :
***************
*** 284,290 ****
  				op = nextfile();
  			if (op) {
  				if (!sflag)
! 					printf("%lld\n", bytes);
  				bytes = 0;
  				fclose(op);
  			}
--- 293,299 ----
  				op = nextfile();
  			if (op) {
  				if (!sflag)
! 					printf(P_LLD "\n", bytes);
  				bytes = 0;
  				fclose(op);
  			}
***************
*** 318,324 ****
  }
  
  static int
! match(const char *line, long long lineno, long long *noffp, int *skip)
  {
  	static int	ncur = -1;
  
--- 327,333 ----
  }
  
  static int
! match(const char *line, LONGLONG lineno, LONGLONG *noffp, int *skip)
  {
  	static int	ncur = -1;
  
Common subdirectories: heirloom-060122/cut and heirloom-060122-patched/cut
Only in heirloom-060122-patched/cut: Makefile
Common subdirectories: heirloom-060122/date and heirloom-060122-patched/date
Only in heirloom-060122-patched/date: Makefile
diff -c heirloom-060122/date/date.c heirloom-060122-patched/date/date.c
*** heirloom-060122/date/date.c Sun Jan 22 18:39:39 2006
--- heirloom-060122-patched/date/date.c Wed Oct 18 01:56:33 2006
***************
*** 46,53 ****
  #include	<libgen.h>
  #include	<time.h>
  #include	<locale.h>
! #include	<utmpx.h>
! #include	<langinfo.h>
  
  static unsigned	errcnt;			/* count of errors */
  static int	bflag;			/* boot flag: don't write wtmp */
--- 46,60 ----
  #include	<libgen.h>
  #include	<time.h>
  #include	<locale.h>
! #ifdef _MINIX
! #include    <utmp.h>
! #include    <sys/time.h>
! #define NEW_TIME 3
! #define OLD_TIME 4
! #else
! #include	<utmpx.h>
! #include	<langinfo.h>
! #endif
  
  static unsigned	errcnt;			/* count of errors */
  static int	bflag;			/* boot flag: don't write wtmp */
***************
*** 151,158 ****
  static void
  settime(char *op)
  {
! 	struct utmpx before, after;
! 	const char wtmpxfile[] = "/var/log/wtmp";
  	time_t newtime;
  
  	memset(&before, 0, sizeof before);
--- 158,171 ----
  static void
  settime(char *op)
  {
! #ifdef _MINIX
!     struct utmp before, after;
!     const char wtmpfile[] = WTMP;
!     struct timeval tv;
! #else
! 	struct utmpx before, after;
! 	const char wtmpxfile[] = "/var/log/wtmp";
! #endif
  	time_t newtime;
  
  	memset(&before, 0, sizeof before);
***************
*** 163,181 ****
  	strcpy(after.ut_line, "new time");
  	if ((newtime = timeop(op)) == (time_t)-1)
  		badconv();
! 	gettimeofday(&before.ut_tv, NULL);
  	if (stime(&newtime) < 0) {
  		fprintf(stderr, "%s: no permission\n", progname);
  		exit(1);
  	}
! 	gettimeofday(&after.ut_tv, NULL);
  #ifdef	__linux__
  	system("/sbin/hwclock -w >/dev/null 2>&1");
  #endif	/* __linux__ */
  	if (bflag == 0) {
! 		pututxline(&before);
! 		pututxline(&after);
! #if !defined (__hpux) && !defined (_AIX)
  		updwtmpx(wtmpxfile, &before);
  		updwtmpx(wtmpxfile, &after);
  #endif	/* !__hpux, !__AIX */
--- 176,208 ----
  	strcpy(after.ut_line, "new time");
  	if ((newtime = timeop(op)) == (time_t)-1)
  		badconv();
! #ifdef _MINIX
!     gettimeofday(&tv, NULL);
!     before.ut_time=tv.tv_sec;
! #else
! 	gettimeofday(&before.ut_tv, NULL);
! #endif
  	if (stime(&newtime) < 0) {
  		fprintf(stderr, "%s: no permission\n", progname);
  		exit(1);
  	}
! #ifdef _MINIX
!     gettimeofday(&tv, NULL);
!     after.ut_time=tv.tv_sec;
! #else
! 	gettimeofday(&after.ut_tv, NULL);
! #endif
  #ifdef	__linux__
  	system("/sbin/hwclock -w >/dev/null 2>&1");
  #endif	/* __linux__ */
  	if (bflag == 0) {
! #ifdef _MINIX
!         /* XXX append utmp entry to wtmpfile */
! #else
! 		pututxline(&before);
! 		pututxline(&after);
! #endif
! #if !defined (__hpux) && !defined (_AIX) && !defined(_MINIX)
  		updwtmpx(wtmpxfile, &before);
  		updwtmpx(wtmpxfile, &after);
  #endif	/* !__hpux, !__AIX */
***************
*** 222,229 ****
  							== NULL ||
  							*date_fmt == '\0')
  #endif	/* _DATE_FMT */
! 						date_fmt =
! 						"%a %b %e %H:%M:%S %Z %Y";
  					strcpy(fmt, date_fmt);
  					break;
  				case 'E':
--- 249,260 ----
  							== NULL ||
  							*date_fmt == '\0')
  #endif	/* _DATE_FMT */
! #ifndef _MINIX
! 						date_fmt =
! 						"%a %b %e %H:%M:%S %Z %Y";
! #else
!                         date_fmt = "%a %b %d %H:%M:%S %Z %Y";
! #endif
  					strcpy(fmt, date_fmt);
  					break;
  				case 'E':
***************
*** 279,284 ****
--- 310,318 ----
  static void
  adjust(char *op)
  {
+ #ifdef _MINIX
+     struct timeval tvnow;
+ #endif
  	struct timeval tv;
  	char *cp;
  
***************
*** 294,304 ****
--- 328,353 ----
  		tv.tv_sec = -tv.tv_sec;
  		tv.tv_usec = -tv.tv_usec;
  	}
+ #ifdef _MINIX
+     if (gettimeofday(&tvnow, NULL) < 0 ) {
+         fprintf(stderr, "%s: Failed to adjust date: %s\n", progname,
+                 strerror(errno));
+         exit(1);
+     }
+     tvnow.tv_sec  += tv.tv_sec;
+     tvnow.tv_usec += tv.tv_usec;
+ 	if (settimeofday(&tvnow, NULL) < 0 ) {
+         fprintf(stderr, "%s: Failed to adjust date: %s\n", progname,
+                 strerror(errno));
+         exit(1);
+     }
+ #else
  	if (adjtime(&tv, 0) < 0) {
  		fprintf(stderr, "%s: Failed to adjust date: %s\n", progname,
  				strerror(errno));
  		exit(1);
  	}
+ #endif
  	return;
  }
  
Common subdirectories: heirloom-060122/dc and heirloom-060122-patched/dc
Only in heirloom-060122-patched/dc: Makefile
Common subdirectories: heirloom-060122/dd and heirloom-060122-patched/dd
Only in heirloom-060122-patched/dd: Makefile
diff -c heirloom-060122/dd/dd.c heirloom-060122-patched/dd/dd.c
*** heirloom-060122/dd/dd.c Sun Jan 22 18:40:04 2006
--- heirloom-060122-patched/dd/dd.c Wed Oct 18 02:06:12 2006
***************
*** 41,47 ****
  #include	<stdio.h>
  #include	<string.h>
  #include	<stdlib.h>
! #include	<malloc.h>
  #include	<errno.h>
  #include	<libgen.h>
  #include	<ctype.h>
--- 41,49 ----
  #include	<stdio.h>
  #include	<string.h>
  #include	<stdlib.h>
! #ifndef _MINIX
! #include	<malloc.h>
! #endif
  #include	<errno.h>
  #include	<libgen.h>
  #include	<ctype.h>
***************
*** 56,62 ****
  
  #if defined (__linux__) || defined (__sun) || defined (__FreeBSD__) || \
  	defined (__hpux) || defined (_AIX) || defined (__NetBSD__) || \
! 	defined (__OpenBSD__) || defined (__DragonFly__) || defined (__APPLE__)
  #include	<sys/mtio.h>
  #else	/* SVR4.2MP */
  #include	<sys/scsi.h>
--- 58,65 ----
  
  #if defined (__linux__) || defined (__sun) || defined (__FreeBSD__) || \
  	defined (__hpux) || defined (_AIX) || defined (__NetBSD__) || \
! 	defined (__OpenBSD__) || defined (__DragonFly__) || defined (__APPLE__) || \
!     defined (_MINIX)
  #include	<sys/mtio.h>
  #else	/* SVR4.2MP */
  #include	<sys/scsi.h>
***************
*** 67,72 ****
--- 70,84 ----
  #include	"memalign.h"
  #include	"mbtowi.h"
  
+ #ifdef _MINIX
+ #define LONGLONG long
+ #define P_LLU "%lu"
+ #define strtoull strtoul
+ #else
+ #define LONGLONG long long
+ #define P_LLU "%llu"
+ #endif
+ 
  /*
   * For 'conv=ascii'.
   */
***************
*** 135,141 ****
  
  static char		*progname;	/* argv[0] to main() */
  
! typedef	long long	d_type;
  
  static char		*iblok;		/* input buffer */
  static char		*oblok;		/* output buffer */
--- 147,153 ----
  
  static char		*progname;	/* argv[0] to main() */
  
! typedef	LONGLONG	d_type;
  
  static char		*iblok;		/* input buffer */
  static char		*oblok;		/* output buffer */
***************
*** 423,437 ****
  static void
  stats(void)
  {
! 	fprintf(stderr, "%llu+%llu records in\n",
! 			(unsigned long long)iwhole,
! 			(unsigned long long)ipartial);
! 	fprintf(stderr, "%llu+%llu records out\n",
! 			(unsigned long long)owhole,
! 			(unsigned long long)opartial);
! 	if (truncated) {
! 		fprintf(stderr, "%llu truncated record%s\n",
! 				(unsigned long long)truncated,
  				truncated > 1 ? "s" : "");
  	}
  }
--- 435,449 ----
  static void
  stats(void)
  {
! 	fprintf(stderr, P_LLU "+" P_LLU " records in\n",
! 			(unsigned LONGLONG)iwhole,
! 			(unsigned LONGLONG)ipartial);
! 	fprintf(stderr, P_LLU "+" P_LLU " records out\n",
! 			(unsigned LONGLONG)owhole,
! 			(unsigned LONGLONG)opartial);
! 	if (truncated) {
! 		fprintf(stderr, P_LLU " truncated record%s\n",
! 				(unsigned LONGLONG)truncated,
  				truncated > 1 ? "s" : "");
  	}
  }
***************
*** 468,474 ****
  	if (yes == -1) {
  #if defined (__linux__) || defined (__FreeBSD__) || defined (__hpux) || \
  	defined (_AIX) || defined (__NetBSD__) || defined (__OpenBSD__) || \
! 	defined (__DragonFly__) || defined (__APPLE__)
  		struct mtget	mg;
  		yes = (istat.st_mode&S_IFMT) == S_IFCHR &&
  			ioctl(iffd, MTIOCGET, &mg) == 0;
--- 480,486 ----
  	if (yes == -1) {
  #if defined (__linux__) || defined (__FreeBSD__) || defined (__hpux) || \
  	defined (_AIX) || defined (__NetBSD__) || defined (__OpenBSD__) || \
! 	defined (__DragonFly__) || defined (__APPLE__) || defined (_MINIX)
  		struct mtget	mg;
  		yes = (istat.st_mode&S_IFMT) == S_IFCHR &&
  			ioctl(iffd, MTIOCGET, &mg) == 0;
Common subdirectories: heirloom-060122/deroff and heirloom-060122-patched/deroff
Only in heirloom-060122-patched/deroff: Makefile
Common subdirectories: heirloom-060122/df and heirloom-060122-patched/df
Only in heirloom-060122-patched/df: Makefile
diff -c heirloom-060122/df/df.c heirloom-060122-patched/df/df.c
*** heirloom-060122/df/df.c Sun Jan 22 18:42:39 2006
--- heirloom-060122-patched/df/df.c Wed Oct 18 02:57:16 2006
***************
*** 45,56 ****
   * - the use of getmntent(), which is Linux-specific.
   */
  
! typedef		unsigned long long	ull;
  
  #include	<pwd.h>
  #include	<sys/types.h>
  #include	<sys/stat.h>
! #if defined (__dietlibc__) || defined (__NetBSD__) || defined (__OpenBSD__)
  #include	"statvfs.c"
  #elif defined (__FreeBSD__) && (__FreeBSD__) < 5
  #include	"statvfs.c"
--- 45,61 ----
   * - the use of getmntent(), which is Linux-specific.
   */
  
! #ifdef _MINIX
! typedef		unsigned long 	ull;
! #else
! typedef		unsigned long long	ull;
! #endif
  
  #include	<pwd.h>
  #include	<sys/types.h>
  #include	<sys/stat.h>
! #if defined (__dietlibc__) || defined (__NetBSD__) || defined (__OpenBSD__) || \
!     defined (_MINIX)
  #include	"statvfs.c"
  #elif defined (__FreeBSD__) && (__FreeBSD__) < 5
  #include	"statvfs.c"
***************
*** 70,75 ****
--- 75,82 ----
  #include	<sys/param.h>
  #include	<sys/ucred.h>
  #include	<sys/mount.h>
+ #elif defined (_MINIX)
+ 
  #else	/* SVR4 */
  #include	<sys/mnttab.h>
  #endif	/* SVR4 */
***************
*** 466,471 ****
--- 473,480 ----
  		printfs(sp[i].f_mntonname, sp[i].f_mntfromname,
  				sp[i].f_fstypename);
  	}
+ #elif defined(_MINIX)   /* XXX put load_mtab and get_mtab_entry stuff here */
+ 
  #else	/* SVR4 */
  	FILE *fp;
  	struct mnttab	mt;
***************
*** 499,504 ****
--- 508,515 ----
  		|| defined (__DragonFly__) || defined (__APPLE__)
  	struct statfs	*sp = NULL;
  	int	count, i;
+ #elif defined(_MINIX)   /* XXX mtab stuff again, now for finding */
+     int i;
  #else	/* SVR4 */
  	struct mnttab mt;
  #endif	/* SVR4 */
***************
*** 522,527 ****
--- 533,540 ----
  		pnerror(errno, "getmntinfo");
  		exit(errcnt);
  	}
+ #elif defined (_MINIX)  /* XXX actual mtab stuff for finding */
+ 
  #else	/* SVR4 */
  	if ((fp = fopen(mtab, "r")) == NULL) {
  		pnerror(errno, mtab);
***************
*** 552,557 ****
--- 565,572 ----
  		m_special = sp[i].f_mntfromname;
  		m_mountp = sp[i].f_mntonname;
  		m_fstype = sp[i].f_fstypename;
+ #elif defined (_MINIX)  /* XXX i love italian food */
+     for (i=0; i==0; i++) {
  #else	/* SVR4 */
  	while (getmntent(fp, &mt) == 0) {
  		m_special = mt.mnt_special;
***************
*** 616,621 ****
--- 631,638 ----
  #elif defined	(__FreeBSD__) || defined (__NetBSD__) || defined (__OpenBSD__) \
  		|| defined (__DragonFly__) || defined (__APPLE__)
  	/* nothing */
+ #elif defined (_MINIX)  /* XXX end. */
+ 
  #else	/* SVR4 */
  	fclose(fp);
  #endif	/* SVR4 */
diff -c heirloom-060122/df/statvfs.c heirloom-060122-patched/df/statvfs.c
*** heirloom-060122/df/statvfs.c Sun Jan 22 18:42:39 2006
--- heirloom-060122-patched/df/statvfs.c Wed Oct 18 02:59:07 2006
***************
*** 21,28 ****
   */
  /*	Sccsid @(#)statvfs.c	1.6 (gritter) 1/22/06	*/
  
! typedef	unsigned long long	fsblkcnt_t;
! typedef	unsigned long long	fsfilcnt_t;
  
  struct statvfs {
  	unsigned long	f_bsize;
--- 21,33 ----
   */
  /*	Sccsid @(#)statvfs.c	1.6 (gritter) 1/22/06	*/
  
! #ifdef _MINIX
! typedef	unsigned long	fsblkcnt_t;
! typedef	unsigned long	fsfilcnt_t;
! #else
! typedef	unsigned long long	fsblkcnt_t;
! typedef	unsigned long long	fsfilcnt_t;
! #endif
  
  struct statvfs {
  	unsigned long	f_bsize;
***************
*** 44,49 ****
--- 49,60 ----
  	|| defined (__APPLE__)
  #include <sys/param.h>
  #include <sys/mount.h>
+ #elif defined (_MINIX)
+ #include <sys/statfs.h>
+ #include <limits.h>
+ #undef statfs   /* Minix does not have statfs yet. The incomplete struct is
+                    bogus anyway*/
+ #define statfs(a,b) (-1)
  #endif
  
  int
***************
*** 53,67 ****
  
  	if (statfs(path, &sf) < 0)
  		return -1;
  	buf->f_bsize = buf->f_frsize = sf.f_bsize;
  	buf->f_blocks = sf.f_blocks;
  	buf->f_bfree = sf.f_bfree;
  	buf->f_bavail = sf.f_bavail;
  	buf->f_files = sf.f_files;
  	buf->f_ffree = buf->f_favail = sf.f_ffree;
! 	buf->f_fsid = 0;
! #if !defined (__NetBSD__) && !defined (__FreeBSD__) && !defined (__OpenBSD__) \
! 		&& !defined (__APPLE__)
  	buf->f_namemax = sf.f_namelen;
  #else	/* __NetBSD__, __FreeBSD__, __OpenBSD__, __APPLE__ */
  	buf->f_namemax = PATH_MAX;
--- 64,80 ----
  
  	if (statfs(path, &sf) < 0)
  		return -1;
+ #ifndef _MINIX      /* XXX fix Minix libc to have a proper statfs struct */
  	buf->f_bsize = buf->f_frsize = sf.f_bsize;
  	buf->f_blocks = sf.f_blocks;
  	buf->f_bfree = sf.f_bfree;
  	buf->f_bavail = sf.f_bavail;
  	buf->f_files = sf.f_files;
  	buf->f_ffree = buf->f_favail = sf.f_ffree;
! #endif
! 	buf->f_fsid = 0;
! #if !defined (__NetBSD__) && !defined (__FreeBSD__) && !defined (__OpenBSD__) \
! 		&& !defined (__APPLE__) && !defined(_MINIX)
  	buf->f_namemax = sf.f_namelen;
  #else	/* __NetBSD__, __FreeBSD__, __OpenBSD__, __APPLE__ */
  	buf->f_namemax = PATH_MAX;
Common subdirectories: heirloom-060122/diff and heirloom-060122-patched/diff
Only in heirloom-060122-patched/diff: Makefile
diff -c heirloom-060122/diff/diffdir.c heirloom-060122-patched/diff/diffdir.c
*** heirloom-060122/diff/diffdir.c Sun Jan 22 18:43:07 2006
--- heirloom-060122-patched/diff/diffdir.c Wed Oct 18 02:17:25 2006
***************
*** 93,98 ****
--- 93,106 ----
  #endif	/* !S_IFSOCK */
  #endif	/* __GLIBC__ */
  
+ #ifdef _MINIX
+ #define LONGLONG long
+ #define P_LLD "%ld"
+ #else
+ #define LONGLONG long long
+ #define P_LLD "%lld"
+ #endif
+ 
  /*
   * diff - directory comparison
   */
***************
*** 104,110 ****
  #define	DIRECT	8		/* Directory */
  
  struct dir {
! 	unsigned long long	d_ino;
  	char	*d_entry;
  };
  
--- 112,118 ----
  #define	DIRECT	8		/* Directory */
  
  struct dir {
! 	unsigned LONGLONG	d_ino;
  	char	*d_entry;
  };
  
***************
*** 126,143 ****
  static void	putN(const char *, const char *, const char *, int);
  static void	putNreg(const char *, const char *, time_t, int);
  static void	putNnorm(FILE *, const char *, const char *,
! 			FILE *, long long, int);
! static void	putNedit(FILE *, const char *, const char *,
! 			FILE *, long long, int, int);
! static void	putNcntx(FILE *, const char *, const char *,
! 			time_t, FILE *, long long, int);
! static void	putNunif(FILE *, const char *, const char *,
! 			time_t, FILE *, long long, int);
  static void	putNhead(FILE *, const char *, const char *, time_t, int,
  			const char *, const char *);
  static void	putNdata(FILE *, FILE *, int, int);
  static void	putNdir(const char *, const char *, int);
! static long long	linec(const char *, FILE *);
  static char	*mkpath(const char *, const char *);
  static void	mktitle(void);
  static int	xclude(const char *);
--- 134,151 ----
  static void	putN(const char *, const char *, const char *, int);
  static void	putNreg(const char *, const char *, time_t, int);
  static void	putNnorm(FILE *, const char *, const char *,
! 			FILE *, LONGLONG, int);
! static void	putNedit(FILE *, const char *, const char *,
! 			FILE *, LONGLONG, int, int);
! static void	putNcntx(FILE *, const char *, const char *,
! 			time_t, FILE *, LONGLONG, int);
! static void	putNunif(FILE *, const char *, const char *,
! 			time_t, FILE *, LONGLONG, int);
  static void	putNhead(FILE *, const char *, const char *, time_t, int,
  			const char *, const char *);
  static void	putNdata(FILE *, FILE *, int, int);
  static void	putNdir(const char *, const char *, int);
! static LONGLONG	linec(const char *, FILE *);
  static char	*mkpath(const char *, const char *);
  static void	mktitle(void);
  static int	xclude(const char *);
***************
*** 711,717 ****
  static void
  putNreg(const char *fn, const char *on, time_t mtime, int which)
  {
! 	long long	lines;
  	FILE	*fp;
  	FILE	*op;
  	void	(*opipe)(int) = SIG_DFL;
--- 719,725 ----
  static void
  putNreg(const char *fn, const char *on, time_t mtime, int which)
  {
! 	LONGLONG	lines;
  	FILE	*fp;
  	FILE	*op;
  	void	(*opipe)(int) = SIG_DFL;
***************
*** 781,795 ****
  
  static void
  putNnorm(FILE *op, const char *fn, const char *on,
! 		FILE *fp, long long lines, int which)
  {
  	int	pfx;
  
  	if (which == 1) {
! 		fprintf(op, "1,%lldd0\n", lines);
! 		pfx = '<';
! 	} else {
! 		fprintf(op, "0a1,%lld\n", lines);
  		pfx = '>';
  	}
  	putNdata(op, fp, pfx, ' ');
--- 789,803 ----
  
  static void
  putNnorm(FILE *op, const char *fn, const char *on,
! 		FILE *fp, LONGLONG lines, int which)
  {
  	int	pfx;
  
  	if (which == 1) {
! 		fprintf(op, "1," P_LLD "d0\n", lines);
! 		pfx = '<';
! 	} else {
! 		fprintf(op, "0a1," P_LLD "\n", lines);
  		pfx = '>';
  	}
  	putNdata(op, fp, pfx, ' ');
***************
*** 797,808 ****
  
  static void
  putNedit(FILE *op, const char *fn, const char *on,
! 		FILE *fp, long long lines, int which, int reverse)
  {
  	switch (reverse) {
  	case 0:
  		if (which == 1)
! 			fprintf(op, "1,%lldd\n", lines);
  		else {
  			fprintf(op, "0a\n");
  			putNdata(op, fp, 0, 0);
--- 805,816 ----
  
  static void
  putNedit(FILE *op, const char *fn, const char *on,
! 		FILE *fp, LONGLONG lines, int which, int reverse)
  {
  	switch (reverse) {
  	case 0:
  		if (which == 1)
! 			fprintf(op, "1," P_LLD "d\n", lines);
  		else {
  			fprintf(op, "0a\n");
  			putNdata(op, fp, 0, 0);
***************
*** 811,817 ****
  		break;
  	case 1:
  		if (which == 1)
! 			fprintf(op, "d1 %lld\n", lines);
  		else {
  			fprintf(op, "a0\n");
  			putNdata(op, fp, 0, 0);
--- 819,825 ----
  		break;
  	case 1:
  		if (which == 1)
! 			fprintf(op, "d1 " P_LLD "\n", lines);
  		else {
  			fprintf(op, "a0\n");
  			putNdata(op, fp, 0, 0);
***************
*** 820,828 ****
  		break;
  	case 2:
  		if (which == 1)
! 			fprintf(op, "d1 %lld\n", lines);
! 		else {
! 			fprintf(op, "a0 %lld\n", lines);
  			putNdata(op, fp, 0, 0);
  		}
  		break;
--- 828,836 ----
  		break;
  	case 2:
  		if (which == 1)
! 			fprintf(op, "d1 " P_LLD "\n", lines);
! 		else {
! 			fprintf(op, "a0 " P_LLD "\n", lines);
  			putNdata(op, fp, 0, 0);
  		}
  		break;
***************
*** 831,847 ****
  
  static void
  putNcntx(FILE *op, const char *fn, const char *on, time_t mtime,
! 		FILE *fp, long long lines, int which)
  {
  	putNhead(op, fn, on, mtime, which, "***", "---");
  	fprintf(op, "***************\n*** ");
  	if (which == 1)
! 		fprintf(op, "1,%lld", lines);
  	else
  		putc('0', op);
  	fprintf(op, " ****\n");
  	if (which != 1)
! 		fprintf(op, "--- 1,%lld ----\n", lines);
  	putNdata(op, fp, which == 1 ? '-' : '+', ' ');
  	if (which == 1)
  		fprintf(op, "--- 0 ----\n");
--- 839,855 ----
  
  static void
  putNcntx(FILE *op, const char *fn, const char *on, time_t mtime,
! 		FILE *fp, LONGLONG lines, int which)
  {
  	putNhead(op, fn, on, mtime, which, "***", "---");
  	fprintf(op, "***************\n*** ");
  	if (which == 1)
! 		fprintf(op, "1," P_LLD, lines);
  	else
  		putc('0', op);
  	fprintf(op, " ****\n");
  	if (which != 1)
! 		fprintf(op, "--- 1," P_LLD " ----\n", lines);
  	putNdata(op, fp, which == 1 ? '-' : '+', ' ');
  	if (which == 1)
  		fprintf(op, "--- 0 ----\n");
***************
*** 849,859 ****
  
  static void
  putNunif(FILE *op, const char *fn, const char *on, time_t mtime,
! 		FILE *fp, long long lines, int which)
  {
  	putNhead(op, fn, on, mtime, which, "---", "+++");
  	fprintf(op, "@@ ");
! 	fprintf(op, which == 1 ? "-1,%lld +0,0" : "-0,0 +1,%lld", lines);
  	fprintf(op, " @@\n");
  	putNdata(op, fp, which == 1 ? '-' : '+', 0);
  }
--- 857,867 ----
  
  static void
  putNunif(FILE *op, const char *fn, const char *on, time_t mtime,
! 		FILE *fp, LONGLONG lines, int which)
  {
  	putNhead(op, fn, on, mtime, which, "---", "+++");
  	fprintf(op, "@@ ");
! 	fprintf(op, which == 1 ? "-1," P_LLD " +0,0" : "-0,0 +1," P_LLD, lines);
  	fprintf(op, " @@\n");
  	putNdata(op, fp, which == 1 ? '-' : '+', 0);
  }
***************
*** 927,937 ****
  	closedir(Dp);
  }
  
! static long long
  linec(const char *fn, FILE *fp)
  {
  	int	c, lastc = '\n';
! 	long long	cnt = 0;
  
  	while ((c = getc(fp)) != EOF) {
  		if (c == '\n')
--- 935,945 ----
  	closedir(Dp);
  }
  
! static LONGLONG
  linec(const char *fn, FILE *fp)
  {
  	int	c, lastc = '\n';
! 	LONGLONG	cnt = 0;
  
  	while ((c = getc(fp)) != EOF) {
  		if (c == '\n')
diff -c heirloom-060122/diff/diffh.c heirloom-060122-patched/diff/diffh.c
*** heirloom-060122/diff/diffh.c Sun May 29 12:55:39 2005
--- heirloom-060122-patched/diff/diffh.c Wed Oct 18 02:27:34 2006
***************
*** 97,102 ****
--- 97,110 ----
  #include <iblok.h>
  #include <mbtowi.h>
  
+ #ifdef _MINIX
+ #define LONGLONG long
+ #define P_LLD "%ld"
+ #else
+ #define LONGLONG long long
+ #define P_LLD "%lld"
+ #endif
+ 
  #define C 3
  #define RANGE 30
  #define INF 16384
***************
*** 107,128 ****
  
  static char *text[2][RANGE];
  static size_t size[2][RANGE];
! static long long lineno[2] = {1, 1};	/*no. of 1st stored line in each file*/
! static int ntext[2];		/*number of stored lines in each*/
! static long long n0,n1;		/*scan pointer in each*/
  static int bflag;
  static int mb_cur_max;
  static int debug = 0;
  static struct iblok *file[2];
  static int eof[2];
  
! static char *getl(int, long long);
! static void clrl(int, long long);
  static void movstr(int, int, int);
  static int easysynch(void);
  static int output(int, int);
! static void change(long long, int, long long, int, const char *);
! static void range(long long, int);
  static int cmp(const char *, const char *);
  static struct iblok *dopen(const char *, const char *);
  static void progerr(const char *);
--- 115,136 ----
  
  static char *text[2][RANGE];
  static size_t size[2][RANGE];
! static LONGLONG lineno[2] = {1, 1};	/*no. of 1st stored line in each file*/
! static int ntext[2];		/*number of stored lines in each*/
! static LONGLONG n0,n1;		/*scan pointer in each*/
  static int bflag;
  static int mb_cur_max;
  static int debug = 0;
  static struct iblok *file[2];
  static int eof[2];
  
! static char *getl(int, LONGLONG);
! static void clrl(int, LONGLONG);
  static void movstr(int, int, int);
  static int easysynch(void);
  static int output(int, int);
! static void change(LONGLONG, int, LONGLONG, int, const char *);
! static void range(LONGLONG, int);
  static int cmp(const char *, const char *);
  static struct iblok *dopen(const char *, const char *);
  static void progerr(const char *);
***************
*** 132,138 ****
  
  	/* return pointer to line n of file f*/
  static char *
! getl(int f, long long n)
  {
  	register int delta, nt;
  	size_t	len;
--- 140,146 ----
  
  	/* return pointer to line n of file f*/
  static char *
! getl(int f, LONGLONG n)
  {
  	register int delta, nt;
  	size_t	len;
***************
*** 161,169 ****
  
  	/*remove thru line n of file f from storage*/
  static void
! clrl(int f,long long n)
! {
! 	register long long i,j;
  	j = n-lineno[f]+1;
  	for(i=0;i+j<ntext[f];i++)
  		movstr(f, i+j, i);
--- 169,177 ----
  
  	/*remove thru line n of file f from storage*/
  static void
! clrl(int f,LONGLONG n)
! {
! 	register LONGLONG i,j;
  	j = n-lineno[f]+1;
  	for(i=0;i+j<ntext[f];i++)
  		movstr(f, i+j, i);
***************
*** 290,296 ****
  }
  
  static void
! change(long long a,int b,long long c,int d,const char *s)
  {
  	range(a,b);
  	printf("%s",s);
--- 298,304 ----
  }
  
  static void
! change(LONGLONG a,int b,LONGLONG c,int d,const char *s)
  {
  	range(a,b);
  	printf("%s",s);
***************
*** 299,312 ****
  }
  
  static void
! range(long long a,int b)
! {
! 	if(b==INF)
! 		printf("%lld,$",a);
! 	else if(b==0)
! 		printf("%lld",a);
! 	else
! 		printf("%lld,%lld",a,a+b);
  }
  
  static int
--- 307,320 ----
  }
  
  static void
! range(LONGLONG a,int b)
! {
! 	if(b==INF)
! 		printf(P_LLD ",$",a);
! 	else if(b==0)
! 		printf(P_LLD,a);
! 	else
! 		printf(P_LLD "," P_LLD,a,a+b);
  }
  
  static int
diff -c heirloom-060122/diff/diffreg.c heirloom-060122-patched/diff/diffreg.c
*** heirloom-060122/diff/diffreg.c Sun Mar 27 10:02:01 2005
--- heirloom-060122-patched/diff/diffreg.c Wed Oct 18 02:22:43 2006
***************
*** 86,91 ****
--- 86,95 ----
  #include <wctype.h>
  #include <inttypes.h>
  #include "mbtowi.h"
+ #ifdef _MINIX
+ #define fseeko fseek
+ #define ftello ftell
+ #endif
  /*
   * diff - compare two files.
   */
Common subdirectories: heirloom-060122/diff3 and heirloom-060122-patched/diff3
Only in heirloom-060122-patched/diff3: Makefile
diff -c heirloom-060122/diff3/Makefile.mk heirloom-060122-patched/diff3/Makefile.mk
*** heirloom-060122/diff3/Makefile.mk Thu May 29 19:35:23 2003
--- heirloom-060122-patched/diff3/Makefile.mk Wed Oct 18 02:30:46 2006
***************
*** 1,10 ****
  all: diff3 diff3prog
  
  diff3: diff3.sh
! 	echo '#!$(SHELL)' | cat - diff3.sh | sed ' \
! 		s,@DEFBIN@,$(DEFBIN),g; \
! 		s,@SV3BIN@,$(SV3BIN),g; \
! 		s,@DEFLIB@,$(DEFLIB),g' >diff3
  	chmod 755 diff3
  
  diff3prog: diff3prog.o
--- 1,7 ----
  all: diff3 diff3prog
  
  diff3: diff3.sh
! 	echo '#!$(SHELL)' | cat - diff3.sh | sed 's,@DEFBIN@,$(DEFBIN),g; s,@SV3BIN@,$(SV3BIN),g; s,@DEFLIB@,$(DEFLIB),g' >diff3
  	chmod 755 diff3
  
  diff3prog: diff3prog.o
Common subdirectories: heirloom-060122/dircmp and heirloom-060122-patched/dircmp
Only in heirloom-060122-patched/dircmp: Makefile
diff -c heirloom-060122/dircmp/Makefile.mk heirloom-060122-patched/dircmp/Makefile.mk
*** heirloom-060122/dircmp/Makefile.mk Sat Jun 25 16:48:53 2005
--- heirloom-060122-patched/dircmp/Makefile.mk Wed Oct 18 02:31:40 2006
***************
*** 1,10 ****
  all: dircmp
  
  dircmp: dircmp.sh
! 	echo '#!$(SHELL)' | cat - dircmp.sh | sed ' \
! 		s,@DEFBIN@,$(DEFBIN),g; \
! 		s,@SV3BIN@,$(SV3BIN),g; \
! 		s,@DEFLIB@,$(DEFLIB),g' >dircmp
  	chmod 755 dircmp
  
  install: all
--- 1,7 ----
  all: dircmp
  
  dircmp: dircmp.sh
! 	echo '#!$(SHELL)' | cat - dircmp.sh | sed 's,@DEFBIN@,$(DEFBIN),g; s,@SV3BIN@,$(SV3BIN),g; s,@DEFLIB@,$(DEFLIB),g' >dircmp
  	chmod 755 dircmp
  
  install: all
Common subdirectories: heirloom-060122/dirname and heirloom-060122-patched/dirname
Only in heirloom-060122-patched/dirname: Makefile
Common subdirectories: heirloom-060122/du and heirloom-060122-patched/du
Only in heirloom-060122-patched/du: Makefile
diff -c heirloom-060122/du/du.c heirloom-060122-patched/du/du.c
*** heirloom-060122/du/du.c Sun May 29 12:55:40 2005
--- heirloom-060122-patched/du/du.c Wed Oct 18 12:21:48 2006
***************
*** 64,69 ****
--- 64,77 ----
  #define	hpfix(blocks)
  #endif
  
+ #ifdef _MINIX
+ #define LONGLONG long
+ #define NP_LLU "lu"
+ #else
+ #define LONGLONG long long
+ #define NP_LLU "llu"
+ #endif
+ 
  static struct level {
  	struct getdb	*l_db;
  	int	l_fd;
***************
*** 108,114 ****
  static int		oflag;		/* do not add subdirs */
  static int		HLflag;		/* -H or -L flag */
  static long		maxdepth;	/* max depth of recursion */
! static long long	*dtots;		/* size of directories on recursion */
  static struct dslot	*d0;		/* start of devices table */
  static char		*progname;	/* argv0 to main */
  static struct islot	*inull;		/* i-node tree null element */
--- 116,122 ----
  static int		oflag;		/* do not add subdirs */
  static int		HLflag;		/* -H or -L flag */
  static long		maxdepth;	/* max depth of recursion */
! static LONGLONG	*dtots;		/* size of directories on recursion */
  static struct dslot	*d0;		/* start of devices table */
  static char		*progname;	/* argv0 to main */
  static struct islot	*inull;		/* i-node tree null element */
***************
*** 159,165 ****
   * Show output.
   */
  static void
! report(unsigned long long sz, const char *fn)
  {
  	if (hflag || kflag) {
  		if (sz & 01)
--- 167,173 ----
   * Show output.
   */
  static void
! report(unsigned LONGLONG sz, const char *fn)
  {
  	if (hflag || kflag) {
  		if (sz & 01)
***************
*** 176,186 ****
  			up++;
  		}
  		if (sz < 10 && rest)
! 			printf("%2llu.%u%c\t%s\n", sz, rest, *up, fn);
! 		else
! 			printf("%4llu%c\t%s\n", sz, *up, fn);
! 	} else
! 		printf("%llu\t%s\n", sz, fn);
  }
  
  /*
--- 184,194 ----
  			up++;
  		}
  		if (sz < 10 && rest)
! 			printf("%2" NP_LLU ".%u%c\t%s\n", sz, rest, *up, fn);
! 		else
! 			printf("%4" NP_LLU "%c\t%s\n", sz, *up, fn);
! 	} else
! 		printf("%" NP_LLU "\t%s\n", sz, fn);
  }
  
  /*
***************
*** 333,348 ****
  static void
  dufile(const char *fn, const struct stat *sp, int level)
  {
  	switch (sp->st_mode&S_IFMT) {
  	default:
  		if (sp->st_nlink > 1 && multilink(sp))
  			break;
  		if (aflag && !sflag)
! 			report(sp->st_blocks, fn);
! 		dtots[level] += sp->st_blocks;
! 		break;
! 	case S_IFDIR:
! 		dtots[level + 1] += sp->st_blocks;
  		if (!sflag || level == 0)
  			report(dtots[level + 1], fn);
  		if (oflag == 0)
--- 341,364 ----
  static void
  dufile(const char *fn, const struct stat *sp, int level)
  {
+     unsigned LONGLONG nblocks;
+ 
+ #ifdef _MINIX
+     nblocks = (sp->st_size / 512) + 1;
+ #else
+     nblocks = sp->st_blocks;
+ #endif
+ 
  	switch (sp->st_mode&S_IFMT) {
  	default:
  		if (sp->st_nlink > 1 && multilink(sp))
  			break;
  		if (aflag && !sflag)
! 			report(nblocks, fn);
! 		dtots[level] += nblocks;
! 		break;
! 	case S_IFDIR:
! 		dtots[level + 1] += nblocks;
  		if (!sflag || level == 0)
  			report(dtots[level + 1], fn);
  		if (oflag == 0)
***************
*** 478,487 ****
--- 494,505 ----
  
  		while (waitpid(pid, &status, 0) != pid);
  		if (status && WIFSIGNALED(status)) {
+ #ifndef _MINIX
  			struct rlimit	rl;
  
  			rl.rlim_cur = rl.rlim_max = 0;
  			setrlimit(RLIMIT_CORE, &rl);
+ #endif
  			raise(WTERMSIG(status));
  			pause();
  		}
***************
*** 522,528 ****
  #ifndef	SUS
  		if (aflag || sflag)
  #endif
! 			report(st.st_blocks, fn);
  	}
  }
  
--- 540,550 ----
  #ifndef	SUS
  		if (aflag || sflag)
  #endif
! #ifdef _MINIX
! 			report(st.st_size/512 + 1, fn);
! #else
! 			report(st.st_blocks, fn);
! #endif
  	}
  }
  
Common subdirectories: heirloom-060122/echo and heirloom-060122-patched/echo
Only in heirloom-060122-patched/echo: Makefile
diff -c heirloom-060122/echo/defs.h heirloom-060122-patched/echo/defs.h
*** heirloom-060122/echo/defs.h Sat Jul  2 12:36:39 2005
--- heirloom-060122-patched/echo/defs.h Wed Oct 18 13:42:20 2006
***************
*** 73,79 ****
  #define	prp()		fputs("test: ", stdout)
  #define	prs(s)		fputs(s, stdout)
  #define	sigchk()
! extern long long	stoifll(const char *);
  
  extern int	mb_cur_max;
  #define	nextc(wc, sp)	(mb_cur_max > 1 && *(sp) & 0200 ? \
--- 73,81 ----
  #define	prp()		fputs("test: ", stdout)
  #define	prs(s)		fputs(s, stdout)
  #define	sigchk()
! #ifndef _MINIX
! extern long long	stoifll(const char *);
! #endif /* Why is this here anyway? */
  
  extern int	mb_cur_max;
  #define	nextc(wc, sp)	(mb_cur_max > 1 && *(sp) & 0200 ? \
Common subdirectories: heirloom-060122/ed and heirloom-060122-patched/ed
Only in heirloom-060122-patched/ed: Makefile
Common subdirectories: heirloom-060122/env and heirloom-060122-patched/env
Only in heirloom-060122-patched/env: Makefile
Common subdirectories: heirloom-060122/expand and heirloom-060122-patched/expand
Only in heirloom-060122-patched/expand: Makefile
diff -c heirloom-060122/expand/expand.c heirloom-060122-patched/expand/expand.c
*** heirloom-060122/expand/expand.c Sun May 29 12:55:40 2005
--- heirloom-060122-patched/expand/expand.c Wed Oct 18 13:45:46 2006
***************
*** 93,99 ****
  	char	b;
  	wint_t	c;
  	int	n, w;
! 	long long	col;
  
  	if ((ip = fn ? ib_open(fn, 0) : ib_alloc(0, 0)) == NULL) {
  		perror(fn ? fn : "stdin");
--- 93,99 ----
  	char	b;
  	wint_t	c;
  	int	n, w;
! 	LONGLONG	col;
  
  	if ((ip = fn ? ib_open(fn, 0) : ib_alloc(0, 0)) == NULL) {
  		perror(fn ? fn : "stdin");
diff -c heirloom-060122/expand/tablist.c heirloom-060122-patched/expand/tablist.c
*** heirloom-060122/expand/tablist.c Fri Jul 16 16:58:15 2004
--- heirloom-060122-patched/expand/tablist.c Wed Oct 18 13:46:10 2006
***************
*** 42,48 ****
  settab(const char *s)
  {
  	char	*x, *y;
! 	long long	n;
  
  	if (s == NULL || *s == '\0')
  		badts();
--- 42,48 ----
  settab(const char *s)
  {
  	char	*x, *y;
! 	LONGLONG	n;
  
  	if (s == NULL || *s == '\0')
  		badts();
***************
*** 68,74 ****
  }
  
  void
! addtab(long long n)
  {
  	struct tab	*tp, *tq;
  
--- 68,74 ----
  }
  
  void
! addtab(LONGLONG n)
  {
  	struct tab	*tp, *tq;
  
diff -c heirloom-060122/expand/tablist.h heirloom-060122-patched/expand/tablist.h
*** heirloom-060122/expand/tablist.h Mon May  5 20:59:29 2003
--- heirloom-060122-patched/expand/tablist.h Wed Oct 18 13:47:06 2006
***************
*** 27,40 ****
  
  /*	Sccsid @(#)tablist.h	1.1 (gritter) 5/5/03	*/
  
! extern struct	tab {
! 	struct tab	*t_nxt;
! 	long long	t_pos;
  } *tablist;
  
  extern int		tabstop;
  
  extern void	settab(const char *);
! extern void	addtab(long long);
  extern void	badts(void);
  extern void	*scalloc(size_t, size_t);
--- 27,47 ----
  
  /*	Sccsid @(#)tablist.h	1.1 (gritter) 5/5/03	*/
  
! #ifdef _MINIX
! #define LONGLONG long
! #define strtoll strtol
! #else
! #define LONGLONG longlong
! #endif
! 
! extern struct	tab {
! 	struct tab	*t_nxt;
! 	LONGLONG	t_pos;
  } *tablist;
  
  extern int		tabstop;
  
  extern void	settab(const char *);
! extern void	addtab(LONGLONG);
  extern void	badts(void);
  extern void	*scalloc(size_t, size_t);
diff -c heirloom-060122/expand/unexpand.c heirloom-060122-patched/expand/unexpand.c
*** heirloom-060122/expand/unexpand.c Sun May 29 12:55:40 2005
--- heirloom-060122-patched/expand/unexpand.c Wed Oct 18 13:48:05 2006
***************
*** 60,66 ****
  
  static void	usage(void);
  static void	unexpand(const char *);
! static void	spaces(long long *, long long *, struct tab **);
  
  int
  main(int argc, char **argv)
--- 60,66 ----
  
  static void	usage(void);
  static void	unexpand(const char *);
! static void	spaces(LONGLONG *, LONGLONG *, struct tab **);
  
  int
  main(int argc, char **argv)
***************
*** 119,125 ****
  	char	b;
  	wint_t	c;
  	int	n, w;
! 	long long	col, spc = 0;
  
  	if ((ip = fn ? ib_open(fn, 0) : ib_alloc(0, 0)) == NULL) {
  		perror(fn ? fn : "stdin");
--- 119,125 ----
  	char	b;
  	wint_t	c;
  	int	n, w;
! 	LONGLONG	col, spc = 0;
  
  	if ((ip = fn ? ib_open(fn, 0) : ib_alloc(0, 0)) == NULL) {
  		perror(fn ? fn : "stdin");
***************
*** 191,200 ****
  }
  
  static void
! spaces(long long *sp, long long *cp, struct tab **tp)
! {
! 	int	bol;
! 	long long	nsp;
  
  	bol = *cp == 0;
  	if (tablist) {
--- 191,200 ----
  }
  
  static void
! spaces(LONGLONG *sp, LONGLONG *cp, struct tab **tp)
! {
! 	int	bol;
! 	LONGLONG	nsp;
  
  	bol = *cp == 0;
  	if (tablist) {
Common subdirectories: heirloom-060122/expr and heirloom-060122-patched/expr
Only in heirloom-060122-patched/expr: Makefile
diff -c heirloom-060122/expr/expr.y heirloom-060122-patched/expr/expr.y
*** heirloom-060122/expr/expr.y Sun May 29 12:55:40 2005
--- heirloom-060122-patched/expr/expr.y Wed Oct 18 13:53:30 2006
***************
*** 72,77 ****
--- 72,87 ----
  
  #include	"atoll.h"
  
+ #ifdef _MINIX
+ typedef long int64_t;
+ #define LONGLONG long
+ #define P_LLD "%ld"
+ #define atoll atol
+ #else
+ #define LONGLONG long long
+ #define P_LLD "%lld"
+ #endif
+ 
  #define EQL(x,y) !strcmp(x,y)
  
  #define	NUMSZ	25
***************
*** 447,456 ****
  	int	ret;
  
  	rv = smalloc(NUMSZ);
! 	ret = snprintf(rv, NUMSZ, "%lld", (long long)val);
! 	if (ret < 0 || ret >= NUMSZ) {
! 		rv = srealloc(rv, ret + 1);
! 		ret = snprintf(rv, ret, "%lld", (long long)val);
  		if (ret < 0)
  			yyerror("illegal number");
  	}
--- 457,466 ----
  	int	ret;
  
  	rv = smalloc(NUMSZ);
! 	ret = snprintf(rv, NUMSZ, P_LLD, (LONGLONG)val);
! 	if (ret < 0 || ret >= NUMSZ) {
! 		rv = srealloc(rv, ret + 1);
! 		ret = snprintf(rv, ret, P_LLD, (LONGLONG)val);
  		if (ret < 0)
  			yyerror("illegal number");
  	}
Common subdirectories: heirloom-060122/factor and heirloom-060122-patched/factor
Only in heirloom-060122-patched/factor: Makefile
Common subdirectories: heirloom-060122/file and heirloom-060122-patched/file
Only in heirloom-060122-patched/file: Makefile
diff -c heirloom-060122/file/file.c heirloom-060122-patched/file/file.c
*** heirloom-060122/file/file.c Sun May 29 12:55:40 2005
--- heirloom-060122-patched/file/file.c Wed Oct 18 13:59:47 2006
***************
*** 86,91 ****
--- 86,94 ----
  #ifndef	S_IFNWK
  #define	S_IFNWK		0x9000		/* HP-UX network special file */
  #endif
+ #ifndef S_IFSOCK
+ #define S_IFSOCK    014000
+ #endif
  static int in;
  static int i  = 0;
  static char buf[512];
Common subdirectories: heirloom-060122/find and heirloom-060122-patched/find
Only in heirloom-060122-patched/find: Makefile
diff -c heirloom-060122/find/find.c heirloom-060122-patched/find/find.c
*** heirloom-060122/find/find.c Sun Jan 22 18:44:03 2006
--- heirloom-060122-patched/find/find.c Wed Oct 18 14:06:17 2006
***************
*** 103,111 ****
--- 103,122 ----
  #define	S_IFNWK		0x9000
  #endif
  
+ #ifndef S_IFSOCK
+ #define S_IFSOCK    0140000
+ #endif
+ 
  #undef	ctime
  #define	ctime	find_ctime
  
+ #ifdef _MINIX
+ #define LONGLONG long
+ #define atoll atol
+ #else
+ #define LONGLONG long long
+ #endif
+ 
  static char	*Pathname;
  
  struct aggregate {		/* for exec ... {} + */
***************
*** 228,234 ****
  static int	anewer(struct anode *);
  static int	fstype(struct anode *);
  static int	local(struct anode *);
! static int	scomp(long long, long long, char);
  static int	doex(int, struct aggregate *);
  static struct aggregate *mkagg(long);
  static uid_t	getunum(const char *);
--- 239,245 ----
  static int	anewer(struct anode *);
  static int	fstype(struct anode *);
  static int	local(struct anode *);
! static int	scomp(LONGLONG, LONGLONG, char);
  static int	doex(int, struct aggregate *);
  static struct aggregate *mkagg(long);
  static uid_t	getunum(const char *);
***************
*** 733,739 ****
  #if defined (__linux__) || defined (_AIX) || defined (__hpux)
  	return(EQ(fscur->fstype, p->l.fstype));
  #elif defined (__FreeBSD__) || defined (__NetBSD__) || defined (__OpenBSD__) \
! 		|| defined (__DragonFly__) || defined (__APPLE__)
  	return(EQ(Statfs, p->l.fstype));
  #else
  	return(EQ(Statb.st_fstype, p->l.fstype));
--- 744,750 ----
  #if defined (__linux__) || defined (_AIX) || defined (__hpux)
  	return(EQ(fscur->fstype, p->l.fstype));
  #elif defined (__FreeBSD__) || defined (__NetBSD__) || defined (__OpenBSD__) \
! 		|| defined (__DragonFly__) || defined (__APPLE__) || defined (_MINIX)
  	return(EQ(Statfs, p->l.fstype));
  #else
  	return(EQ(Statb.st_fstype, p->l.fstype));
***************
*** 744,750 ****
  #if defined (__linux__) || defined (_AIX) || defined (__hpux)
  	return(strcmp(fscur->fstype, "nfs") && strcmp(fscur->fstype, "smbfs"));
  #elif defined (__FreeBSD__) || defined (__NetBSD__) || defined (__OpenBSD__) \
! 		|| defined (__DragonFly__) || defined (__APPLE__)
  	return(strcmp(Statfs, "nfs") != 0);
  #else
  	return(strcmp(Statb.st_fstype, "nfs") != 0);
--- 755,761 ----
  #if defined (__linux__) || defined (_AIX) || defined (__hpux)
  	return(strcmp(fscur->fstype, "nfs") && strcmp(fscur->fstype, "smbfs"));
  #elif defined (__FreeBSD__) || defined (__NetBSD__) || defined (__OpenBSD__) \
! 		|| defined (__DragonFly__) || defined (__APPLE__) || defined (_MINIX)
  	return(strcmp(Statfs, "nfs") != 0);
  #else
  	return(strcmp(Statb.st_fstype, "nfs") != 0);
***************
*** 753,759 ****
  
  /* support functions */
  /* funny signed compare */
! static int scomp(register long long a, register long long b, register char s)
  {
  	if(s == '+')
  		return(a > b);
--- 764,770 ----
  
  /* support functions */
  /* funny signed compare */
! static int scomp(register LONGLONG a, register LONGLONG b, register char s)
  {
  	if(s == '+')
  		return(a > b);
***************
*** 1167,1176 ****
--- 1178,1189 ----
  	default:
  		while (waitpid(pid, &i, 0) != pid);
  		if (i && WIFSIGNALED(i)) {
+ #ifndef _MINIX
  			struct rlimit	rl;
  
  			rl.rlim_cur = rl.rlim_max = 0;
  			setrlimit(RLIMIT_CORE, &rl);
+ #endif
  			raise(WTERMSIG(i));
  			pause();
  		}
Common subdirectories: heirloom-060122/fmt and heirloom-060122-patched/fmt
Only in heirloom-060122-patched/fmt: Makefile
diff -c heirloom-060122/fmt/fmt.c heirloom-060122-patched/fmt/fmt.c
*** heirloom-060122/fmt/fmt.c Sun May 29 12:55:40 2005
--- heirloom-060122-patched/fmt/fmt.c Wed Oct 18 14:32:25 2006
***************
*** 72,77 ****
--- 72,83 ----
  #include <iblok.h>
  #include <asciitype.h>
  
+ #ifdef _MINIX
+ #define LONGLONG long
+ #else
+ #define LONGLONG long long
+ #endif
+ 
  /*
   * fmt -- format the concatenation of input files or standard input
   * onto standard output.  Designed for use with Mail ~|
***************
*** 81,87 ****
   */
  
  static int	pfx;			/* Current leading blank count */
! static long long	lineno;			/* Current input line */
  static int	mark;			/* we saw a head line */
  static long	width = 72;		/* Width that we will not exceed */
  static int	cflag;			/* crown margin mode */
--- 87,93 ----
   */
  
  static int	pfx;			/* Current leading blank count */
! static LONGLONG	lineno;			/* Current input line */
  static int	mark;			/* we saw a head line */
  static long	width = 72;		/* Width that we will not exceed */
  static int	cflag;			/* crown margin mode */
Common subdirectories: heirloom-060122/fmtmsg and heirloom-060122-patched/fmtmsg
Only in heirloom-060122-patched/fmtmsg: Makefile
Common subdirectories: heirloom-060122/fold and heirloom-060122-patched/fold
Only in heirloom-060122-patched/fold: Makefile
Common subdirectories: heirloom-060122/getconf and heirloom-060122-patched/getconf
Only in heirloom-060122-patched/getconf: Makefile
diff -c heirloom-060122/getconf/getconf.c heirloom-060122-patched/getconf/getconf.c
*** heirloom-060122/getconf/getconf.c Fri Sep  2 16:09:17 2005
--- heirloom-060122-patched/getconf/getconf.c Wed Oct 18 14:46:45 2006
***************
*** 2124,2129 ****
--- 2124,2133 ----
  		break;
  
  	case CONFSTR:
+ #ifdef _MINIX
+ 		fprintf(stderr, "confstr() not available\n");
+ 		return (1);
+ #else
  		if (argc > 2)
  			return (usage());
  		errno = 0;
***************
*** 2153,2158 ****
--- 2157,2163 ----
  
  		printf("%s\n", buffer);
  		free(buffer);
+ #endif
  		break;
  
  	case PATHCONF:
Common subdirectories: heirloom-060122/getopt and heirloom-060122-patched/getopt
Only in heirloom-060122-patched/getopt: Makefile
Common subdirectories: heirloom-060122/grep and heirloom-060122-patched/grep
Only in heirloom-060122-patched/grep: Makefile
diff -c heirloom-060122/grep/grep.c heirloom-060122-patched/grep/grep.c
*** heirloom-060122/grep/grep.c Sat Feb  5 00:53:55 2005
--- heirloom-060122-patched/grep/grep.c Wed Oct 18 15:38:47 2006
***************
*** 33,39 ****
  
  #include	<sys/types.h>
  #include	<sys/stat.h>
! #include	<sys/mman.h>
  #include	<fcntl.h>
  #include	<unistd.h>
  #include	<stdio.h>
--- 33,41 ----
  
  #include	<sys/types.h>
  #include	<sys/stat.h>
! #ifndef _MINIX
! #include	<sys/mman.h>
! #endif
  #include	<fcntl.h>
  #include	<unistd.h>
  #include	<stdio.h>
***************
*** 49,54 ****
--- 51,60 ----
  #include	"grep.h"
  #include	"alloc.h"
  
+ #ifdef _MINIX
+ #undef LONGLONG
+ #endif
+ 
  /*
   * Generic flags and the like.
   */
Common subdirectories: heirloom-060122/groups and heirloom-060122-patched/groups
Only in heirloom-060122-patched/groups: Makefile
Common subdirectories: heirloom-060122/hd and heirloom-060122-patched/hd
Only in heirloom-060122-patched/hd: Makefile
diff -c heirloom-060122/hd/hd.c heirloom-060122-patched/hd/hd.c
*** heirloom-060122/hd/hd.c Sun May 29 12:55:41 2005
--- heirloom-060122-patched/hd/hd.c Wed Oct 18 15:51:03 2006
***************
*** 50,55 ****
--- 50,64 ----
  #include "atoll.h"
  #include "mbtowi.h"
  
+ #ifdef _MINIX
+ #define LONGLONG long
+ #define NP_LL "l"
+ #define strtoll strtol
+ #else
+ #define LONGLONG long long
+ #define NP_LL "ll"
+ #endif
+ 
  #ifdef	__GLIBC__
  #ifdef	_IO_getc_unlocked
  #undef	getc
***************
*** 101,108 ****
  static enum base	bflag;	/* byte format specifier */
  static enum base	cflag;	/* print ASCII at center */
  static enum base	lflag;	/* long (32 bit) format specifier */
! static long long	nflag;	/* number of bytes to process */
! static long long	sflag;	/* start offset */
  static int		tflag;	/* print text file */
  static int		vflag;	/* no '*' for identical lines */
  static enum base	wflag;	/* word (16 bit) format specifier */
--- 110,117 ----
  static enum base	bflag;	/* byte format specifier */
  static enum base	cflag;	/* print ASCII at center */
  static enum base	lflag;	/* long (32 bit) format specifier */
! static LONGLONG	nflag;	/* number of bytes to process */
! static LONGLONG	sflag;	/* start offset */
  static int		tflag;	/* print text file */
  static int		vflag;	/* no '*' for identical lines */
  static enum base	wflag;	/* word (16 bit) format specifier */
***************
*** 114,129 ****
  static void		usage(void);
  static void		flag(int);
  static void		base(enum base, enum base *);
! static long long	count(const char *);
  static void		usage(void);
  static void		diag(const char *, ...);
  static void		hd(FILE *);
! static void		prna(long long);
  static void		prnb(union block *, int);
  static void		line(union block *, int, int, enum base, int);
  static const struct fm	*getfmt(int, enum base);
  static void		getalign(void);
! static void		prnt(FILE *, long long);
  static void		prnc(int);
  static char		*wcget(FILE *fp, wint_t *wc, int *len);
  
--- 123,138 ----
  static void		usage(void);
  static void		flag(int);
  static void		base(enum base, enum base *);
! static LONGLONG	count(const char *);
  static void		usage(void);
  static void		diag(const char *, ...);
  static void		hd(FILE *);
! static void		prna(LONGLONG);
  static void		prnb(union block *, int);
  static void		line(union block *, int, int, enum base, int);
  static const struct fm	*getfmt(int, enum base);
  static void		getalign(void);
! static void		prnt(FILE *, LONGLONG);
  static void		prnc(int);
  static char		*wcget(FILE *fp, wint_t *wc, int *len);
  
***************
*** 257,266 ****
  	}
  }
  
! static long long
! count(const char *s)
! {
! 	long long	c;
  	int	bs = 10;
  	char	*x;
  
--- 266,275 ----
  	}
  }
  
! static LONGLONG
! count(const char *s)
! {
! 	LONGLONG	c;
  	int	bs = 10;
  	char	*x;
  
***************
*** 325,331 ****
  static void
  hd(FILE *fp)
  {
! 	long long	of = 0, rd = 0;
  	union block	b, ob;
  	size_t	n, m, on = 0;
  	int	star = 0;
--- 334,340 ----
  static void
  hd(FILE *fp)
  {
! 	LONGLONG	of = 0, rd = 0;
  	union block	b, ob;
  	size_t	n, m, on = 0;
  	int	star = 0;
***************
*** 367,384 ****
  }
  
  static void
! prna(long long n)
  {
  	switch (aflag) {
  	case BASE_O:
! 		printf("%06llo", n);
! 		break;
! 	case BASE_D:
! 		printf("%05llu", n);
  		break;
  	case BASE_0:
  	case BASE_X:
! 		printf("%04llx", n);
  		break;
  	}
  }
--- 376,393 ----
  }
  
  static void
! prna(LONGLONG n)
  {
  	switch (aflag) {
  	case BASE_O:
! 		printf("%06" NP_LL "o", n);
! 		break;
! 	case BASE_D:
! 		printf("%05" NP_LL "u", n);
  		break;
  	case BASE_0:
  	case BASE_X:
! 		printf("%04" NP_LL "x", n);
  		break;
  	}
  }
***************
*** 558,563 ****
--- 567,575 ----
  {
  	int	i, j;
  	enum base	*basep;
+ #ifdef _MINIX
+     char *alignp;
+ #endif
  
  	for (i = 0; ofmt[i].f_fmt; i++) {
  		switch (ofmt[i].f_fmt) {
***************
*** 576,595 ****
  		default:
  			basep = NULL;
  		}
  		if (basep && *basep & ofmt[i].f_base)
  			for (j = 0; j < sizeof align; j++)
  				if (ofmt[i].f_align[j] > align[j])
! 					align[j] = ofmt[i].f_align[j];
  	}
  }
  
  static void
! prnt(FILE *fp, long long of)
  {
  	wint_t	wc;
  	char	b, *mb;
  	int	c, lastc = '\n', n;
! 	long long	rd = 0;
  
  	while ((nflag == 0 || rd < nflag)) {
  		if (mb_cur_max > 1) {
--- 588,614 ----
  		default:
  			basep = NULL;
  		}
+ #ifdef _MINIX
+         alignp = align;
+ #endif
  		if (basep && *basep & ofmt[i].f_base)
  			for (j = 0; j < sizeof align; j++)
  				if (ofmt[i].f_align[j] > align[j])
! #ifdef _MINIX
! 					alignp[j] = ofmt[i].f_align[j];
! #else
! 					align[j] = ofmt[i].f_align[j];
! #endif
  	}
  }
  
  static void
! prnt(FILE *fp, LONGLONG of)
  {
  	wint_t	wc;
  	char	b, *mb;
  	int	c, lastc = '\n', n;
! 	LONGLONG	rd = 0;
  
  	while ((nflag == 0 || rd < nflag)) {
  		if (mb_cur_max > 1) {
Common subdirectories: heirloom-060122/head and heirloom-060122-patched/head
Only in heirloom-060122-patched/head: Makefile
diff -c heirloom-060122/head/head.c heirloom-060122-patched/head/head.c
*** heirloom-060122/head/head.c Sun May 29 12:55:41 2005
--- heirloom-060122-patched/head/head.c Wed Oct 18 15:55:34 2006
***************
*** 47,54 ****
  
  #include	"iblok.h"
  
! static unsigned	errcnt;			/* count of errors */
! static unsigned long long	count = 10;	/* lines to display */
  static char	*progname;		/* argv[0] to main() */
  
  static void
--- 47,61 ----
  
  #include	"iblok.h"
  
! #ifdef _MINIX
! #define LONGLONG long
! #define strtoull strtoul
! #else
! #define LONGLONG long long
! #endif
! 
! static unsigned	errcnt;			/* count of errors */
! static unsigned LONGLONG	count = 10;	/* lines to display */
  static char	*progname;		/* argv[0] to main() */
  
  static void
***************
*** 70,76 ****
  	static int	printed;
  	const char	*errfn;
  	register int	c;
! 	unsigned long long	n = 1;
  
  	if (fn[0] == '-' && fn[1] == '\0') {
  		ip = ib_alloc(0, 0);
--- 77,83 ----
  	static int	printed;
  	const char	*errfn;
  	register int	c;
! 	unsigned LONGLONG	n = 1;
  
  	if (fn[0] == '-' && fn[1] == '\0') {
  		ip = ib_alloc(0, 0);
***************
*** 98,108 ****
  	return 0;
  }
  
! static unsigned long long
  get_count(char *arg)
  {
  	char	*x;
! 	unsigned long long	n;
  
  	if (arg == NULL || *arg == '\0') {
  		fprintf(stderr, "%s: missing number\n", progname);
--- 105,115 ----
  	return 0;
  }
  
! static unsigned LONGLONG
  get_count(char *arg)
  {
  	char	*x;
! 	unsigned LONGLONG	n;
  
  	if (arg == NULL || *arg == '\0') {
  		fprintf(stderr, "%s: missing number\n", progname);
Common subdirectories: heirloom-060122/hostname and heirloom-060122-patched/hostname
Only in heirloom-060122-patched/hostname: Makefile
diff -c heirloom-060122/hostname/hostname.c heirloom-060122-patched/hostname/hostname.c
*** heirloom-060122/hostname/hostname.c Sun May 29 12:55:41 2005
--- heirloom-060122-patched/hostname/hostname.c Wed Oct 18 16:08:33 2006
***************
*** 42,47 ****
--- 42,62 ----
  
  static const char	*progname;
  
+ #ifdef _MINIX
+ #include <errno.h>
+ int sethostname(char *name, size_t len) {
+     FILE *fp;
+     if ((fp= fopen("/etc/hostname.file", "w")) == NULL
+         || fprintf(fp, "%s\n", name) == EOF
+         || fclose(fp) == EOF) {
+             fprintf(stderr, "%s: /etc/hostname.file: %s\n", progname,
+                     strerror(errno));
+             return -1;
+ 		}
+     return 0;
+ }
+ #endif
+ 
  int
  main(int argc, char **argv)
  {
Common subdirectories: heirloom-060122/id and heirloom-060122-patched/id
Only in heirloom-060122-patched/id: Makefile
Common subdirectories: heirloom-060122/join and heirloom-060122-patched/join
Only in heirloom-060122-patched/join: Makefile
Common subdirectories: heirloom-060122/kill and heirloom-060122-patched/kill
Only in heirloom-060122-patched/kill: Makefile
Common subdirectories: heirloom-060122/libcommon and heirloom-060122-patched/libcommon
Only in heirloom-060122-patched/libcommon: Makefile
diff -c heirloom-060122/libcommon/Makefile.mk heirloom-060122-patched/libcommon/Makefile.mk
*** heirloom-060122/libcommon/Makefile.mk Sun Jan 22 18:33:32 2006
--- heirloom-060122-patched/libcommon/Makefile.mk Thu Oct 19 01:38:54 2006
***************
*** 4,12 ****
  	ib_open.o ib_popen.o ib_read.o ib_seek.o oblok.o sfile.o strtol.o \
  	getdir.o regexpr.o gmatch.o utmpx.o memalign.o pathconf.o \
  	sigset.o signal.o sigrelse.o sighold.o sigignore.o sigpause.o \
! 	getopt.o pfmt.o vpfmt.o setlabel.o setuxlabel.o pfmt_label.o sysv3.o
! libcommon.a: headers $(OBJ)
! 	$(AR) -rv $@ $(OBJ)
  	$(RANLIB) $@
  
  CHECK: CHECK.c
--- 4,13 ----
  	ib_open.o ib_popen.o ib_read.o ib_seek.o oblok.o sfile.o strtol.o \
  	getdir.o regexpr.o gmatch.o utmpx.o memalign.o pathconf.o \
  	sigset.o signal.o sigrelse.o sighold.o sigignore.o sigpause.o \
! 	getopt.o pfmt.o vpfmt.o setlabel.o setuxlabel.o pfmt_label.o sysv3.o \
! 	realpath.o fnmatch.o dirname.o
! libcommon.a: headers $(OBJ)
! 	$(AR) rv $@ $(OBJ)
  	$(RANLIB) $@
  
  CHECK: CHECK.c
***************
*** 125,130 ****
--- 126,140 ----
  pfmt_label.o: pfmt_label.c
  	$(CC) $(CFLAGSS) $(CPPFLAGS) $(LARGEF) $(IWCHAR) -I. -c pfmt_label.c
  
+ realpath.o: realpath.c
+ 	$(CC) $(CFLAGSS) $(CPPFLAGS) $(LARGEF) $(IWCHAR) -I. -c realpath.c
+ 
+ fnmatch.o: fnmatch.c
+ 	$(CC) $(CFLAGSS) $(CPPFLAGS) $(LARGEF) $(IWCHAR) -I. -c fnmatch.c
+ 
+ dirname.o: dirname.c
+ 	$(CC) $(CFLAGSS) $(CPPFLAGS) $(LARGEF) $(IWCHAR) -I. -c dirname.c
+ 
  asciitype.o: asciitype.h
  ib_alloc.o: iblok.h
  ib_close.o: iblok.h
Only in heirloom-060122-patched/libcommon: dirname.c
Only in heirloom-060122-patched/libcommon: dirname.h
Only in heirloom-060122-patched/libcommon: fnmatch.c
Only in heirloom-060122-patched/libcommon: fnmatch.h
diff -c heirloom-060122/libcommon/getdir.c heirloom-060122-patched/libcommon/getdir.c
*** heirloom-060122/libcommon/getdir.c Sun Jan 22 19:06:14 2006
--- heirloom-060122-patched/libcommon/getdir.c Wed Oct 18 14:15:25 2006
***************
*** 1,4 ****
--- 1,8 ----
  /*
+  * Minix/POSIX implementation is copyright (c) 2006 by Ivo van Poorten
+  * License as below.
+  */
+ /*
   * Copyright (c) 2003 Gunnar Ritter
   *
   * This software is provided 'as-is', without any express or implied
***************
*** 59,65 ****
  #ifdef	__hpux
  #define		_KERNEL
  #endif	/* __hpux */
! #include	<sys/dirent.h>
  #ifdef		__hpux
  #ifndef	_INO64_T
  typedef	unsigned long long	uint64_t;
--- 63,73 ----
  #ifdef	__hpux
  #define		_KERNEL
  #endif	/* __hpux */
! #ifdef _MINIX
! #include <dirent.h>
! #else
! #include	<sys/dirent.h>
! #endif
  #ifdef		__hpux
  #ifndef	_INO64_T
  typedef	unsigned long long	uint64_t;
***************
*** 96,101 ****
--- 104,112 ----
  	} g_u;
  	int		g_num;
  	int		g_fd;
+ #ifdef _MINIX
+     DIR *mnx_dirp;
+ #endif
  };
  
  struct getdb *
***************
*** 109,114 ****
--- 120,126 ----
  	db->g_offs = 0;
  	db->g_fd = fd;
  	db->g_path = path;
+     db->mnx_dirp = NULL;
  	return db;
  }
  
***************
*** 118,123 ****
--- 130,136 ----
  	free(db);
  }
  
+ #ifndef _MINIX
  struct direc *
  getdir(struct getdb *db, int *err)
  {
***************
*** 149,155 ****
  		      )
  		{
  		next:
! #ifndef	__DragonFly__
  			reclen = db->g_dirp->d_reclen;
  #else
  			reclen = _DIRENT_DIRSIZ(db->g_dirp);
--- 162,168 ----
  		      )
  		{
  		next:
! #if	!defined(__DragonFly__) && !defined(_MINIX)
  			reclen = db->g_dirp->d_reclen;
  #else
  			reclen = _DIRENT_DIRSIZ(db->g_dirp);
***************
*** 174,180 ****
  	db->g_dic.d_ino = db->g_dirp->d_fileno;
  #endif	/* __FreeBSD__, __NetBSD__, __OpenBSD__, __DragonFly__, __APPLE__ */
  	db->g_dic.d_name = db->g_dirp->d_name;
! #ifndef	__DragonFly__
  		reclen = db->g_dirp->d_reclen;
  #else
  		reclen = _DIRENT_DIRSIZ(db->g_dirp);
--- 187,193 ----
  	db->g_dic.d_ino = db->g_dirp->d_fileno;
  #endif	/* __FreeBSD__, __NetBSD__, __OpenBSD__, __DragonFly__, __APPLE__ */
  	db->g_dic.d_name = db->g_dirp->d_name;
! #if !defined(__DragonFly__) && !defined(_MINIX)
  		reclen = db->g_dirp->d_reclen;
  #else
  		reclen = _DIRENT_DIRSIZ(db->g_dirp);
***************
*** 186,188 ****
--- 199,235 ----
  		db->g_dirp = (struct dirent *)((char *)db->g_dirp + reclen);
  	return &(db->g_dic);
  }
+ 
+ #else /* !_MINIX */
+ 
+ struct direc *
+ getdir(struct getdb *db, int *err)
+ {
+     *err = 0;
+     errno = 0;
+     if (db->mnx_dirp == NULL) {
+         db->mnx_dirp = opendir(db->g_path);
+         if (db->mnx_dirp == NULL) {
+             *err = errno;
+             return NULL;
+         }
+     }
+ 
+     do {
+         db->g_dirp = readdir(db->mnx_dirp);
+         if (db->g_dirp == NULL) {
+             *err = errno; /* not set on end-of-dir */
+             closedir(db->mnx_dirp);
+             db->mnx_dirp = NULL;
+             return NULL;
+         }
+     } while (db->g_dirp->d_ino == 0);
+ 
+     db->g_dic.d_ino = db->g_dirp->d_ino;
+     db->g_dic.d_name = db->g_dirp->d_name;
+ 
+ 	return &(db->g_dic);
+ }
+ 
+ #endif /* _MINIX */
+ 
diff -c heirloom-060122/libcommon/getdir.h heirloom-060122-patched/libcommon/getdir.h
*** heirloom-060122/libcommon/getdir.h Sun Oct 19 14:52:52 2003
--- heirloom-060122-patched/libcommon/getdir.h Tue Oct 17 02:09:25 2006
***************
*** 23,30 ****
  
  #include	<sys/types.h>
  
! struct	direc {
! 	unsigned long long	d_ino;
  	char	*d_name;
  };
  
--- 23,36 ----
  
  #include	<sys/types.h>
  
! #ifdef _MINIX
! #define LONGLONG long
! #else
! #define LONGLONG long long
! #endif
! 
! struct	direc {
! 	unsigned LONGLONG	d_ino;
  	char	*d_name;
  };
  
diff -c heirloom-060122/libcommon/ib_alloc.c heirloom-060122-patched/libcommon/ib_alloc.c
*** heirloom-060122/libcommon/ib_alloc.c Sat Mar 12 15:42:02 2005
--- heirloom-060122-patched/libcommon/ib_alloc.c Tue Oct 17 02:05:23 2006
***************
*** 28,34 ****
  #include	<string.h>
  #include	<errno.h>
  #include	<stdlib.h>
! #include	<malloc.h>
  
  #include	"memalign.h"
  #include	"iblok.h"
--- 28,36 ----
  #include	<string.h>
  #include	<errno.h>
  #include	<stdlib.h>
! #ifndef _MINIX
! #include	<malloc.h>
! #endif
  
  #include	"memalign.h"
  #include	"iblok.h"
***************
*** 46,52 ****
  	if (blksize == 0) {
  		if (fstat(fd, &st) < 0)
  			return NULL;
! 		blksize = st.st_blksize > 0 ? st.st_blksize : 512;
  	}
  	if ((ip = calloc(1, sizeof *ip)) == NULL)
  		return NULL;
--- 48,58 ----
  	if (blksize == 0) {
  		if (fstat(fd, &st) < 0)
  			return NULL;
! #ifndef _MINIX
! 		blksize = st.st_blksize > 0 ? st.st_blksize : 512;
! #else
!         blksize = 512;
! #endif
  	}
  	if ((ip = calloc(1, sizeof *ip)) == NULL)
  		return NULL;
diff -c heirloom-060122/libcommon/iblok.h heirloom-060122-patched/libcommon/iblok.h
*** heirloom-060122/libcommon/iblok.h Fri Dec 10 01:27:14 2004
--- heirloom-060122-patched/libcommon/iblok.h Tue Oct 17 02:03:43 2006
***************
*** 29,37 ****
  #include	<stdio.h>		/* for EOF */
  #include	<wchar.h>		/* for wchar_t */
  #include	<limits.h>		/* for MB_LEN_MAX */
! 
! struct	iblok {
! 	long long	ib_endoff;	/* offset of endc from start of file */
  	char	ib_mbuf[MB_LEN_MAX+1];	/* multibyte overflow buffer */
  	char	*ib_mcur;		/* next byte to read in ib_mbuf */
  	char	*ib_mend;		/* one beyond last byte in ib_mbuf */
--- 29,42 ----
  #include	<stdio.h>		/* for EOF */
  #include	<wchar.h>		/* for wchar_t */
  #include	<limits.h>		/* for MB_LEN_MAX */
! #ifdef _MINIX
! #define LONGLONG long
! #else
! #define LONGLONG long long
! #endif
! 
! struct	iblok {
! 	LONGLONG	ib_endoff;	/* offset of endc from start of file */
  	char	ib_mbuf[MB_LEN_MAX+1];	/* multibyte overflow buffer */
  	char	*ib_mcur;		/* next byte to read in ib_mbuf */
  	char	*ib_mend;		/* one beyond last byte in ib_mbuf */
Only in heirloom-060122-patched/libcommon: libcommon.a
diff -c heirloom-060122/libcommon/memalign.c heirloom-060122-patched/libcommon/memalign.c
*** heirloom-060122/libcommon/memalign.c Sun Jan 22 19:06:14 2006
--- heirloom-060122-patched/libcommon/memalign.c Tue Oct 17 15:54:53 2006
***************
*** 23,29 ****
  
  #if defined (__FreeBSD__) || defined (__dietlibc__) || defined (_AIX) || \
  	defined (__NetBSD__) || defined (__OpenBSD__) || \
! 	defined (__DragonFly__) || defined (__APPLE__)
  /*
   * FreeBSD malloc(3) promises to page-align the return of malloc() calls
   * if size is at least a page. This serves for a poor man's memalign() 
--- 23,29 ----
  
  #if defined (__FreeBSD__) || defined (__dietlibc__) || defined (_AIX) || \
  	defined (__NetBSD__) || defined (__OpenBSD__) || \
! 	defined (__DragonFly__) || defined (__APPLE__) || defined(_MINIX)
  /*
   * FreeBSD malloc(3) promises to page-align the return of malloc() calls
   * if size is at least a page. This serves for a poor man's memalign() 
diff -c heirloom-060122/libcommon/memalign.h heirloom-060122-patched/libcommon/memalign.h
*** heirloom-060122/libcommon/memalign.h Sun Jan 22 19:06:14 2006
--- heirloom-060122-patched/libcommon/memalign.h Tue Oct 17 22:51:35 2006
***************
*** 26,32 ****
  
  #if defined (__FreeBSD__) || defined (__dietlibc__) || defined (_AIX) || \
  	defined (__NetBSD__) || defined (__OpenBSD__) || \
! 	defined (__DragonFly__) || defined (__APPLE__)
  #include	<stdlib.h>
  
  extern void	*memalign(size_t, size_t);
--- 26,32 ----
  
  #if defined (__FreeBSD__) || defined (__dietlibc__) || defined (_AIX) || \
  	defined (__NetBSD__) || defined (__OpenBSD__) || \
! 	defined (__DragonFly__) || defined (__APPLE__) || defined(_MINIX)
  #include	<stdlib.h>
  
  extern void	*memalign(size_t, size_t);
diff -c heirloom-060122/libcommon/oblok.c heirloom-060122-patched/libcommon/oblok.c
*** heirloom-060122/libcommon/oblok.c Fri Jul 16 15:38:21 2004
--- heirloom-060122-patched/libcommon/oblok.c Tue Oct 17 02:05:47 2006
***************
*** 27,33 ****
  #include	<errno.h>
  #include	<stdio.h>
  #include	<stdlib.h>
! #include	<malloc.h>
  
  #include	"memalign.h"
  #include	"oblok.h"
--- 27,35 ----
  #include	<errno.h>
  #include	<stdio.h>
  #include	<stdlib.h>
! #ifndef _MINIX
! #include	<malloc.h>
! #endif
  
  #include	"memalign.h"
  #include	"oblok.h"
diff -c heirloom-060122/libcommon/oblok.h heirloom-060122-patched/libcommon/oblok.h
*** heirloom-060122/libcommon/oblok.h Thu Apr 17 20:34:53 2003
--- heirloom-060122-patched/libcommon/oblok.h Tue Oct 17 02:06:31 2006
***************
*** 22,27 ****
--- 22,32 ----
  /*	Sccsid @(#)oblok.h	1.3 (gritter) 4/17/03	*/
  
  #include	<sys/types.h>
+ #ifdef _MINIX
+ #define LONGLONG long
+ #else
+ #define LONGLONG long long
+ #endif
  
  #ifndef	OBLOK
  enum	{
***************
*** 38,44 ****
  
  struct	oblok {
  	char	ob_blk[OBLOK];		/* buffered data */
! 	long long	ob_wrt;			/* amount of data written */
  	int	ob_pos;			/* position of first empty date byte */
  	int	ob_fd;			/* file descriptor to write to */
  	enum ob_mode	ob_bf;		/* buffering mode */
--- 43,49 ----
  
  struct	oblok {
  	char	ob_blk[OBLOK];		/* buffered data */
! 	LONGLONG	ob_wrt;			/* amount of data written */
  	int	ob_pos;			/* position of first empty date byte */
  	int	ob_fd;			/* file descriptor to write to */
  	enum ob_mode	ob_bf;		/* buffering mode */
Only in heirloom-060122-patched/libcommon: realpath.c
Only in heirloom-060122-patched/libcommon: realpath.h
Only in heirloom-060122-patched/libcommon: savethis
diff -c heirloom-060122/libcommon/sfile.c heirloom-060122-patched/libcommon/sfile.c
*** heirloom-060122/libcommon/sfile.c Mon Jun  7 00:15:06 2004
--- heirloom-060122-patched/libcommon/sfile.c Tue Oct 17 02:07:29 2006
***************
*** 91,98 ****
  #include	<sys/types.h>
  
  /*ARGSUSED*/
! long long
! sfile(int dfd, int sfd, mode_t mode, long long count)
  {
  	return 0;
  }
--- 91,103 ----
  #include	<sys/types.h>
  
  /*ARGSUSED*/
! #ifdef _MINIX
! long
! sfile(int dfd, int sfd, mode_t mode, long count)
! #else
! long long
! sfile(int dfd, int sfd, mode_t mode, long long count)
! #endif
  {
  	return 0;
  }
diff -c heirloom-060122/libcommon/sfile.h heirloom-060122-patched/libcommon/sfile.h
*** heirloom-060122/libcommon/sfile.h Thu Apr 17 20:34:53 2003
--- heirloom-060122-patched/libcommon/sfile.h Tue Oct 17 15:52:45 2006
***************
*** 21,26 ****
--- 21,32 ----
   */
  /*	Sccsid @(#)sfile.h	1.4 (gritter) 4/17/03	*/
  
+ #ifdef _MINIX
+ #define LONGLONG long
+ #else
+ #define LONGLONG long long
+ #endif
+ 
  /*
   * Return values:
   *
***************
*** 36,40 ****
   *
   * -1		An error occured; operation may not continue.
   */
! extern long long	sfile(int dst_fd, int src_fd, mode_t src_mode,
! 				long long src_size);
--- 42,46 ----
   *
   * -1		An error occured; operation may not continue.
   */
! extern LONGLONG	sfile(int dst_fd, int src_fd, mode_t src_mode,
! 				LONGLONG src_size);
diff -c heirloom-060122/libcommon/sighold.c heirloom-060122-patched/libcommon/sighold.c
*** heirloom-060122/libcommon/sighold.c Sun Jan 22 19:06:14 2006
--- heirloom-060122-patched/libcommon/sighold.c Wed Oct 18 20:55:59 2006
***************
*** 22,28 ****
  /*	Sccsid @(#)sighold.c	1.7 (gritter) 1/22/06	*/
  
  #if defined (__FreeBSD__) || defined (__dietlibc__) || defined (__NetBSD__) || \
! 	defined (__OpenBSD__) || defined (__DragonFly__) || defined (__APPLE__)
  #include <signal.h>
  #include "sigset.h"
  
--- 22,29 ----
  /*	Sccsid @(#)sighold.c	1.7 (gritter) 1/22/06	*/
  
  #if defined (__FreeBSD__) || defined (__dietlibc__) || defined (__NetBSD__) || \
! 	defined (__OpenBSD__) || defined (__DragonFly__) || defined (__APPLE__) || \
!     defined (_MINIX)
  #include <signal.h>
  #include "sigset.h"
  
diff -c heirloom-060122/libcommon/sigrelse.c heirloom-060122-patched/libcommon/sigrelse.c
*** heirloom-060122/libcommon/sigrelse.c Sun Jan 22 19:06:14 2006
--- heirloom-060122-patched/libcommon/sigrelse.c Tue Oct 17 15:59:53 2006
***************
*** 22,28 ****
  /*	Sccsid @(#)sigrelse.c	1.8 (gritter) 1/22/06	*/
  
  #if defined (__FreeBSD__) || defined (__dietlibc__) || defined (__NetBSD__) || \
! 	defined (__OpenBSD__) || defined (__DragonFly__) || defined (__APPLE__)
  #include <signal.h>
  #include "sigset.h"
  
--- 22,29 ----
  /*	Sccsid @(#)sigrelse.c	1.8 (gritter) 1/22/06	*/
  
  #if defined (__FreeBSD__) || defined (__dietlibc__) || defined (__NetBSD__) || \
! 	defined (__OpenBSD__) || defined (__DragonFly__) || defined (__APPLE__) || \
!     defined(_MINIX)
  #include <signal.h>
  #include "sigset.h"
  
diff -c heirloom-060122/libcommon/sigset.c heirloom-060122-patched/libcommon/sigset.c
*** heirloom-060122/libcommon/sigset.c Sun Jan 22 19:06:14 2006
--- heirloom-060122-patched/libcommon/sigset.c Tue Oct 17 16:00:59 2006
***************
*** 22,28 ****
  /*	Sccsid @(#)sigset.c	1.7 (gritter) 1/22/06	*/
  
  #if defined (__FreeBSD__) || defined (__dietlibc__) || defined (__NetBSD__) || \
! 	defined (__OpenBSD__) || defined (__DragonFly__) || defined (__APPLE__)
  #include <signal.h>
  #include "sigset.h"
  
--- 22,29 ----
  /*	Sccsid @(#)sigset.c	1.7 (gritter) 1/22/06	*/
  
  #if defined (__FreeBSD__) || defined (__dietlibc__) || defined (__NetBSD__) || \
! 	defined (__OpenBSD__) || defined (__DragonFly__) || defined (__APPLE__) || \
!     defined (_MINIX)
  #include <signal.h>
  #include "sigset.h"
  
diff -c heirloom-060122/libcommon/sigset.h heirloom-060122-patched/libcommon/sigset.h
*** heirloom-060122/libcommon/sigset.h Sun Jan 22 19:06:14 2006
--- heirloom-060122-patched/libcommon/sigset.h Tue Oct 17 22:52:59 2006
***************
*** 22,28 ****
  /*	Sccsid @(#)sigset.h	1.9 (gritter) 1/22/06	*/
  
  #if defined (__FreeBSD__) || defined (__dietlibc__) || defined (__NetBSD__) || \
! 	defined (__OpenBSD__) || defined (__DragonFly__) || defined (__APPLE__)
  
  #ifndef	SIG_HOLD
  #define	SIG_HOLD	((void (*)(int))2)
--- 22,29 ----
  /*	Sccsid @(#)sigset.h	1.9 (gritter) 1/22/06	*/
  
  #if defined (__FreeBSD__) || defined (__dietlibc__) || defined (__NetBSD__) || \
! 	defined (__OpenBSD__) || defined (__DragonFly__) || defined (__APPLE__) || \
!     defined (_MINIX)
  
  #ifndef	SIG_HOLD
  #define	SIG_HOLD	((void (*)(int))2)
Common subdirectories: heirloom-060122/libuxre and heirloom-060122-patched/libuxre
Only in heirloom-060122-patched/libuxre: Makefile
diff -c heirloom-060122/libuxre/Makefile.mk heirloom-060122-patched/libuxre/Makefile.mk
*** heirloom-060122/libuxre/Makefile.mk Sun Jan 22 18:33:50 2006
--- heirloom-060122-patched/libuxre/Makefile.mk Tue Oct 17 02:15:35 2006
***************
*** 6,12 ****
  OBJ = onefile.o regfree.o regerror.o
  
  libuxre.a: $(OBJ)
! 	$(AR) -rv $@ $(OBJ)
  	$(RANLIB) $@
  
  onefile.o: onefile.c
--- 6,12 ----
  OBJ = onefile.o regfree.o regerror.o
  
  libuxre.a: $(OBJ)
! 	$(AR) rv $@ $(OBJ)
  	$(RANLIB) $@
  
  onefile.o: onefile.c
diff -c heirloom-060122/libuxre/_collelem.c heirloom-060122-patched/libuxre/_collelem.c
*** heirloom-060122/libuxre/_collelem.c Sat Oct 18 19:16:46 2003
--- heirloom-060122-patched/libuxre/_collelem.c Tue Oct 17 02:51:05 2006
***************
*** 105,111 ****
  					{
  						w = spare->weight[0];
  					}
! 					spare->weight[lo] = w;
  				}
  				return spare;
  			}
--- 105,118 ----
  					{
  						w = spare->weight[0];
  					}
! #ifdef _MINIX
!                     {
!                         wuchar_type *wuctp = &(spare->weight);
!                         wuctp[lo]=w;
!                     }
! #else
! 					spare->weight[lo] = w;
! #endif
  				}
  				return spare;
  			}
Only in heirloom-060122-patched/libuxre: libuxre.a
Common subdirectories: heirloom-060122/libwchar and heirloom-060122-patched/libwchar
Only in heirloom-060122-patched/libwchar: Makefile
diff -c heirloom-060122/libwchar/Makefile.mk heirloom-060122-patched/libwchar/Makefile.mk
*** heirloom-060122/libwchar/Makefile.mk Sun Jan 22 18:34:02 2006
--- heirloom-060122-patched/libwchar/Makefile.mk Tue Oct 17 02:15:35 2006
***************
*** 3,9 ****
  OBJ = mbtowc.o wctomb.o wctype.o mbstowcs.o wcwidth.o wcslen.o wcsncmp.o \
  	mbrtowc.o wctfunc.o mblen.o
  libwchar.a: fake $(OBJ)
! 	$(AR) -rv $@ $(OBJ)
  	$(RANLIB) $@
  
  fake:
--- 3,9 ----
  OBJ = mbtowc.o wctomb.o wctype.o mbstowcs.o wcwidth.o wcslen.o wcsncmp.o \
  	mbrtowc.o wctfunc.o mblen.o
  libwchar.a: fake $(OBJ)
! 	$(AR) rv $@ $(OBJ)
  	$(RANLIB) $@
  
  fake:
Only in heirloom-060122-patched/libwchar: libwchar.a
diff -c heirloom-060122/libwchar/wchar.h heirloom-060122-patched/libwchar/wchar.h
*** heirloom-060122/libwchar/wchar.h Tue Aug  2 23:29:17 2005
--- heirloom-060122-patched/libwchar/wchar.h Tue Oct 17 01:47:37 2006
***************
*** 100,108 ****
  wchar_t		*wcstok(wchar_t *, const wchar_t *, wchar_t **);
  long		wcstol(const wchar_t *, wchar_t **, int);
  long double	wcstold(const wchar_t *, wchar_t **);
! long long	wcstoll(const wchar_t *, wchar_t **, int);
! unsigned long	wcstoul(const wchar_t *, wchar_t **, int);
! unsigned long long	wcstoull(const wchar_t *, wchar_t **, int);
  wchar_t		*wcswcs(const wchar_t *, const wchar_t *);
  int		wcswidth(const wchar_t *, size_t);
  size_t		wcsxfrm(wchar_t *, const wchar_t *, size_t);
--- 100,113 ----
  wchar_t		*wcstok(wchar_t *, const wchar_t *, wchar_t **);
  long		wcstol(const wchar_t *, wchar_t **, int);
  long double	wcstold(const wchar_t *, wchar_t **);
! #ifndef _MINIX
! long long	wcstoll(const wchar_t *, wchar_t **, int);
! unsigned long long	wcstoull(const wchar_t *, wchar_t **, int);
! #else
! long	wcstoll(const wchar_t *, wchar_t **, int);
! unsigned long	wcstoull(const wchar_t *, wchar_t **, int);
! #endif
! unsigned long	wcstoul(const wchar_t *, wchar_t **, int);
  wchar_t		*wcswcs(const wchar_t *, const wchar_t *);
  int		wcswidth(const wchar_t *, size_t);
  size_t		wcsxfrm(wchar_t *, const wchar_t *, size_t);
diff -c heirloom-060122/libwchar/wctype.c heirloom-060122-patched/libwchar/wctype.c
*** heirloom-060122/libwchar/wctype.c Tue Sep 28 18:53:28 2004
--- heirloom-060122-patched/libwchar/wctype.c Tue Oct 17 02:37:17 2006
***************
*** 25,30 ****
--- 25,36 ----
  #include <string.h>
  #include <blank.h>
  
+ #ifdef _MINIX
+ int (isblank)(int c) {
+     return isblank(c);
+ }
+ #endif
+ 
  #define	thistype(s)	if (strcmp((#s), property) == 0) { \
  				func = is ##s; \
  				goto found; \
diff -c heirloom-060122/libwchar/wctype.h heirloom-060122-patched/libwchar/wctype.h
*** heirloom-060122/libwchar/wctype.h Sat May  1 17:01:02 2004
--- heirloom-060122-patched/libwchar/wctype.h Tue Oct 17 02:34:24 2006
***************
*** 30,35 ****
--- 30,40 ----
  
  typedef	int	wctrans_t;
  
+ #ifdef _MINIX
+ _PROTOTYPE( int isblank, (int _c) );
+ #define isblank(c) ( (c) == ' ' || (c) == '\t' )
+ #endif
+ 
  #define	iswalnum(c)	isalnum(c)
  #define	iswalpha(c)	isalpha(c)
  #define	iswblank(c)	isblank(c)
Common subdirectories: heirloom-060122/line and heirloom-060122-patched/line
Only in heirloom-060122-patched/line: Makefile
Common subdirectories: heirloom-060122/listusers and heirloom-060122-patched/listusers
Only in heirloom-060122-patched/listusers: Makefile
Common subdirectories: heirloom-060122/ln and heirloom-060122-patched/ln
Only in heirloom-060122-patched/ln: Makefile
Common subdirectories: heirloom-060122/logins and heirloom-060122-patched/logins
Only in heirloom-060122-patched/logins: Makefile
Common subdirectories: heirloom-060122/logname and heirloom-060122-patched/logname
Only in heirloom-060122-patched/logname: Makefile
Common subdirectories: heirloom-060122/ls and heirloom-060122-patched/ls
Only in heirloom-060122-patched/ls: Makefile
diff -c heirloom-060122/ls/ls.c heirloom-060122-patched/ls/ls.c
*** heirloom-060122/ls/ls.c Sun May 29 12:55:42 2005
--- heirloom-060122-patched/ls/ls.c Tue Oct 17 02:01:32 2006
***************
*** 155,160 ****
--- 155,166 ----
  #define ST_BLOCKS 1
  #endif
  
+ #if ST_BLOCKS
+ #define nblocks(f)  ((f)->blocks)
+ #else
+ #define nblocks(f)  (((f)->size + BLOCK - 1 ) / BLOCK )
+ #endif
+ 
  /* Some terminals ignore more than 80 characters on a line.  Dumb ones wrap
   * when the cursor hits the side.  Nice terminals don't wrap until they have
   * to print the 81st character.  Wether we like it or not, no column 80.
***************
*** 803,809 ****
  #ifdef S_IFLNK
  		case S_IFLNK:
  #endif
! 			cb += flist->blocks;
  		}
  		flist = flist->next;
  	}
--- 809,815 ----
  #ifdef S_IFLNK
  		case S_IFLNK:
  #endif
!             cb += nblocks(flist);
  		}
  		flist = flist->next;
  	}
***************
*** 1166,1172 ****
  		char	dummy[2];
  		if (doit) {
  			if (present('h'))
! 				printf("%s ", hfmt(f->blocks * 512,
  							!present('m')));
  			else
  #ifdef	LONGLONG
--- 1172,1178 ----
  		char	dummy[2];
  		if (doit) {
  			if (present('h'))
! 				printf("%s ", hfmt(nblocks(f) * 512,
  							!present('m')));
  			else
  #ifdef	LONGLONG
***************
*** 1174,1180 ****
  					(long long)blockcount(f->blocks));
  #else
  				printf("%*lu ", present('m') ? 1 : 4,
! 					(long)blockcount(f->blocks));
  #endif
  		} else {
  			if (present('h'))
--- 1180,1186 ----
  					(long long)blockcount(f->blocks));
  #else
  				printf("%*lu ", present('m') ? 1 : 4,
! 					(long)blockcount(nblocks(f)));
  #endif
  		} else {
  			if (present('h'))
***************
*** 1187,1193 ****
  #else
  				width += snprintf(dummy, sizeof dummy, "%*lu ",
  					present('m') ? 1 : 4,
! 					(long)f->blocks);
  #endif
  		}
  	}
--- 1193,1199 ----
  #else
  				width += snprintf(dummy, sizeof dummy, "%*lu ",
  					present('m') ? 1 : 4,
! 					(long)nblocks(f));
  #endif
  		}
  	}
Common subdirectories: heirloom-060122/mail and heirloom-060122-patched/mail
Only in heirloom-060122-patched/mail: Makefile
diff -c heirloom-060122/mail/done.c heirloom-060122-patched/mail/done.c
*** heirloom-060122/mail/done.c Wed Jun 22 01:42:38 2005
--- heirloom-060122-patched/mail/done.c Wed Oct 18 16:19:49 2006
***************
*** 53,59 ****
  	case EPERM:
  	case EACCES:
  	case ENOSPC:
!         case EDQUOT:
  		rc = 73;	/* EX_CANTCREAT */
  		break;
  	case EAGAIN:
--- 53,59 ----
  	case EPERM:
  	case EACCES:
  	case ENOSPC:
! 	case EDQUOT:
  		rc = 73;	/* EX_CANTCREAT */
  		break;
  	case EAGAIN:
diff -c heirloom-060122/mail/islocal.c heirloom-060122-patched/mail/islocal.c
*** heirloom-060122/mail/islocal.c Wed Jun 22 03:15:14 2005
--- heirloom-060122-patched/mail/islocal.c Wed Oct 18 16:20:20 2006
***************
*** 32,38 ****
  
  #include <sys/param.h>
  #include "mail.h"
- 
  /*
   * islocal (char *user, uid_t *puid) - see if user exists on this system
   */
--- 32,37 ----
diff -c heirloom-060122/mail/mail.h heirloom-060122-patched/mail/mail.h
*** heirloom-060122/mail/mail.h Sat Jul  2 23:11:41 2005
--- heirloom-060122-patched/mail/mail.h Wed Oct 18 16:22:15 2006
***************
*** 492,495 ****
  			*(to) = srealloc(*(to), *(tosize) += 32); \
  		(*(to))[(i)++]
  
! #endif /* _MAIL_H */
--- 492,502 ----
  			*(to) = srealloc(*(to), *(tosize) += 32); \
  		(*(to))[(i)++]
  
! #ifdef _MINIX
! #define EDQUOT 122
! #define EOVERFLOW 75
! #define MAXPATHLEN PATH_MAX
! #define INADDR_LOOPBACK 0x7f000001L
! #endif
! 
! #endif /* _MAIL_H */
diff -c heirloom-060122/makefile heirloom-060122-patched/makefile
*** heirloom-060122/makefile Sun Jan 22 21:48:04 2006
--- heirloom-060122-patched/makefile Wed Oct 18 17:12:49 2006
***************
*** 1,19 ****
  SHELL = /bin/sh
  
  SUBDIRS = build libwchar libcommon libuxre _install \
  	banner basename bc bdiff bfs \
  	cal calendar cat chmod chown \
! 	cksum cmp col comm copy cp cpio csplit cut \
  	date dc dd deroff diff diff3 dircmp dirname df du \
  	echo ed env expand expr \
  	factor file find fmt fmtmsg fold \
  	getconf getopt grep groups hd head hostname id join \
  	kill line listusers ln logins logname ls \
  	mail man mesg mkdir mkfifo mknod more mvdir \
! 	nawk news nice nl nohup oawk od \
! 	paste pathchk pg pgrep pr printenv printf priocntl ps psrinfo pwd \
! 	random renice rm rmdir \
! 	sdiff sed setpgrp shl sleep sort spell split stty su sum sync \
  	tabs tail tapecntl tar tcopy tee test time touch tr true tsort tty \
  	ul uname uniq units users wc what who whoami whodo xargs yes
  
--- 1,21 ----
  SHELL = /bin/sh
  
+ SKIPSUBDIRS = cpio
+ 
  SUBDIRS = build libwchar libcommon libuxre _install \
  	banner basename bc bdiff bfs \
  	cal calendar cat chmod chown \
! 	cksum cmp col comm copy cp csplit cut \
  	date dc dd deroff diff diff3 dircmp dirname df du \
  	echo ed env expand expr \
  	factor file find fmt fmtmsg fold \
  	getconf getopt grep groups hd head hostname id join \
  	kill line listusers ln logins logname ls \
  	mail man mesg mkdir mkfifo mknod more mvdir \
! 	nawk news nice nl nohup sed oawk od \
! 	paste pathchk pg pgrep pr printenv printf priocntl ps psrinfo pwd \
! 	random renice rm rmdir \
! 	sdiff setpgrp shl sleep sort spell split stty su sum sync \
  	tabs tail tapecntl tar tcopy tee test time touch tr true tsort tty \
  	ul uname uniq units users wc what who whoami whodo xargs yes
  
***************
*** 102,111 ****
  	rm -rf $(PKGPROTO) $(PKGTEMP)/heirloom
  
  DIETFLAGS =	CC="$(HOME)/src/diet gcc" HOSTCC="$(HOME)/src/diet gcc" \
! 		CFLAGS="-Os -fomit-frame-pointer" \
! 		CFLAGSS="-Os -fomit-frame-pointer" \
! 		CFLAGS2="-Os -fomit-frame-pointer" \
! 		CFLAGSU="-Os -fomit-frame-pointer" \
  		LCRYPT= \
  		IWCHAR=-I../libwchar LWCHAR="-L../libwchar -lwchar" \
  		DEFBIN=/5bin SV3BIN=/5bin S42BIN=/5bin/s42 \
--- 104,113 ----
  	rm -rf $(PKGPROTO) $(PKGTEMP)/heirloom
  
  DIETFLAGS =	CC="$(HOME)/src/diet gcc" HOSTCC="$(HOME)/src/diet gcc" \
! 		CFLAGS="-Os " \
! 		CFLAGSS="-Os " \
! 		CFLAGS2="-Os " \
! 		CFLAGSU="-Os " \
  		LCRYPT= \
  		IWCHAR=-I../libwchar LWCHAR="-L../libwchar -lwchar" \
  		DEFBIN=/5bin SV3BIN=/5bin S42BIN=/5bin/s42 \
***************
*** 140,148 ****
  
  pie:
  	$(MAKE) \
! 		CFLAGS="-Os -fomit-frame-pointer -fPIE" \
! 		CFLAGSS="-Os -fomit-frame-pointer -fPIE" \
! 		CFLAGS2="-Os -fomit-frame-pointer -fPIE" \
  		LDFLAGS="-pie"
  
  ps2:
--- 142,150 ----
  
  pie:
  	$(MAKE) \
! 		CFLAGS="-Os  -fPIE" \
! 		CFLAGSS="-Os  -fPIE" \
! 		CFLAGS2="-Os  -fPIE" \
  		LDFLAGS="-pie"
  
  ps2:
***************
*** 152,161 ****
  
  ps2diet:
  	$(MAKE) CC="$(HOME)/src/diet gcc" \
! 		CFLAGS="-Os -fomit-frame-pointer" \
! 		CFLAGSS="-Os -fomit-frame-pointer" \
! 		CFLAGS2="-Os -fomit-frame-pointer" \
! 		CFLAGSU="-Os -fomit-frame-pointer" \
  		LCRYPT= \
  		IWCHAR=-I../libwchar LWCHAR="-L../libwchar -lwchar" \
  		WARN="-Wchar-subscripts -Wimplicit \
--- 154,163 ----
  
  ps2diet:
  	$(MAKE) CC="$(HOME)/src/diet gcc" \
! 		CFLAGS="-Os " \
! 		CFLAGSS="-Os " \
! 		CFLAGS2="-Os " \
! 		CFLAGSU="-Os " \
  		LCRYPT= \
  		IWCHAR=-I../libwchar LWCHAR="-L../libwchar -lwchar" \
  		WARN="-Wchar-subscripts -Wimplicit \
Common subdirectories: heirloom-060122/man and heirloom-060122-patched/man
Only in heirloom-060122-patched/man: Makefile
diff -c heirloom-060122/man/Makefile.mk heirloom-060122-patched/man/Makefile.mk
*** heirloom-060122/man/Makefile.mk Sun Jul 18 13:15:48 2004
--- heirloom-060122-patched/man/Makefile.mk Fri Oct 20 23:56:22 2006
***************
*** 10,15 ****
--- 10,22 ----
  
  bang.ksh:
  	@IFS=: ;\
+ 	if test "`uname`" = Minix ;\
+ 	then \
+ 		echo "selected /usr/local/bin/ksh" ; \
+ 		echo "#! /usr/local/bin/ksh" > bang.ksh ; \
+ 		echo "DFLDIR=$(DFLDIR)" >> bang.ksh ; \
+ 		exit ; \
+ 	fi ; \
  	if test "`uname`" = HP-UX ;\
  	then \
  		order='bash ksh';\
Common subdirectories: heirloom-060122/mesg and heirloom-060122-patched/mesg
Only in heirloom-060122-patched/mesg: Makefile
Common subdirectories: heirloom-060122/mkdir and heirloom-060122-patched/mkdir
Only in heirloom-060122-patched/mkdir: Makefile
Common subdirectories: heirloom-060122/mkfifo and heirloom-060122-patched/mkfifo
Only in heirloom-060122-patched/mkfifo: Makefile
Common subdirectories: heirloom-060122/mknod and heirloom-060122-patched/mknod
Only in heirloom-060122-patched/mknod: Makefile
Common subdirectories: heirloom-060122/more and heirloom-060122-patched/more
Only in heirloom-060122-patched/more: Makefile
diff -c heirloom-060122/more/more.c heirloom-060122-patched/more/more.c
*** heirloom-060122/more/more.c Sun May 29 12:55:43 2005
--- heirloom-060122-patched/more/more.c Wed Oct 18 16:35:43 2006
***************
*** 96,101 ****
--- 96,108 ----
  
  #include <mbtowi.h>
  
+ #ifdef _MINIX
+ #define MAX_OFF_T 0x7fffffffL
+ #define fseeko fseek
+ #else
+ #define MAX_OFF_T 0x7fffffffffffffffL
+ #endif
+ 
  #ifdef	__GLIBC__
  #ifdef	_IO_getc_unlocked
  #undef	getc
***************
*** 392,398 ****
  		left = command (fnames[fnum], f);
  	    }
  	    if (left != 0) {
! 		if ((noscroll || clearit) && (file_size!=0x7fffffffffffffffLL))
  		    if (clreol)
  			home ();
  		    else
--- 399,405 ----
  		left = command (fnames[fnum], f);
  	    }
  	    if (left != 0) {
! 		if ((noscroll || clearit) && (file_size!=MAX_OFF_T))
  		    if (clreol)
  			home ();
  		    else
***************
*** 564,570 ****
  	fseeko(f, 0, SEEK_SET);
      }
      if ((file_size = stbuf.st_size) == 0)
! 	file_size = 0x7fffffffffffffffLL;
      return (f);
  }
  
--- 571,577 ----
  	fseeko(f, 0, SEEK_SET);
      }
      if ((file_size = stbuf.st_size) == 0)
! 	file_size = MAX_OFF_T;
      return (f);
  }
  
***************
*** 1603,1613 ****
  	 * Wait until we're in the foreground before we save the
  	 * the terminal modes.
  	 */
  	if ((tgrp = tcgetpgrp(fileno(stdout))) < 0) {
  	    perror("tcgetpgrp");
  	    exit(1);
  	}
! 	if (tgrp != getpgid(0)) {
  	    kill(0, SIGTTOU);
  	    goto retry;
  	}
--- 1610,1628 ----
  	 * Wait until we're in the foreground before we save the
  	 * the terminal modes.
  	 */
+ #ifdef _MINIX
+     tgrp = getpgrp();
+ #else
  	if ((tgrp = tcgetpgrp(fileno(stdout))) < 0) {
  	    perror("tcgetpgrp");
  	    exit(1);
  	}
! #endif
! #ifdef _MINIX
! 	if (tgrp != getpgrp()) {
! #else
! 	if (tgrp != getpgid(0)) {
! #endif
  	    kill(0, SIGTTOU);
  	    goto retry;
  	}
Common subdirectories: heirloom-060122/mvdir and heirloom-060122-patched/mvdir
Only in heirloom-060122-patched/mvdir: Makefile
diff -c heirloom-060122/mvdir/Makefile.mk heirloom-060122-patched/mvdir/Makefile.mk
*** heirloom-060122/mvdir/Makefile.mk Sat Jun 25 17:03:27 2005
--- heirloom-060122-patched/mvdir/Makefile.mk Wed Oct 18 16:37:39 2006
***************
*** 1,10 ****
  all: mvdir
  
  mvdir: mvdir.sh
! 	echo '#!$(SHELL)' | cat - mvdir.sh | sed ' \
! 		s,@DEFBIN@,$(DEFBIN),g; \
! 		s,@SV3BIN@,$(SV3BIN),g; \
! 		s,@DEFLIB@,$(DEFLIB),g' >mvdir
  	chmod 755 mvdir
  
  install: all
--- 1,7 ----
  all: mvdir
  
  mvdir: mvdir.sh
! 	echo '#!$(SHELL)' | cat - mvdir.sh | sed 's,@DEFBIN@,$(DEFBIN),g; s,@SV3BIN@,$(SV3BIN),g; s,@DEFLIB@,$(DEFLIB),g' >mvdir
  	chmod 755 mvdir
  
  install: all
Common subdirectories: heirloom-060122/nawk and heirloom-060122-patched/nawk
Only in heirloom-060122-patched/nawk: Makefile
diff -c heirloom-060122/nawk/main.c heirloom-060122-patched/nawk/main.c
*** heirloom-060122/nawk/main.c Sun Dec 19 02:23:10 2004
--- heirloom-060122-patched/nawk/main.c Wed Oct 18 16:39:11 2006
***************
*** 35,41 ****
  #include <errno.h>
  #include <string.h>
  #include <locale.h>
! #include <langinfo.h>
  #include <libgen.h>
  
  #define	CMDCLASS	""/*"UX:"*/	/* Command classification */
--- 35,43 ----
  #include <errno.h>
  #include <string.h>
  #include <locale.h>
! #ifndef _MINIX
! #include <langinfo.h>
! #endif  /* why is this here anyway? */
  #include <libgen.h>
  
  #define	CMDCLASS	""/*"UX:"*/	/* Command classification */
Common subdirectories: heirloom-060122/news and heirloom-060122-patched/news
Only in heirloom-060122-patched/news: Makefile
Common subdirectories: heirloom-060122/nice and heirloom-060122-patched/nice
Only in heirloom-060122-patched/nice: Makefile
diff -c heirloom-060122/nice/nice.c heirloom-060122-patched/nice/nice.c
*** heirloom-060122/nice/nice.c Sun May 29 12:55:43 2005
--- heirloom-060122-patched/nice/nice.c Wed Oct 18 16:52:48 2006
***************
*** 41,46 ****
--- 41,50 ----
  #include	<errno.h>
  #include	<libgen.h>
  
+ #ifdef _MINIX
+ #include <sys/resource.h>
+ #endif
+ 
  static unsigned	errcnt;			/* count of errors */
  static char	*progname;		/* argv[0] to main() */
  
***************
*** 116,122 ****
  optend:
  	if (i >= argc)
  		usage();
! 	nice(niceval);
  	execvp(argv[i], &argv[i]);
  	e = errno;
  	pnerror(e, argv[i]);
--- 120,138 ----
  optend:
  	if (i >= argc)
  		usage();
! #ifdef _MINIX
!     niceval += getpriority(PRIO_PROCESS, 0);
!     if (errno) {
!         perror("getpriority");
!         return 1;
!     }
!     if (setpriority(PRIO_PROCESS, 0, niceval)) {
!         perror("setpriority");
!         return 1;
!     }
! #else
! 	nice(niceval);
! #endif
  	execvp(argv[i], &argv[i]);
  	e = errno;
  	pnerror(e, argv[i]);
Common subdirectories: heirloom-060122/nl and heirloom-060122-patched/nl
Only in heirloom-060122-patched/nl: Makefile
diff -c heirloom-060122/nl/nl.c heirloom-060122-patched/nl/nl.c
*** heirloom-060122/nl/nl.c Sun May 29 12:55:43 2005
--- heirloom-060122-patched/nl/nl.c Wed Oct 18 16:57:51 2006
***************
*** 58,63 ****
--- 58,69 ----
  #include	<iblok.h>
  #include	<mbtowi.h>
  
+ #ifdef _MINIX
+ #define LONGLONG long
+ #else
+ #define LONGLONG long long
+ #endif
+ 
  struct	type {
  	const char	*t_str;
  	int	t_chr;
***************
*** 96,102 ****
  
  static struct iblok	*input;			/* input file */
  
! static unsigned long long	number;		/* line number */
  
  static int		mb_cur_max;		/* MB_CUR_MAX acceleration */
  
--- 102,108 ----
  
  static struct iblok	*input;			/* input file */
  
! static unsigned LONGLONG	number;		/* line number */
  
  static int		mb_cur_max;		/* MB_CUR_MAX acceleration */
  
***************
*** 400,406 ****
  }
  
  static size_t
! mknum(char *buf, int size, unsigned long long n)
  {
  	char	*cp;
  
--- 406,412 ----
  }
  
  static size_t
! mknum(char *buf, int size, unsigned LONGLONG n)
  {
  	char	*cp;
  
Common subdirectories: heirloom-060122/nohup and heirloom-060122-patched/nohup
Only in heirloom-060122-patched/nohup: Makefile
Common subdirectories: heirloom-060122/oawk and heirloom-060122-patched/oawk
Only in heirloom-060122-patched/oawk: Makefile
diff -c heirloom-060122/oawk/Makefile.mk heirloom-060122-patched/oawk/Makefile.mk
*** heirloom-060122/oawk/Makefile.mk Sat Oct  2 18:23:20 2004
--- heirloom-060122-patched/oawk/Makefile.mk Fri Oct 20 23:06:46 2006
***************
*** 14,20 ****
  	echo '{ char *tnm;' >> $@
  	echo 'int yval;' >> $@
  	echo '} tok[] = {' >> $@
! 	sed 's/#[ 	]*define[ 	]\{1,\}\([^ 	]*\)[ 	]\{1,\}\(.*\)/{ "\1", \2 },/' \
  	    < awk.h >> $@
  	echo '};' >> $@
  	echo 'char *tokname(int n)' >> $@
--- 14,20 ----
  	echo '{ char *tnm;' >> $@
  	echo 'int yval;' >> $@
  	echo '} tok[] = {' >> $@
! 	../sed/sed 's/#[ 	]*define[ 	]\{1,\}\([^ 	]*\)[ 	]\{1,\}\(.*\)/{ "\1", \2 },/' \
  	    < awk.h >> $@
  	echo '};' >> $@
  	echo 'char *tokname(int n)' >> $@
diff -c heirloom-060122/oawk/awk.def heirloom-060122-patched/oawk/awk.def
*** heirloom-060122/oawk/awk.def Mon Oct  4 22:36:53 2004
--- heirloom-060122-patched/oawk/awk.def Wed Oct 18 17:19:07 2006
***************
*** 78,83 ****
--- 78,91 ----
  #include <stdlib.h>
  #include <inttypes.h>
  
+ #ifdef _MINIX
+ #define LONGLONG long
+ #define P_LLD "%ld"
+ #else
+ #define LONGLONG long long
+ #define P_LLD "%lld"
+ #endif
+ 
  #define	AWKFLOAT	double
  #define	xfree(a)	{ if(a!=NULL) { yfree(a); a=NULL;} }
  #define	strfree(a)	{ if(a!=NULL && a!=EMPTY) { yfree(a);} a=EMPTY; }
***************
*** 102,108 ****
  extern char	*record;
  extern char	EMPTY[];
  extern int	dbg;
! extern long long	lineno;
  extern int	errorflag;
  extern const char	*radixchar;
  extern int	radixcharlen;
--- 110,116 ----
  extern char	*record;
  extern char	EMPTY[];
  extern int	dbg;
! extern LONGLONG	lineno;
  extern int	errorflag;
  extern const char	*radixchar;
  extern int	radixcharlen;
diff -c heirloom-060122/oawk/awk.lx.l heirloom-060122-patched/oawk/awk.lx.l
*** heirloom-060122/oawk/awk.lx.l Sat Jun 18 21:46:58 2005
--- heirloom-060122-patched/oawk/awk.lx.l Wed Oct 18 17:01:29 2006
***************
*** 130,136 ****
  }
  #endif	/* !FLEX_SCANNER */
  
! long long	lineno	= 1;
  #define	RETURN(x)	{if (ldbg) ptoken(x); return(x); }
  #define	CADD	cbuf[clen++]=yytext[0]; if(clen>=CBUFLEN-1) {yyerror("string too long"); BEGIN INITIAL;}
  #define	CBUFLEN	800
--- 130,136 ----
  }
  #endif	/* !FLEX_SCANNER */
  
! LONGLONG	lineno	= 1;
  #define	RETURN(x)	{if (ldbg) ptoken(x); return(x); }
  #define	CADD	cbuf[clen++]=yytext[0]; if(clen>=CBUFLEN-1) {yyerror("string too long"); BEGIN INITIAL;}
  #define	CBUFLEN	800
diff -c heirloom-060122/oawk/lib.c heirloom-060122-patched/oawk/lib.c
*** heirloom-060122/oawk/lib.c Fri Jul 16 15:38:22 2004
--- heirloom-060122-patched/oawk/lib.c Wed Oct 18 17:19:28 2006
***************
*** 371,377 ****
  
  void
  yyerror(const char *s) {
! 	fprintf(stderr, "%s: %s near line %lld\n", progname, s, lineno);
  	errorflag = 2;
  }
  
--- 371,377 ----
  
  void
  yyerror(const char *s) {
! 	fprintf(stderr, "%s: %s near line " P_LLD "\n", progname, s, lineno);
  	errorflag = 2;
  }
  
diff -c heirloom-060122/oawk/main.c heirloom-060122-patched/oawk/main.c
*** heirloom-060122/oawk/main.c Sun Dec 12 16:05:00 2004
--- heirloom-060122-patched/oawk/main.c Wed Oct 18 17:06:51 2006
***************
*** 86,92 ****
  #include "awk.h"
  #include <libgen.h>
  #include <locale.h>
! #include <langinfo.h>
  
  int	dbg	= 0;
  int	ldbg	= 0;
--- 86,96 ----
  #include "awk.h"
  #include <libgen.h>
  #include <locale.h>
! #ifdef _MINIX
! #include "../cal/fake_langinfo.h"
! #else
! #include <langinfo.h>
! #endif
  
  int	dbg	= 0;
  int	ldbg	= 0;
diff -c heirloom-060122/oawk/tran.c heirloom-060122-patched/oawk/tran.c
*** heirloom-060122/oawk/tran.c Mon Mar 31 16:41:56 2003
--- heirloom-060122-patched/oawk/tran.c Wed Oct 18 17:18:08 2006
***************
*** 259,265 ****
  	if ((vp->tval & STR) == 0) {
  		if (!(vp->tval&FLD))
  			strfree(vp->sval);
! 		if ((long long)vp->fval==vp->fval)
  			(void)snprintf(s, sizeof s, "%.20g", vp->fval);
  		else
  			(void)snprintf(s, sizeof s, *OFMT, vp->fval);
--- 259,265 ----
  	if ((vp->tval & STR) == 0) {
  		if (!(vp->tval&FLD))
  			strfree(vp->sval);
! 		if ((LONGLONG)vp->fval==vp->fval)
  			(void)snprintf(s, sizeof s, "%.20g", vp->fval);
  		else
  			(void)snprintf(s, sizeof s, *OFMT, vp->fval);
Common subdirectories: heirloom-060122/od and heirloom-060122-patched/od
Only in heirloom-060122-patched/od: Makefile
diff -c heirloom-060122/od/od.c heirloom-060122-patched/od/od.c
*** heirloom-060122/od/od.c Sun May 29 12:55:43 2005
--- heirloom-060122-patched/od/od.c Wed Oct 18 20:46:49 2006
***************
*** 64,69 ****
--- 64,77 ----
  #endif	/* _IO_putc_unlocked */
  #endif	/* __GLIBC__ */
  
+ #ifdef _MINIX
+ #define LONGLONG long
+ #define strtoll strtol
+ #define strtoull strtoul
+ #else
+ #define LONGLONG long long
+ #endif
+ 
  enum	{
  	BLOCK = 16
  };
***************
*** 75,81 ****
  	char		b_c[BLOCK];
  	int16_t		b_16[8];
  	int32_t		b_32[4];
! 	int64_t		b_64[2];
  	float		b_f[4];
  	double		b_d[2];
  };
--- 83,91 ----
  	char		b_c[BLOCK];
  	int16_t		b_16[8];
  	int32_t		b_32[4];
! #if !defined(_MINIX)
! 	int64_t		b_64[2];
! #endif
  	float		b_f[4];
  	double		b_d[2];
  };
***************
*** 139,148 ****
  static char		*progname;	/* argv[0] to main() */
  static int		offset_base = 8;/* base of offset to be printed */
  static int		offset_oflo = 07777777;	/* max offs. in regular width */
! static long long	skip;		/* skip bytes of input */
! static long long	limit = -1;	/* print no more bytes than limit */
! static long long	total;		/* total bytes of input */
! static long long	offset;		/* offset to print */
  static int		vflag;		/* print all lines */
  static int		Cflag;		/* Cray -C option */
  static char		**files;	/* files to read */
--- 149,158 ----
  static char		*progname;	/* argv[0] to main() */
  static int		offset_base = 8;/* base of offset to be printed */
  static int		offset_oflo = 07777777;	/* max offs. in regular width */
! static LONGLONG	skip;		/* skip bytes of input */
! static LONGLONG	limit = -1;	/* print no more bytes than limit */
! static LONGLONG	total;		/* total bytes of input */
! static LONGLONG	offset;		/* offset to print */
  static int		vflag;		/* print all lines */
  static int		Cflag;		/* Cray -C option */
  static char		**files;	/* files to read */
***************
*** 342,356 ****
  
  mkfuncs(i, int)
  mkfuncs(l, long)
! mkfuncs(ll, long long)
  
  /*
   * Print the offset at the start of each row.
   */
  static void
! prna(long long addr, int c)
! {
! 	unsigned long long	a;
  	char	buf[30];
  	int	m, n, s;
  
--- 352,371 ----
  
  mkfuncs(i, int)
  mkfuncs(l, long)
! #if !defined(_MINIX)
! mkfuncs(ll, long long)
! #else
! #undef lldigit
! #define lldigit(a,b,c,d) ldigit(a,b,c,d)
! #endif
  
  /*
   * Print the offset at the start of each row.
   */
  static void
! prna(LONGLONG addr, int c)
! {
! 	unsigned LONGLONG	a;
  	char	buf[30];
  	int	m, n, s;
  
***************
*** 404,410 ****
   * Print a number of output lines, each preceded by the offset column.
   */
  static void
! prnt(long long addr, const char *s)
  {
  	int	lc = 0;
  
--- 419,425 ----
   * Print a number of output lines, each preceded by the offset column.
   */
  static void
! prnt(LONGLONG addr, const char *s)
  {
  	int	lc = 0;
  
***************
*** 583,588 ****
--- 598,608 ----
  							037777777777UL);
  					break;
  				case 8:
+ #if defined(_MINIX)
+                     fprintf(stderr, "this platform does not support 64-bit"
+                             "datatypes\n");
+                     exit(2);
+ #else
  					if (tp->t_fmt == 'd')
  						l+= llnumber(&buf[l], tp->t_prf,
  							b1->bu_blk.b_64[i]);
***************
*** 590,595 ****
--- 610,616 ----
  						l+= llnumber(&buf[l], tp->t_prf,
  							b1->bu_blk.b_64[i] &
  						01777777777777777777777ULL);
+ #endif
  					break;
  				}
  			}
***************
*** 828,834 ****
  static int
  setoffset(const char *s)
  {
! 	long long	o;
  	const char	*sp;
  	int	base = 8;
  	int	mult = 1;
--- 849,855 ----
  static int
  setoffset(const char *s)
  {
! 	LONGLONG	o;
  	const char	*sp;
  	int	base = 8;
  	int	mult = 1;
***************
*** 862,868 ****
  setskip(const char *s)
  {
  	const char	*sp = NULL;
! 	long long	o;
  	int	base = 10;
  	int	mult = 1;
  
--- 883,889 ----
  setskip(const char *s)
  {
  	const char	*sp = NULL;
! 	LONGLONG	o;
  	int	base = 10;
  	int	mult = 1;
  
***************
*** 927,933 ****
  static int
  setlimit(const char *s)
  {
! 	long long	o;
  	char	*x;
  	int	base = 10;
  
--- 948,954 ----
  static int
  setlimit(const char *s)
  {
! 	LONGLONG	o;
  	char	*x;
  	int	base = 10;
  
Common subdirectories: heirloom-060122/paste and heirloom-060122-patched/paste
Only in heirloom-060122-patched/paste: Makefile
Common subdirectories: heirloom-060122/pathchk and heirloom-060122-patched/pathchk
Only in heirloom-060122-patched/pathchk: Makefile
Common subdirectories: heirloom-060122/pg and heirloom-060122-patched/pg
Only in heirloom-060122-patched/pg: Makefile
diff -c heirloom-060122/pg/pg.c heirloom-060122-patched/pg/pg.c
*** heirloom-060122/pg/pg.c Sun Aug 14 15:15:20 2005
--- heirloom-060122-patched/pg/pg.c Wed Oct 18 20:55:37 2006
***************
*** 67,73 ****
  #include "sigset.h"
  #include <setjmp.h>
  #include <locale.h>
! #include <nl_types.h>
  #include <libgen.h>
  #include <alloca.h>
  #ifndef	USE_TERMCAP
--- 67,75 ----
  #include "sigset.h"
  #include <setjmp.h>
  #include <locale.h>
! #ifndef _MINIX
! #include <nl_types.h>
! #endif
  #include <libgen.h>
  #include <alloca.h>
  #ifndef	USE_TERMCAP
***************
*** 79,84 ****
--- 81,100 ----
  #include <termcap.h>
  #endif	/* USE_TERMCAP */
  
+ #ifdef _MINIX
+ #define LONGLONG long
+ #define P_LLD "%ld"
+ #define fseeko fseek
+ #define ftello ftell
+ #else
+ #define LONGLONG long long
+ #define P_LLD "%lld"
+ #endif
+ 
+ #ifndef LINE_MAX
+ #define LINE_MAX 2048   /* POSIX 2 LINE_MAX */
+ #endif
+ 
  #define	ENABLE_WIDECHAR			/* for util-linux */
  #define	catopen(a, b)			0
  #define	catgets(a, b, c, d)		d
***************
*** 792,798 ****
   * '%c' by themselves.
   */
  static void
! printprompt(long long pageno)
  {
  	char	*p, *q;
  	int	n, pd;
--- 808,814 ----
   * '%c' by themselves.
   */
  static void
! printprompt(LONGLONG pageno)
  {
  	char	*p, *q;
  	int	n, pd;
***************
*** 807,813 ****
  			if (p[1] == 'd' && pd++ == 0) {
  				q += snprintf(q,
  					&promptbuf[sizeof promptbuf] - q,
! 					"%lld", pageno);
  				p += 2;
  			} else if (p[1] == '%') {
  				p++;
--- 823,829 ----
  			if (p[1] == 'd' && pd++ == 0) {
  				q += snprintf(q,
  					&promptbuf[sizeof promptbuf] - q,
! 					P_LLD, pageno);
  				p += 2;
  			} else if (p[1] == '%') {
  				p++;
***************
*** 829,835 ****
   * we check for valid input.
   */
  static void
! prompt(long long pageno)
  {
  	struct termios tio;
  	char key;
--- 845,851 ----
   * we check for valid input.
   */
  static void
! prompt(LONGLONG pageno)
  {
  	struct termios tio;
  	char key;
***************
*** 2253,2261 ****
--- 2269,2279 ----
  	if (sizeof LINE == 4) {
  		LINE = 020000000000UL;
  		MASK = 017777777777UL;
+ #ifndef _MINIX
  	} else if (sizeof LINE == 8) {
  		LINE = 01000000000000000000000ULL;
  		MASK = 0777777777777777777777ULL;
+ #endif
  	} else
  		abort();	/* need to fill in values for your off_t here */
  	progname = basename(argv[0]);
Common subdirectories: heirloom-060122/pgrep and heirloom-060122-patched/pgrep
Only in heirloom-060122-patched/pgrep: Makefile
diff -c heirloom-060122/pgrep/pgrep.c heirloom-060122-patched/pgrep/pgrep.c
*** heirloom-060122/pgrep/pgrep.c Sun Jan 22 18:50:51 2006
--- heirloom-060122-patched/pgrep/pgrep.c Thu Oct 19 16:12:19 2006
***************
*** 1,4 ****
--- 1,8 ----
  /*
+  * Minix collectprocs implementation, Copyright (c) 2006, Ivo van Poorten
+  * License as below
+  */
+ /*
   * pgrep, pkill - find or signal processes by name and other attributes
   *
   * Gunnar Ritter, Freiburg i. Br., Germany, March 2003.
***************
*** 54,60 ****
  #include	<regex.h>
  
  #if !defined (__linux__) && !defined (__NetBSD__) && !defined (__OpenBSD__) \
! 	&& !defined (__APPLE__)
  #if defined (__hpux)
  #include	<sys/param.h>
  #include	<sys/pstat.h>
--- 58,64 ----
  #include	<regex.h>
  
  #if !defined (__linux__) && !defined (__NetBSD__) && !defined (__OpenBSD__) \
! 	&& !defined (__APPLE__) && !defined (_MINIX)
  #if defined (__hpux)
  #include	<sys/param.h>
  #include	<sys/pstat.h>
***************
*** 112,119 ****
  	unsigned long	v_ulong;
  };
  
! struct	proc {
! 	struct proc	*p_nxt;		/* next proc structure */
  	pid_t		p_pid;		/* process id */
  	char		p_fname[19];	/* executable name */
  	pid_t		p_ppid;		/* parent process id */
--- 116,123 ----
  	unsigned long	v_ulong;
  };
  
! struct	OURproc {
! 	struct OURproc	*p_nxt;		/* next proc structure */
  	pid_t		p_pid;		/* process id */
  	char		p_fname[19];	/* executable name */
  	pid_t		p_ppid;		/* parent process id */
***************
*** 166,172 ****
  static int		signo = SIGTERM;	/* signal to send */
  static int		need_euid_egid;	/* need euid or egid */
  static struct attlist	*attributes;	/* required attributes */
! static struct proc	*processes;	/* collected processes */
  static regex_t		*expression;	/* regular expression to match */
  static const char	*delimiter;	/* delimiter string */
  static int		prdelim;	/* print a delimiter (not first proc) */
--- 170,176 ----
  static int		signo = SIGTERM;	/* signal to send */
  static int		need_euid_egid;	/* need euid or egid */
  static struct attlist	*attributes;	/* required attributes */
! static struct OURproc	*processes;	/* collected processes */
  static regex_t		*expression;	/* regular expression to match */
  static const char	*delimiter;	/* delimiter string */
  static int		prdelim;	/* print a delimiter (not first proc) */
***************
*** 204,210 ****
  }
  
  #if !defined (__hpux) && !defined (_AIX) && !defined (__NetBSD__) \
! 	&& !defined (__OpenBSD__) && !defined (__APPLE__)
  static void
  chdir_to_proc(void)
  {
--- 208,214 ----
  }
  
  #if !defined (__hpux) && !defined (_AIX) && !defined (__NetBSD__) \
! 	&& !defined (__OpenBSD__) && !defined (__APPLE__) && !defined(_MINIX)
  static void
  chdir_to_proc(void)
  {
***************
*** 315,321 ****
  }
  
  #if !defined (__hpux) && !defined (_AIX) && !defined (__NetBSD__) && \
! 	!defined (__OpenBSD__) && !defined (__APPLE__)
  
  #if defined (__linux__) || defined (__FreeBSD__) || defined (__DragonFly__)
  
--- 319,325 ----
  }
  
  #if !defined (__hpux) && !defined (_AIX) && !defined (__NetBSD__) && \
! 	!defined (__OpenBSD__) && !defined (__APPLE__) && !defined(_MINIX)
  
  #if defined (__linux__) || defined (__FreeBSD__) || defined (__DragonFly__)
  
***************
*** 333,339 ****
  
  #if defined (__linux__)
  static enum okay
! getproc_stat(struct proc *p, pid_t expected_pid)
  {
  	static char	*buf;
  	static size_t	buflen;
--- 337,343 ----
  
  #if defined (__linux__)
  static enum okay
! getproc_stat(struct OURproc *p, pid_t expected_pid)
  {
  	static char	*buf;
  	static size_t	buflen;
***************
*** 424,430 ****
  }
  
  static enum okay
! getproc_cmdline(struct proc *p)
  {
  	FILE	*fp;
  	char	*cp, *ce;
--- 428,434 ----
  }
  
  static enum okay
! getproc_cmdline(struct OURproc *p)
  {
  	FILE	*fp;
  	char	*cp, *ce;
***************
*** 455,461 ****
  }
  
  static enum okay
! getproc_status(struct proc *p)
  {
  	char	line[LINE_MAX];
  	union value	*v;
--- 459,465 ----
  }
  
  static enum okay
! getproc_status(struct OURproc *p)
  {
  	char	line[LINE_MAX];
  	union value	*v;
***************
*** 505,514 ****
  	return OKAY;
  }
  
! static struct proc *
! getproc(const char *dir, pid_t expected_pid)
! {
! 	struct proc	*p;
  	enum okay	result;
  
  	p = scalloc(1, sizeof *p);
--- 509,518 ----
  	return OKAY;
  }
  
! static struct OURproc *
! getproc(const char *dir, pid_t expected_pid)
! {
! 	struct OURproc	*p;
  	enum okay	result;
  
  	p = scalloc(1, sizeof *p);
***************
*** 529,535 ****
  #elif defined (__FreeBSD__) || defined (__DragonFly__)
  
  static enum okay
! getproc_status(struct proc *p, pid_t expected_pid)
  {
  	static char	*buf;
  	static size_t	buflen;
--- 533,539 ----
  #elif defined (__FreeBSD__) || defined (__DragonFly__)
  
  static enum okay
! getproc_status(struct OURproc *p, pid_t expected_pid)
  {
  	static char	*buf;
  	static size_t	buflen;
***************
*** 609,615 ****
  }
  
  static enum okay
! getproc_cmdline(struct proc *p)
  {
  	FILE	*fp;
  	char	*cp, *ce;
--- 613,619 ----
  }
  
  static enum okay
! getproc_cmdline(struct OURproc *p)
  {
  	FILE	*fp;
  	char	*cp, *ce;
***************
*** 639,648 ****
  	return OKAY;
  }
  
! static struct proc *
! getproc(const char *dir, pid_t expected_pid)
! {
! 	struct proc	*p;
  	enum okay	result;
  
  	p = scalloc(1, sizeof *p);
--- 643,652 ----
  	return OKAY;
  }
  
! static struct OURproc *
! getproc(const char *dir, pid_t expected_pid)
! {
! 	struct OURproc	*p;
  	enum okay	result;
  
  	p = scalloc(1, sizeof *p);
***************
*** 683,689 ****
  }
  
  static enum okay
! getproc_psinfo(const char *dir, struct proc *p, pid_t expected_pid)
  {
  	FILE	*fp;
  	struct psinfo	pi;
--- 687,693 ----
  }
  
  static enum okay
! getproc_psinfo(const char *dir, struct OURproc *p, pid_t expected_pid)
  {
  	FILE	*fp;
  	struct psinfo	pi;
***************
*** 718,724 ****
  
  #ifndef	__sun
  static enum okay
! getproc_cred(const char *dir, struct proc *p)
  {
  	FILE	*fp;
  	struct prcred	pc;
--- 722,728 ----
  
  #ifndef	__sun
  static enum okay
! getproc_cred(const char *dir, struct OURproc *p)
  {
  	FILE	*fp;
  	struct prcred	pc;
***************
*** 736,745 ****
  }
  #endif	/* !__sun */
  
! static struct proc *
! getproc(const char *dir, pid_t expected_pid)
! {
! 	struct proc	*p;
  	enum okay	result;
  
  	p = scalloc(1, sizeof *p);
--- 740,749 ----
  }
  #endif	/* !__sun */
  
! static struct OURproc *
! getproc(const char *dir, pid_t expected_pid)
! {
! 	struct OURproc	*p;
  	enum okay	result;
  
  	p = scalloc(1, sizeof *p);
***************
*** 759,765 ****
  static void
  collectprocs(void)
  {
! 	struct proc	*p, *pq = NULL;
  	DIR	*Dp;
  	struct dirent	*dp;
  	unsigned long	val;
--- 763,769 ----
  static void
  collectprocs(void)
  {
! 	struct OURproc	*p, *pq = NULL;
  	DIR	*Dp;
  	struct dirent	*dp;
  	unsigned long	val;
***************
*** 791,797 ****
  collectprocs(void)
  {
  #define	burst	((size_t)10)
! 	struct proc	*p, *pq = NULL;
  	struct pst_status	pst[burst];
  	int	i, count;
  	int	idx = 0;
--- 795,801 ----
  collectprocs(void)
  {
  #define	burst	((size_t)10)
! 	struct OURproc	*p, *pq = NULL;
  	struct pst_status	pst[burst];
  	int	i, count;
  	int	idx = 0;
***************
*** 831,837 ****
  }
  #elif defined (_AIX)
  static void
! oneproc(struct proc *p, struct procentry64 *pi)
  {
  	char	args[100], *ap, *cp;
  
--- 835,841 ----
  }
  #elif defined (_AIX)
  static void
! oneproc(struct OURproc *p, struct procentry64 *pi)
  {
  	char	args[100], *ap, *cp;
  
***************
*** 868,874 ****
  collectprocs(void)
  {
  #define	burst	((size_t)10)
! 	struct proc	*p, *pq = NULL;
  	struct procentry64	pi[burst];
  	pid_t	idx = 0;
  	int	i, count;
--- 872,878 ----
  collectprocs(void)
  {
  #define	burst	((size_t)10)
! 	struct OURproc	*p, *pq = NULL;
  	struct procentry64	pi[burst];
  	pid_t	idx = 0;
  	int	i, count;
***************
*** 890,896 ****
  #elif defined (__OpenBSD__)
  #include <uvm/uvm_extern.h>
  static void
! oneproc(struct proc *p, struct kinfo_proc *kp)
  {
  	p->p_pid = kp->kp_proc.p_pid;
  	strncpy(p->p_fname, kp->kp_proc.p_comm, sizeof p->p_fname);
--- 894,900 ----
  #elif defined (__OpenBSD__)
  #include <uvm/uvm_extern.h>
  static void
! oneproc(struct OURproc *p, struct kinfo_proc *kp)
  {
  	p->p_pid = kp->kp_proc.p_pid;
  	strncpy(p->p_fname, kp->kp_proc.p_comm, sizeof p->p_fname);
***************
*** 909,915 ****
  		kp->kp_eproc.e_vm.vm_ssize;
  }
  static void
! argproc(struct proc *p, struct kinfo_proc *kp, kvm_t *kt)
  {
  	char	**args;
  	char	*ap, *pp;
--- 913,919 ----
  		kp->kp_eproc.e_vm.vm_ssize;
  }
  static void
! argproc(struct OURproc *p, struct kinfo_proc *kp, kvm_t *kt)
  {
  	char	**args;
  	char	*ap, *pp;
***************
*** 931,937 ****
  static void
  collectprocs(void)
  {
! 	struct proc	*p, *pq = NULL;
  	kvm_t	*kt;
  	struct	kinfo_proc *kp;
  	int	i, cnt;
--- 935,941 ----
  static void
  collectprocs(void)
  {
! 	struct OURproc	*p, *pq = NULL;
  	kvm_t	*kt;
  	struct	kinfo_proc *kp;
  	int	i, cnt;
***************
*** 953,959 ****
  }
  #elif defined (__NetBSD__)
  static void
! oneproc(struct proc *p, struct kinfo_proc2 *kp)
  {
  	p->p_pid = kp->p_pid;
  	strncpy(p->p_fname, kp->p_comm, sizeof p->p_fname);
--- 957,963 ----
  }
  #elif defined (__NetBSD__)
  static void
! oneproc(struct OURproc *p, struct kinfo_proc2 *kp)
  {
  	p->p_pid = kp->p_pid;
  	strncpy(p->p_fname, kp->p_comm, sizeof p->p_fname);
***************
*** 971,977 ****
  }
  
  static void
! argproc(struct proc *p, struct kinfo_proc2 *kp, kvm_t *kt)
  {
  	char	**args;
  	char	*ap, *pp;
--- 975,981 ----
  }
  
  static void
! argproc(struct OURproc *p, struct kinfo_proc2 *kp, kvm_t *kt)
  {
  	char	**args;
  	char	*ap, *pp;
***************
*** 993,999 ****
  static void
  collectprocs(void)
  {
! 	struct proc	*p, *pq = NULL;
  	kvm_t	*kt;
  	struct	kinfo_proc2 *kp;
  	int	i, cnt;
--- 997,1003 ----
  static void
  collectprocs(void)
  {
! 	struct OURproc	*p, *pq = NULL;
  	kvm_t	*kt;
  	struct	kinfo_proc2 *kp;
  	int	i, cnt;
***************
*** 1074,1080 ****
  extern	kern_return_t task_for_pid(task_port_t task, pid_t pid, task_port_t *target);
  
  static void
! oneproc(struct proc *p, struct kinfo_proc *kp)
  {
  	task_port_t	task;
  	kern_return_t   error;
--- 1078,1084 ----
  extern	kern_return_t task_for_pid(task_port_t task, pid_t pid, task_port_t *target);
  
  static void
! oneproc(struct OURproc *p, struct kinfo_proc *kp)
  {
  	task_port_t	task;
  	kern_return_t   error;
***************
*** 1115,1121 ****
  }
  
  static void
! argproc(struct proc *p, struct kinfo_proc *kp)
  {
  	size_t	size, argsz;
  	char	*argbuf;
--- 1119,1125 ----
  }
  
  static void
! argproc(struct OURproc *p, struct kinfo_proc *kp)
  {
  	size_t	size, argsz;
  	char	*argbuf;
***************
*** 1202,1211 ****
  	/* free the memory allocated by GetBSDProcessList */
  	free(kp);	
  }
  #endif	/* all */
  
  static enum okay
! hasattr(struct proc *p, struct attrib *a)
  {
  	long	val = 0;
  
--- 1206,1296 ----
  	/* free the memory allocated by GetBSDProcessList */
  	free(kp);	
  }
+ #elif defined(_MINIX)
+ 
+ #include <limits.h>
+ #include <timers.h>
+ #include <minix/config.h>
+ #include <minix/type.h>
+ #include <minix/const.h>
+ #include <minix/ipc.h>
+ /* You need to have the kernel and servers sources installed to compile this */
+ #include "/usr/src/servers/pm/mproc.h"
+ #include "/usr/src/servers/fs/fproc.h"
+ #include "/usr/src/kernel/const.h"
+ #include "/usr/src/kernel/proc.h"
+ 
+ #define PROCS (NR_TASKS + NR_PROCS)
+ 
+ static void oneproc(struct OURproc *p, struct proc kp[], struct mproc mp[],
+                     struct fproc fp[], int i) {
+     int p_nr = kp[i].p_nr;
+ 
+     p->p_size = ( ( kp[i].p_memmap[T].mem_len +
+                     kp[i].p_memmap[S].mem_phys - kp[i].p_memmap[D].mem_phys +
+                     kp[i].p_memmap[S].mem_len ) << CLICK_SHIFT ) / 1024;
+ 
+     if (p_nr < 0 ) {  /* special case for tasks */
+         p->p_pid = p_nr;
+         snprintf(p->p_fname, sizeof(p->p_fname), "%s", kp[i].p_name);
+ 	    p->p_ppid = p->p_pgid = p->p_sid = p->p_ttydev = p->p_uid =
+         p->p_euid = p->p_gid = p->p_egid = p->p_start = p->p_size = 0;
+         p->p_psargs[0] = '\0';
+         return;
+     }
+ 
+     p->p_pid = mp[p_nr].mp_pid;
+     snprintf(p->p_fname, sizeof(p->p_fname), "%s", mp[p_nr].mp_name);
+     p->p_ppid = mp[mp[p_nr].mp_parent].mp_pid;
+     p->p_pgid = mp[p_nr].mp_procgrp;
+     p->p_sid = 0; /* non-existent */
+     p->p_ttydev = minor(fp[p_nr].fp_tty);
+     p->p_psargs[0] = '\0'; /* need setgid kmem for that which is undesirable */
+     p->p_uid = mp[p_nr].mp_realuid;
+     p->p_euid = mp[p_nr].mp_effuid;
+     p->p_gid = mp[p_nr].mp_realgid;
+     p->p_egid = mp[p_nr].mp_effgid;
+     p->p_start = 0; /* non-existent */
+     p->p_nxt = NULL;
+ }
+ 
+ static void collectprocs(void) {
+     struct OURproc *p, *pq = NULL;
+     struct proc proc[PROCS];
+     struct mproc mproc[PROCS];
+     struct fproc fproc[PROCS];
+ 	size_t i;
+ 	int	err;
+ 
+ 	if (getsysinfo(PM_PROC_NR, SI_KPROC_TAB, proc) < 0) {
+ 		fprintf(stderr, "error getting kproc tab\n");
+ 		exit(3);
+ 	}
+ 	if (getsysinfo(PM_PROC_NR, SI_PROC_TAB, mproc) < 0) {
+ 		fprintf(stderr, "error getting mproc tab\n");
+ 		exit(3);
+ 	}
+ 	if (getsysinfo(FS_PROC_NR, SI_PROC_TAB, fproc) < 0) {
+ 		fprintf(stderr, "error getting fproc tab\n");
+ 		exit(3);
+ 	}
+ 	for (i = 0; i < PROCS; i++) {
+         if (proc[i].p_rts_flags & SLOT_FREE)    continue;
+ 
+ 		p = smalloc(sizeof *p);
+ 		if (pq)
+ 			pq->p_nxt = p;
+ 		else
+ 			processes = p;
+ 		pq = p;
+ 		oneproc(p, proc, mproc, fproc, i);
+ 	}
+ }
+ 
  #endif	/* all */
  
  static enum okay
! hasattr(struct OURproc *p, struct attrib *a)
  {
  	long	val = 0;
  
***************
*** 1243,1249 ****
  }
  
  static void
! tryproc(struct proc *p)
  {
  	struct attlist	*alp;
  	struct attrib	*ap;
--- 1328,1334 ----
  }
  
  static void
! tryproc(struct OURproc *p)
  {
  	struct attlist	*alp;
  	struct attrib	*ap;
***************
*** 1271,1284 ****
  static void
  selectprocs(void)
  {
! 	struct proc	*p;
  
  	for (p = processes; p; p = p->p_nxt)
  		tryproc(p);
  }
  
  static void
! outproc(struct proc *p)
  {
  	if (pkill) {
  		if (kill(p->p_pid, signo) < 0)
--- 1356,1369 ----
  static void
  selectprocs(void)
  {
! 	struct OURproc	*p;
  
  	for (p = processes; p; p = p->p_nxt)
  		tryproc(p);
  }
  
  static void
! outproc(struct OURproc *p)
  {
  	if (pkill) {
  		if (kill(p->p_pid, signo) < 0)
***************
*** 1301,1307 ****
  static void
  handleprocs(void)
  {
! 	struct proc	*p, *selected = NULL;
  
  	for (p = processes; p; p = p->p_nxt) {
  		if (p->p_pid != mypid && p->p_match ^ vflag) {
--- 1386,1392 ----
  static void
  handleprocs(void)
  {
! 	struct OURproc	*p, *selected = NULL;
  
  	for (p = processes; p; p = p->p_nxt) {
  		if (p->p_pid != mypid && p->p_match ^ vflag) {
***************
*** 1373,1382 ****
  		}
  		if (val == 0) switch (at) {
  		case ATT_PGRP:
! 			val = getpgid(0);
! 			break;
! 		case ATT_SID:
! 			val = getsid(0);
  			break;
  		}
  		break;
--- 1458,1475 ----
  		}
  		if (val == 0) switch (at) {
  		case ATT_PGRP:
! #ifdef _MINIX
! 			val = getpgrp();
! #else
! 			val = getpgid(0);
! #endif
! 			break;
! 		case ATT_SID:
! #ifdef _MINIX
! 			val = getpgrp();
! #else
! 			val = getsid(0);
! #endif
  			break;
  		}
  		break;
***************
*** 1578,1584 ****
  	}
  	mypid = getpid();
  #if !defined (__hpux) && !defined (_AIX) && !defined (__NetBSD__) && \
! 		!defined (__OpenBSD__) && !defined (__APPLE__)
  	chdir_to_proc();
  #endif	/* !__hpux, !_AIX, !__NetBSD__, !__OpenBSD__, !__APPLE__ */
  	collectprocs();
--- 1671,1677 ----
  	}
  	mypid = getpid();
  #if !defined (__hpux) && !defined (_AIX) && !defined (__NetBSD__) && \
! 		!defined (__OpenBSD__) && !defined (__APPLE__) && !defined(_MINIX)
  	chdir_to_proc();
  #endif	/* !__hpux, !_AIX, !__NetBSD__, !__OpenBSD__, !__APPLE__ */
  	collectprocs();
Common subdirectories: heirloom-060122/pr and heirloom-060122-patched/pr
Only in heirloom-060122-patched/pr: Makefile
diff -c heirloom-060122/pr/pr.c heirloom-060122-patched/pr/pr.c
*** heirloom-060122/pr/pr.c Sun May 29 12:55:43 2005
--- heirloom-060122-patched/pr/pr.c Thu Oct 19 01:16:43 2006
***************
*** 85,90 ****
--- 85,99 ----
  #include <iblok.h>
  #include <mbtowi.h>
  
+ #ifdef _MINIX
+ #define LONGLONG long
+ #define NP_LLD "ld"
+ #define atoll atol
+ #else
+ #define LONGLONG long long
+ #define NP_LLD "lld"
+ #endif
+ 
  #define	next(wc, s, n)	(mb_cur_max > 1 && *(s) & 0200 ? \
  		((n) = mbtowi(&(wc), (s), mb_cur_max), \
  		 (n) = ((n) > 0 ? (n) : (n) < 0 ? (wc=WEOF, 1) : 1)) :\
***************
*** 115,122 ****
  static struct iblok	*ifile[10];
  static const char	**lastarg;
  static wint_t	*peekc, *peek2c;
! static long long	fpage;
! static long long	page;
  static int	colw;
  static int	nspace;
  static int	width	= 72;
--- 124,131 ----
  static struct iblok	*ifile[10];
  static const char	**lastarg;
  static wint_t	*peekc, *peek2c;
! static LONGLONG	fpage;
! static LONGLONG	page;
  static int	colw;
  static int	nspace;
  static int	width	= 72;
***************
*** 157,163 ****
  static void	put(wint_t);
  static void	putcp(wint_t);
  static void	putcs(const char *);
! static int	putnum(long long);
  static int	cnumwidth(void);
  static void	delaym(const char *, const char *);
  static void	printm(void);
--- 166,172 ----
  static void	put(wint_t);
  static void	putcp(wint_t);
  static void	putcs(const char *);
! static int	putnum(LONGLONG);
  static int	cnumwidth(void);
  static void	delaym(const char *, const char *);
  static void	printm(void);
***************
*** 522,529 ****
  	}
  	if (header == 0)
  		header = fp?fp:"";
! 	strftime(cbuf, sizeof cbuf, "%b %e %H:%M %Y",
! 			localtime(&sbuf.st_mtime));
  	page = 1;
  	for (i = 0; i<NCOL; i++)
  		scol[i] = icol[i] = 0;
--- 531,543 ----
  	}
  	if (header == 0)
  		header = fp?fp:"";
! #ifdef _MINIX
! 	strftime(cbuf, sizeof cbuf, "%b %d %H:%M %Y",
! 			localtime(&sbuf.st_mtime));
! #else
! 	strftime(cbuf, sizeof cbuf, "%b %e %H:%M %Y",
! 			localtime(&sbuf.st_mtime));
! #endif
  	page = 1;
  	for (i = 0; i<NCOL; i++)
  		scol[i] = icol[i] = 0;
***************
*** 548,554 ****
  			putcs("  ");
  			putcs(header);
  			snprintf(linebuf, sizeof linebuf,
! 					" Page %lld\n\n\n", page);
  			putcs(linebuf);
  		}
  		c = putpage();
--- 562,568 ----
  			putcs("  ");
  			putcs(header);
  			snprintf(linebuf, sizeof linebuf,
! 					" Page %" NP_LLD "\n\n\n", page);
  			putcs(linebuf);
  		}
  		c = putpage();
***************
*** 596,603 ****
  static wint_t
  putpage(void)
  {
! 	static long long	cnt;
! 	long long	ocnt;
  	register int lastcol, i;
  	register wint_t c = 0;
  	register wint_t *cp;
--- 610,617 ----
  static wint_t
  putpage(void)
  {
! 	static LONGLONG	cnt;
! 	LONGLONG	ocnt;
  	register int lastcol, i;
  	register wint_t c = 0;
  	register wint_t *cp;
***************
*** 967,979 ****
  }
  
  static int
! putnum(long long n)
  {
  	char	buf[40], *bp;
  	int	i;
  
  	i = col;
! 	snprintf(buf, sizeof buf, "%*lld", nflg.c_g, n);
  	for (bp = buf; *bp; bp++)
  		put(*bp);
  	put(nflg.c_c);
--- 981,993 ----
  }
  
  static int
! putnum(LONGLONG n)
  {
  	char	buf[40], *bp;
  	int	i;
  
  	i = col;
! 	snprintf(buf, sizeof buf, "%*" NP_LLD, nflg.c_g, n);
  	for (bp = buf; *bp; bp++)
  		put(*bp);
  	put(nflg.c_c);
Common subdirectories: heirloom-060122/printenv and heirloom-060122-patched/printenv
Only in heirloom-060122-patched/printenv: Makefile
Common subdirectories: heirloom-060122/printf and heirloom-060122-patched/printf
Only in heirloom-060122-patched/printf: Makefile
Common subdirectories: heirloom-060122/priocntl and heirloom-060122-patched/priocntl
Only in heirloom-060122-patched/priocntl: Makefile
Common subdirectories: heirloom-060122/ps and heirloom-060122-patched/ps
Only in heirloom-060122-patched/ps: Makefile
diff -c heirloom-060122/ps/Makefile.mk heirloom-060122-patched/ps/Makefile.mk
*** heirloom-060122/ps/Makefile.mk Sat May  1 16:58:02 2004
--- heirloom-060122-patched/ps/Makefile.mk Thu Oct 19 13:07:14 2006
***************
*** 1,28 ****
  all: ps ps_sus ps_s42 ps_ucb
  
  ps: ps.o
  	$(LD) $(LDFLAGS) ps.o $(LCOMMON) $(LWCHAR) $(LIBGEN) $(LIBS) $(LKVM) -o ps
  
  ps.o: ps.c
! 	$(CC) $(CFLAGS) $(CPPFLAGS) $(GNUFL) $(IWCHAR) $(ICOMMON) -DUSE_PS_CACHE -DDEFAULT='"$(DFLDIR)/ps"' -c ps.c
  
  ps_sus: ps_sus.o
  	$(LD) $(LDFLAGS) ps_sus.o $(LCOMMON) $(LWCHAR) $(LIBGEN) $(LIBS) $(LKVM) -o ps_sus
  
  ps_sus.o: ps.c
! 	$(CC) $(CFLAGS) $(CPPFLAGS) $(GNUFL) $(IWCHAR) $(ICOMMON) -DUSE_PS_CACHE -DDEFAULT='"$(DFLDIR)/ps"' -DSUS -c ps.c -o ps_sus.o
  
  ps_s42: ps_s42.o
  	$(LD) $(LDFLAGS) ps_s42.o $(LCOMMON) $(LWCHAR) $(LIBGEN) $(LIBS) $(LKVM) -o ps_s42
  
  ps_s42.o: ps.c
! 	$(CC) $(CFLAGS) $(CPPFLAGS) $(GNUFL) $(IWCHAR) $(ICOMMON) -DUSE_PS_CACHE -DDEFAULT='"$(DFLDIR)/ps"' -DS42 -c ps.c -o ps_s42.o
  
  ps_ucb: ps_ucb.o
  	$(LD) $(LDFLAGS) ps_ucb.o $(LCOMMON) $(LWCHAR) $(LIBGEN) $(LIBS) $(LKVM) -o ps_ucb
  
  ps_ucb.o: ps.c
! 	$(CC) $(CFLAGS) $(CPPFLAGS) $(GNUFL) $(IWCHAR) $(ICOMMON) -DUSE_PS_CACHE -DDEFAULT='"$(DFLDIR)/ps"' -DUCB -c ps.c -o ps_ucb.o
  
  install: all
  	$(UCBINST) -c -m 4755 ps $(ROOT)$(SV3BIN)/ps
--- 1,31 ----
  all: ps ps_sus ps_s42 ps_ucb
  
+ #USE_PS_CACHE_DEF=-DUSE_PS_CACHE
+ USE_PS_CACHE_DEF=
+ 
  ps: ps.o
  	$(LD) $(LDFLAGS) ps.o $(LCOMMON) $(LWCHAR) $(LIBGEN) $(LIBS) $(LKVM) -o ps
  
  ps.o: ps.c
! 	$(CC) $(CFLAGS) $(CPPFLAGS) $(GNUFL) $(IWCHAR) $(ICOMMON) $(USE_PS_CACHE_DEF) -DPSCDEFAULT='"$(DFLDIR)/ps"' -c ps.c
  
  ps_sus: ps_sus.o
  	$(LD) $(LDFLAGS) ps_sus.o $(LCOMMON) $(LWCHAR) $(LIBGEN) $(LIBS) $(LKVM) -o ps_sus
  
  ps_sus.o: ps.c
! 	$(CC) $(CFLAGS) $(CPPFLAGS) $(GNUFL) $(IWCHAR) $(ICOMMON) $(USE_PS_CACHE_DEF) -DPSCDEFAULT='"$(DFLDIR)/ps"' -DSUS -c ps.c -o ps_sus.o
  
  ps_s42: ps_s42.o
  	$(LD) $(LDFLAGS) ps_s42.o $(LCOMMON) $(LWCHAR) $(LIBGEN) $(LIBS) $(LKVM) -o ps_s42
  
  ps_s42.o: ps.c
! 	$(CC) $(CFLAGS) $(CPPFLAGS) $(GNUFL) $(IWCHAR) $(ICOMMON) $(USE_PS_CACHE_DEF) -DPSCDEFAULT='"$(DFLDIR)/ps"' -DS42 -c ps.c -o ps_s42.o
  
  ps_ucb: ps_ucb.o
  	$(LD) $(LDFLAGS) ps_ucb.o $(LCOMMON) $(LWCHAR) $(LIBGEN) $(LIBS) $(LKVM) -o ps_ucb
  
  ps_ucb.o: ps.c
! 	$(CC) $(CFLAGS) $(CPPFLAGS) $(GNUFL) $(IWCHAR) $(ICOMMON) $(USE_PS_CACHE_DEF) -DPSCDEFAULT='"$(DFLDIR)/ps"' -DUCB -c ps.c -o ps_ucb.o
  
  install: all
  	$(UCBINST) -c -m 4755 ps $(ROOT)$(SV3BIN)/ps
diff -c heirloom-060122/ps/ps.c heirloom-060122-patched/ps/ps.c
*** heirloom-060122/ps/ps.c Sun Jan 22 18:54:07 2006
--- heirloom-060122-patched/ps/ps.c Fri Oct 20 00:51:55 2006
***************
*** 45,51 ****
  static const char cacheid[] = "@(#)/tmp/ps_cache	2.110 (gritter) 1/22/06";
  
  #if !defined (__linux__) && !defined (__sun) && !defined (__FreeBSD__) \
! 	&& !defined (__DragonFly__)
  #define	_KMEMUSER
  #endif	/* !__linux__, !__sun, !__FreeBSD__, !__DragonFly__ */
  #include	<sys/types.h>
--- 45,51 ----
  static const char cacheid[] = "@(#)/tmp/ps_cache	2.110 (gritter) 1/22/06";
  
  #if !defined (__linux__) && !defined (__sun) && !defined (__FreeBSD__) \
! 	&& !defined (__DragonFly__) && !defined(_MINIX)
  #define	_KMEMUSER
  #endif	/* !__linux__, !__sun, !__FreeBSD__, !__DragonFly__ */
  #include	<sys/types.h>
***************
*** 65,74 ****
  #include	<alloca.h>
  #include	<dirent.h>
  #include	<limits.h>
! #include	<sched.h>
! #include	<pwd.h>
! #include	<grp.h>
! #include	<langinfo.h>
  #include	<locale.h>
  #include	<ctype.h>
  #include	<blank.h>
--- 65,78 ----
  #include	<alloca.h>
  #include	<dirent.h>
  #include	<limits.h>
! #ifndef _MINIX
! #include	<sched.h>
! #endif
! #include	<pwd.h>
! #include	<grp.h>
! #ifndef _MINIX
! #include	<langinfo.h>
! #endif
  #include	<locale.h>
  #include	<ctype.h>
  #include	<blank.h>
***************
*** 126,134 ****
  #if !defined (P_SINTR) && defined (L_SINTR)
  #define	P_SINTR	L_SINTR
  #endif
- #ifndef	SCHED_OTHER
- #define	SCHED_OTHER	1
- #endif
  #elif defined (__APPLE__)
  #include	<sys/proc.h>
  #include        <sys/sysctl.h>
--- 130,135 ----
***************
*** 139,144 ****
--- 140,165 ----
  #include	<mach/shared_memory_server.h>
  #define	proc	process
  #undef	p_pgid
+ #elif defined (_MINIX)
+ #include "../cal/fake_langinfo.h"
+ #include "dirname.h"
+ #include <limits.h>
+ #include <timers.h>
+ #include <signal.h>
+ #include <minix/config.h>
+ #include <minix/type.h>
+ #include <minix/const.h>
+ #include <minix/ipc.h>
+ #include <minix/endpoint.h>
+ #include <minix/sysutil.h>
+ #include <sys/vm.h>
+ #define KB_PER_PAGE (PAGE_SIZE / 1024)
+ /* You need to have the kernel and servers sources installed to compile this */
+ #include "/usr/src/servers/pm/mproc.h"
+ #include "/usr/src/servers/fs/fproc.h"
+ #include "/usr/src/kernel/const.h"
+ #include "/usr/src/kernel/proc.h"
+ #define PROCS (NR_TASKS + NR_PROCS)
  #else	/* SVR4 */
  #include	<sys/mnttab.h>
  #ifdef	__sun
***************
*** 158,163 ****
--- 179,198 ----
  
  #include	<mbtowi.h>
  
+ #ifdef _MINIX
+ #define LONGLONG long
+ #else
+ #define LONGLONG long long
+ #endif
+ 
+ #ifndef LINE_MAX
+ #define LINE_MAX 2048   /* POSIX 2 LINE_MAX */
+ #endif
+ 
+ #ifndef	SCHED_OTHER
+ #define	SCHED_OTHER	1
+ #endif
+ 
  #ifdef	__linux__
  #ifndef	SCHED_BATCH
  #define	SCHED_BATCH	3
***************
*** 350,356 ****
  	{ OU_PGID,	"pgid",		" PGID",	0		},
  	{ OU_PCPU,	"pcpu",		"%CPU",		0		},
  	{ OU_VSZ,	"vsz",		"   VSZ",	0		},
! 	{ OU_NICE,	"nice",		"NI",		0		},
  	{ OU_ETIME,	"etime",	"    ELAPSED",	0		},
  	{ OU_TIME,	"time",		"    TIME",	0		},
  	{ OU_ACCUTIME,	"accutime",	" TIME",	0		},
--- 385,395 ----
  	{ OU_PGID,	"pgid",		" PGID",	0		},
  	{ OU_PCPU,	"pcpu",		"%CPU",		0		},
  	{ OU_VSZ,	"vsz",		"   VSZ",	0		},
! #ifdef _MINIX   /* negative nice levels can be 3 chars */
! 	{ OU_NICE,	"nice",		" NI",		0		},
! #else
! 	{ OU_NICE,	"nice",		"NI",		0		},
! #endif
  	{ OU_ETIME,	"etime",	"    ELAPSED",	0		},
  	{ OU_TIME,	"time",		"    TIME",	0		},
  	{ OU_ACCUTIME,	"accutime",	" TIME",	0		},
***************
*** 395,401 ****
  	{ OU_SPACE,	NULL,		" ",	 	0		}
  };
  
! struct	proc {
  	pid_t		p_pid;		/* process id */
  	char		p_fname[19];	/* executable name */
  	char		p_state[2];	/* process state */
--- 434,440 ----
  	{ OU_SPACE,	NULL,		" ",	 	0		}
  };
  
! struct	OURproc {
  	pid_t		p_pid;		/* process id */
  	char		p_fname[19];	/* executable name */
  	char		p_state[2];	/* process state */
***************
*** 467,473 ****
  static int		mb_cur_max;	/* MB_CUR_MAX acceleration */
  static int		ontty;		/* running on a tty */
  static char		*progname;	/* argv[0] to main() */
! static struct proc	myproc;		/* struct proc for this ps instance */
  
  static struct ditem	**d0;		/* dev_t to device name mapping */
  static struct criterion	*c0;		/* criteria list */
--- 506,512 ----
  static int		mb_cur_max;	/* MB_CUR_MAX acceleration */
  static int		ontty;		/* running on a tty */
  static char		*progname;	/* argv[0] to main() */
! static struct OURproc	myproc;		/* struct OURproc for this ps instance */
  
  static struct ditem	**d0;		/* dev_t to device name mapping */
  static struct criterion	*c0;		/* criteria list */
***************
*** 485,492 ****
  #endif	/* USE_PS_CACHE */
  static int		dropprivs;
  
! static void		postproc(struct proc *);
! static enum okay	selectproc(struct proc *);
  
  /************************************************************************
   * 			Utility functions				*
--- 524,531 ----
  #endif	/* USE_PS_CACHE */
  static int		dropprivs;
  
! static void		postproc(struct OURproc *);
! static enum okay	selectproc(struct OURproc *);
  
  /************************************************************************
   * 			Utility functions				*
***************
*** 558,564 ****
  static struct trenod *
  treget(unsigned long num, struct trenod **troot)
  {
! 	long long	c;
  	struct trenod	*tp = *troot;
  
  	while (tp != NULL) {
--- 597,603 ----
  static struct trenod *
  treget(unsigned long num, struct trenod **troot)
  {
! 	LONGLONG	c;
  	struct trenod	*tp = *troot;
  
  	while (tp != NULL) {
***************
*** 576,582 ****
  treput(struct trenod *tk, struct trenod **troot)
  {
  	if (*troot) {
! 		long long	c;
  		struct trenod	*tp = *troot, *tq = NULL;
  
  		while (tp != NULL) {
--- 615,621 ----
  treput(struct trenod *tk, struct trenod **troot)
  {
  	if (*troot) {
! 		LONGLONG	c;
  		struct trenod	*tp = *troot, *tq = NULL;
  
  		while (tp != NULL) {
***************
*** 623,629 ****
  }
  
  #if !defined (__hpux) && !defined (_AIX) && !defined (__NetBSD__) && \
! 	!defined (__OpenBSD__) && !defined (__APPLE__)
  static void
  chdir_to_proc(void)
  {
--- 662,668 ----
  }
  
  #if !defined (__hpux) && !defined (_AIX) && !defined (__NetBSD__) && \
! 	!defined (__OpenBSD__) && !defined (__APPLE__) && !defined (_MINIX)
  static void
  chdir_to_proc(void)
  {
***************
*** 758,764 ****
  }
  
  static void
! cleanline(struct proc *p)
  {
  	/*
  	 * If the argument list contains a nonprintable character,
--- 797,803 ----
  }
  
  static void
! cleanline(struct OURproc *p)
  {
  	/*
  	 * If the argument list contains a nonprintable character,
***************
*** 1008,1018 ****
  	return width;
  }
  
! #define	ZOMBIE(a)	(p->p_lstate[0] != 'Z' ? (a) : \
  				printf("%-*s", o->o_len, oflag ? "-" : " "))
  
  static void
! outproc(struct proc *p)
  {
  	struct output	*o;
  	int	width = 0;
--- 1047,1057 ----
  	return width;
  }
  
! #define	OURZOMBIE(a)	(p->p_lstate[0] != 'Z' ? (a) : \
  				printf("%-*s", o->o_len, oflag ? "-" : " "))
  
  static void
! outproc(struct OURproc *p)
  {
  	struct output	*o;
  	int	width = 0;
***************
*** 1032,1038 ****
  			width += putgroup(p->p_egid, o->o_len);
  			break;
  		case OU_PID:
! 			width += printf("%*u", o->o_len, (int)p->p_pid);
  			break;
  		case OU_PPID:
  			width += printf("%*u", o->o_len, (int)p->p_ppid);
--- 1071,1081 ----
  			width += putgroup(p->p_egid, o->o_len);
  			break;
  		case OU_PID:
! #ifdef _MINIX
! 			width += printf("%*i", o->o_len, (int)p->p_pid);
! #else
! 			width += printf("%*u", o->o_len, (int)p->p_pid);
! #endif
  			break;
  		case OU_PPID:
  			width += printf("%*u", o->o_len, (int)p->p_ppid);
***************
*** 1042,1081 ****
  			break;
  		case OU_LWP:
  		case OU_STID:
! 			width += ZOMBIE(printf("%*u", o->o_len, (int)p->p_lwp));
  			break;
  		case OU_PCPU:
  			width += printf("%*.1f", o->o_len, p->p_pctcpu);
  			break;
  		case OU_VSZ:
! 			width += ZOMBIE(printf("%*lu", o->o_len,
  						(long)p->p_size));
  			break;
  		case OU_NICE:
  			if (p->p_policy == SCHED_OTHER && p->p_pid != 0) {
! 				width += ZOMBIE(printf("%*d", o->o_len,
! 							(int)p->p_nice));
! 			} else {
! 				width += ZOMBIE(printf("%*.*s",
  							o->o_len, o->o_len,
  							p->p_clname));
  			}
  			break;
  		case OU_NLWP:
! 			width += ZOMBIE(printf("%*u", o->o_len, p->p_nlwp));
! 			break;
! 		case OU_NTP:
! 			width += ZOMBIE(printf("%*u", o->o_len,
  					p->p_nlwp > 1 ? p->p_nlwp : 0));
  			break;
  		case OU_TID:
! 			width += ZOMBIE(printf("%*s", o->o_len, "-"));
  			break;
  		case OU_ETIME:
  			width += time2(now - p->p_start, o->o_len, 0);
  			break;
  		case OU_TTY:
! 			width += ZOMBIE(putdev(p->p_ttydev, o->o_len));
  			break;
  		case OU_LTIME:
  		case OU_OTIME:
--- 1085,1124 ----
  			break;
  		case OU_LWP:
  		case OU_STID:
! 			width += OURZOMBIE(printf("%*u", o->o_len, (int)p->p_lwp));
  			break;
  		case OU_PCPU:
  			width += printf("%*.1f", o->o_len, p->p_pctcpu);
  			break;
  		case OU_VSZ:
! 			width += OURZOMBIE(printf("%*lu", o->o_len,
  						(long)p->p_size));
  			break;
  		case OU_NICE:
  			if (p->p_policy == SCHED_OTHER && p->p_pid != 0) {
! 				width += OURZOMBIE(printf("%*d", o->o_len,
! 							(int)p->p_nice));
! 			} else {
! 				width += OURZOMBIE(printf("%*.*s",
  							o->o_len, o->o_len,
  							p->p_clname));
  			}
  			break;
  		case OU_NLWP:
! 			width += OURZOMBIE(printf("%*u", o->o_len, p->p_nlwp));
! 			break;
! 		case OU_NTP:
! 			width += OURZOMBIE(printf("%*u", o->o_len,
  					p->p_nlwp > 1 ? p->p_nlwp : 0));
  			break;
  		case OU_TID:
! 			width += OURZOMBIE(printf("%*s", o->o_len, "-"));
  			break;
  		case OU_ETIME:
  			width += time2(now - p->p_start, o->o_len, 0);
  			break;
  		case OU_TTY:
! 			width += OURZOMBIE(putdev(p->p_ttydev, o->o_len));
  			break;
  		case OU_LTIME:
  		case OU_OTIME:
***************
*** 1129,1151 ****
  			width += printf("%*u", o->o_len, (int)p->p_sid);
  			break;
  		case OU_CLASS:
! 			width += ZOMBIE(printf("%*s", o->o_len, p->p_clname));
! 			break;
! 		case OU_PRI:
! 			width += ZOMBIE(printf("%*d", o->o_len, (int)p->p_pri));
! 			break;
! 		case OU_OPRI:
! 			width += ZOMBIE(printf("%*d", o->o_len,
  						(int)p->p_oldpri));
  			break;
  		case OU_PSR:
  			width += printf("%*d", o->o_len, (int)p->p_psr);
  			break;
  		case OU_ADDR:
! 			width += ZOMBIE(putxd(o->o_len, (long)p->p_addr));
! 			break;
! 		case OU_OSZ:
! 			width += ZOMBIE(printf("%*lu", o->o_len,
  						(long)p->p_osz));
  			break;
  		case OU_WCHAN:
--- 1172,1194 ----
  			width += printf("%*u", o->o_len, (int)p->p_sid);
  			break;
  		case OU_CLASS:
! 			width += OURZOMBIE(printf("%*s", o->o_len, p->p_clname));
! 			break;
! 		case OU_PRI:
! 			width += OURZOMBIE(printf("%*d", o->o_len, (int)p->p_pri));
! 			break;
! 		case OU_OPRI:
! 			width += OURZOMBIE(printf("%*d", o->o_len,
  						(int)p->p_oldpri));
  			break;
  		case OU_PSR:
  			width += printf("%*d", o->o_len, (int)p->p_psr);
  			break;
  		case OU_ADDR:
! 			width += OURZOMBIE(putxd(o->o_len, (long)p->p_addr));
! 			break;
! 		case OU_OSZ:
! 			width += OURZOMBIE(printf("%*lu", o->o_len,
  						(long)p->p_osz));
  			break;
  		case OU_WCHAN:
***************
*** 1156,1170 ****
  				width += printf("%*s", o->o_len, " ");
  			break;
  		case OU_STIME:
! 			width += ZOMBIE(time3(p->p_start, o->o_len));
! 			break;
! 		case OU_RSS:
! 			width += ZOMBIE(printf("%*lu", o->o_len,
  						(long)p->p_rssize));
  			break;
  		case OU_ORSS:
  		case OU_MRSZ:
! 			width += ZOMBIE(printf("%*lu", o->o_len,
  						(long)p->p_orss));
  			break;
  		case OU_PMEM:
--- 1199,1213 ----
  				width += printf("%*s", o->o_len, " ");
  			break;
  		case OU_STIME:
! 			width += OURZOMBIE(time3(p->p_start, o->o_len));
! 			break;
! 		case OU_RSS:
! 			width += OURZOMBIE(printf("%*lu", o->o_len,
  						(long)p->p_rssize));
  			break;
  		case OU_ORSS:
  		case OU_MRSZ:
! 			width += OURZOMBIE(printf("%*lu", o->o_len,
  						(long)p->p_orss));
  			break;
  		case OU_PMEM:
***************
*** 1209,1215 ****
  }
  
  #if !defined (__hpux) && !defined (_AIX) && !defined (__NetBSD__) && \
! 	!defined (__OpenBSD__) && !defined (__APPLE__)
  
  #if defined (__linux__) || defined (__FreeBSD__) || defined (__DragonFly__)
  #define	GETVAL_REQ(a)		if ((v = getval(&cp, (a), ' ', 0)) == NULL) \
--- 1252,1258 ----
  }
  
  #if !defined (__hpux) && !defined (_AIX) && !defined (__NetBSD__) && \
! 	!defined (__OpenBSD__) && !defined (__APPLE__) && !defined(_MINIX)
  
  #if defined (__linux__) || defined (__FreeBSD__) || defined (__DragonFly__)
  #define	GETVAL_REQ(a)		if ((v = getval(&cp, (a), ' ', 0)) == NULL) \
***************
*** 1292,1298 ****
  static time_t
  hz2time(long val, int mult)
  {
! 	long long	t;
  
  	t = val * mult / hz;
  	if ((val * mult) % hz >= (hz >> 1))
--- 1335,1341 ----
  static time_t
  hz2time(long val, int mult)
  {
! 	LONGLONG	t;
  
  	t = val * mult / hz;
  	if ((val * mult) % hz >= (hz >> 1))
***************
*** 1300,1306 ****
  	return t;
  }
  
! static void	(*compute_priority)(struct proc *);
  
  /*
   * Calculate reasonable values for priority fields using all we can get
--- 1343,1349 ----
  	return t;
  }
  
! static void	(*compute_priority)(struct OURproc *);
  
  /*
   * Calculate reasonable values for priority fields using all we can get
***************
*** 1308,1314 ****
   * nice value.
   */
  static void
! compute_priority_old(struct proc *p)
  {
  	static int	def_counter, scale, max_goodness;
  	int	full_counter, counter, goodness;
--- 1351,1357 ----
   * nice value.
   */
  static void
! compute_priority_old(struct OURproc *p)
  {
  	static int	def_counter, scale, max_goodness;
  	int	full_counter, counter, goodness;
***************
*** 1379,1385 ****
   * we could use to compute "CPU usage for scheduling".
   */
  static void
! compute_priority_new(struct proc *p)
  {
  	if (p->p_rtpri) {
  		p->p_pri = 100 + p->p_rtpri;
--- 1422,1428 ----
   * we could use to compute "CPU usage for scheduling".
   */
  static void
! compute_priority_new(struct OURproc *p)
  {
  	if (p->p_rtpri) {
  		p->p_pri = 100 + p->p_rtpri;
***************
*** 1391,1397 ****
  }
  
  static void
! compute_various(struct proc *p)
  {
  	/*
  	 * All dead processes are considered zombies by us.
--- 1434,1440 ----
  }
  
  static void
! compute_various(struct OURproc *p)
  {
  	/*
  	 * All dead processes are considered zombies by us.
***************
*** 1436,1442 ****
  }
  
  static enum okay
! getproc_stat(struct proc *p, pid_t expected_pid)
  {
  	static char	*buf;
  	static size_t	buflen;
--- 1479,1485 ----
  }
  
  static enum okay
! getproc_stat(struct OURproc *p, pid_t expected_pid)
  {
  	static char	*buf;
  	static size_t	buflen;
***************
*** 1614,1620 ****
  }
  
  static enum okay
! getproc_scheduler(struct proc *p)
  {
  	struct sched_param	s;
  
--- 1657,1663 ----
  }
  
  static enum okay
! getproc_scheduler(struct OURproc *p)
  {
  	struct sched_param	s;
  
***************
*** 1658,1664 ****
  }
  
  static enum okay
! getproc_cmdline(struct proc *p)
  {
  	FILE	*fp;
  	char	*cp, *cq, *ce;
--- 1701,1707 ----
  }
  
  static enum okay
! getproc_cmdline(struct OURproc *p)
  {
  	FILE	*fp;
  	char	*cp, *cq, *ce;
***************
*** 1696,1702 ****
  }
  
  static enum okay
! getproc_status(struct proc *p)
  {
  	char	line[LINE_MAX];
  	union value	*v;
--- 1739,1745 ----
  }
  
  static enum okay
! getproc_status(struct OURproc *p)
  {
  	char	line[LINE_MAX];
  	union value	*v;
***************
*** 1765,1771 ****
  }
  
  static enum okay
! getproc_statm(struct proc *p)
  {
  	char	line[LINE_MAX];
  	union value	*v;
--- 1808,1814 ----
  }
  
  static enum okay
! getproc_statm(struct OURproc *p)
  {
  	char	line[LINE_MAX];
  	union value	*v;
***************
*** 1811,1817 ****
  }
  
  static enum okay
! getproc(const char *dir, struct proc *p, pid_t expected_pid, pid_t lwp)
  {
  	enum okay	result;
  
--- 1854,1860 ----
  }
  
  static enum okay
! getproc(const char *dir, struct OURproc *p, pid_t expected_pid, pid_t lwp)
  {
  	enum okay	result;
  
***************
*** 1829,1835 ****
  }
  
  static enum okay
! getLWPs(const char *dir, struct proc *p, pid_t expected_pid)
  {
  	DIR	*Dp;
  	struct dirent	*dp;
--- 1872,1878 ----
  }
  
  static enum okay
! getLWPs(const char *dir, struct OURproc *p, pid_t expected_pid)
  {
  	DIR	*Dp;
  	struct dirent	*dp;
***************
*** 1882,1888 ****
  }
  
  static enum okay
! getproc_status(struct proc *p, pid_t expected_pid)
  {
  	static char	*buf;
  	static size_t	buflen;
--- 1925,1931 ----
  }
  
  static enum okay
! getproc_status(struct OURproc *p, pid_t expected_pid)
  {
  	static char	*buf;
  	static size_t	buflen;
***************
*** 1985,1991 ****
  }
  
  static enum okay
! getproc_cmdline(struct proc *p)
  {
  	FILE	*fp;
  	char	*cp, *ce;
--- 2028,2034 ----
  }
  
  static enum okay
! getproc_cmdline(struct OURproc *p)
  {
  	FILE	*fp;
  	char	*cp, *ce;
***************
*** 2016,2022 ****
  }
  
  static void
! priocomp(struct proc *p)
  {
  	static int	once;
  	static int	ranges[3][2];
--- 2059,2065 ----
  }
  
  static void
! priocomp(struct OURproc *p)
  {
  	static int	once;
  	static int	ranges[3][2];
***************
*** 2055,2061 ****
  }
  
  static enum okay
! getproc_map(struct proc *p)
  {
  	FILE	*fp;
  	long	start, end, resident;
--- 2098,2104 ----
  }
  
  static enum okay
! getproc_map(struct OURproc *p)
  {
  	FILE	*fp;
  	long	start, end, resident;
***************
*** 2077,2083 ****
  }
  
  static enum okay
! getproc_scheduler(struct proc *p)
  {
  	struct sched_param	s;
  
--- 2120,2126 ----
  }
  
  static enum okay
! getproc_scheduler(struct OURproc *p)
  {
  	struct sched_param	s;
  
***************
*** 2105,2111 ****
  }
  
  static enum okay
! getproc_kvm(struct proc *p)
  {
  	static kvm_t	*kv;
  	struct kinfo_proc	*kp;
--- 2148,2154 ----
  }
  
  static enum okay
! getproc_kvm(struct OURproc *p)
  {
  	static kvm_t	*kv;
  	struct kinfo_proc	*kp;
***************
*** 2190,2196 ****
  }
  
  static enum okay
! getproc(const char *dir, struct proc *p, pid_t expected_pid, pid_t lwp)
  {
  	enum okay	result;
  
--- 2233,2239 ----
  }
  
  static enum okay
! getproc(const char *dir, struct OURproc *p, pid_t expected_pid, pid_t lwp)
  {
  	enum okay	result;
  
***************
*** 2252,2258 ****
  }
  
  static enum okay
! getproc_psinfo(const char *dir, struct proc *p, pid_t expected_pid)
  {
  	FILE	*fp;
  	struct psinfo	pi;
--- 2295,2301 ----
  }
  
  static enum okay
! getproc_psinfo(const char *dir, struct OURproc *p, pid_t expected_pid)
  {
  	FILE	*fp;
  	struct psinfo	pi;
***************
*** 2332,2338 ****
  }
  
  static enum okay
! getproc_lwpsinfo(const char *dir, struct proc *p, pid_t lwp)
  {
  	static char	clname[PRCLSZ+1];
  	char	base[100];
--- 2375,2381 ----
  }
  
  static enum okay
! getproc_lwpsinfo(const char *dir, struct OURproc *p, pid_t lwp)
  {
  	static char	clname[PRCLSZ+1];
  	char	base[100];
***************
*** 2387,2393 ****
  
  #ifdef	__sun
  static enum okay
! getproc_usage(const char *dir, struct proc *p)
  {
  	FILE	*fp;
  	struct prusage	pu;
--- 2430,2436 ----
  
  #ifdef	__sun
  static enum okay
! getproc_usage(const char *dir, struct OURproc *p)
  {
  	FILE	*fp;
  	struct prusage	pu;
***************
*** 2410,2416 ****
  }
  #else	/* !__sun */
  static enum okay
! getproc_cred(const char *dir, struct proc *p)
  {
  	FILE	*fp;
  	struct prcred	pc;
--- 2453,2459 ----
  }
  #else	/* !__sun */
  static enum okay
! getproc_cred(const char *dir, struct OURproc *p)
  {
  	FILE	*fp;
  	struct prcred	pc;
***************
*** 2434,2440 ****
  #endif	/* !__sun */
  
  static enum okay
! getproc_status(const char *dir, struct proc *p)
  {
  	FILE	*fp;
  	struct pstatus	ps;
--- 2477,2483 ----
  #endif	/* !__sun */
  
  static enum okay
! getproc_status(const char *dir, struct OURproc *p)
  {
  	FILE	*fp;
  	struct pstatus	ps;
***************
*** 2457,2463 ****
  }
  
  static enum okay
! getproc_lwpstatus(const char *dir, struct proc *p, pid_t lwp)
  {
  	FILE	*fp;
  	char	base[100];
--- 2500,2506 ----
  }
  
  static enum okay
! getproc_lwpstatus(const char *dir, struct OURproc *p, pid_t lwp)
  {
  	FILE	*fp;
  	char	base[100];
***************
*** 2495,2501 ****
  }
  
  static enum okay
! getproc(const char *dir, struct proc *p, pid_t expected_pid, pid_t lwp)
  {
  	enum okay	result;
  
--- 2538,2544 ----
  }
  
  static enum okay
! getproc(const char *dir, struct OURproc *p, pid_t expected_pid, pid_t lwp)
  {
  	enum okay	result;
  
***************
*** 2516,2522 ****
  }
  
  static enum okay
! getLWPs(const char *dir, struct proc *p, pid_t expected_pid)
  {
  	DIR	*Dp;
  	struct dirent	*dp;
--- 2559,2565 ----
  }
  
  static enum okay
! getLWPs(const char *dir, struct OURproc *p, pid_t expected_pid)
  {
  	DIR	*Dp;
  	struct dirent	*dp;
***************
*** 2547,2553 ****
  #endif	/* !__linux__, !__FreeBSD__, !__DragonFly__ */
  
  static void
! postproc(struct proc *p)
  {
  	cleanline(p);
  #ifndef	__sun
--- 2590,2596 ----
  #endif	/* !__linux__, !__FreeBSD__, !__DragonFly__ */
  
  static void
! postproc(struct OURproc *p)
  {
  	cleanline(p);
  #ifndef	__sun
***************
*** 2571,2577 ****
  #endif	/* !__hpux, !_AIX, !__NetBSD__, !__OpenBSD__, !__APPLE__ */
  
  static enum okay
! selectproc(struct proc *p)
  {
  	struct criterion	*ct;
  
--- 2614,2620 ----
  #endif	/* !__hpux, !_AIX, !__NetBSD__, !__OpenBSD__, !__APPLE__ */
  
  static enum okay
! selectproc(struct OURproc *p)
  {
  	struct criterion	*ct;
  
***************
*** 2666,2676 ****
  }
  
  #if !defined (__hpux) && !defined (_AIX) && !defined (__NetBSD__) && \
! 	!defined (__OpenBSD__) && !defined (__APPLE__)
  static void
  do_procs(void)
  {
! 	struct proc	p;
  	DIR	*Dp;
  	struct dirent	*dp;
  	unsigned long	val;
--- 2709,2719 ----
  }
  
  #if !defined (__hpux) && !defined (_AIX) && !defined (__NetBSD__) && \
! 	!defined (__OpenBSD__) && !defined (__APPLE__) && !defined(_MINIX)
  static void
  do_procs(void)
  {
! 	struct OURproc	p;
  	DIR	*Dp;
  	struct dirent	*dp;
  	unsigned long	val;
***************
*** 2708,2714 ****
  }
  
  static void
! getproc(struct proc *p, struct pst_status *pst)
  {
  	char	*cp, *np;
  
--- 2751,2757 ----
  }
  
  static void
! getproc(struct OURproc *p, struct pst_status *pst)
  {
  	char	*cp, *np;
  
***************
*** 2761,2767 ****
  }
  
  static void
! getlwp(struct proc *p, struct lwp_status *lwp)
  {
  	p->p_lwp = lwp->lwp_lwpid;
  	p->p_intpri = p->p_rtpri = lwp->lwp_pri;
--- 2804,2810 ----
  }
  
  static void
! getlwp(struct OURproc *p, struct lwp_status *lwp)
  {
  	p->p_lwp = lwp->lwp_lwpid;
  	p->p_intpri = p->p_rtpri = lwp->lwp_pri;
***************
*** 2780,2786 ****
  }
  
  static void
! postproc(struct proc *p)
  {
  	cleanline(p);
  	switch (p->p_lstate[0]) {
--- 2823,2829 ----
  }
  
  static void
! postproc(struct OURproc *p)
  {
  	cleanline(p);
  	switch (p->p_lstate[0]) {
***************
*** 2850,2856 ****
  #define	burst	((size_t)10)
  
  static void
! getLWPs(struct proc *p)
  {
  	struct lwp_status	lwp[burst];
  	int	i, count;
--- 2893,2899 ----
  #define	burst	((size_t)10)
  
  static void
! getLWPs(struct OURproc *p)
  {
  	struct lwp_status	lwp[burst];
  	int	i, count;
***************
*** 2871,2877 ****
  static void
  do_procs(void)
  {
! 	struct proc	p;
  	struct pst_status	pst[burst];
  	int	i, count;
  	int	idx = 0;
--- 2914,2920 ----
  static void
  do_procs(void)
  {
! 	struct OURproc	p;
  	struct pst_status	pst[burst];
  	int	i, count;
  	int	idx = 0;
***************
*** 2906,2912 ****
  }
  
  static void
! getproc(struct proc *p, struct procentry64 *pi)
  {
  	char	args[100], *ap, *cp, *xp;
  
--- 2949,2955 ----
  }
  
  static void
! getproc(struct OURproc *p, struct procentry64 *pi)
  {
  	char	args[100], *ap, *cp, *xp;
  
***************
*** 2964,2970 ****
  }
  
  static void
! postproc(struct proc *p)
  {
  	char	*np, *cp;
  
--- 3007,3013 ----
  }
  
  static void
! postproc(struct OURproc *p)
  {
  	char	*np, *cp;
  
***************
*** 3013,3019 ****
  }
  
  static void
! getlwp(struct proc *p, struct thrdentry64 *ti)
  {
  	p->p_lwp = ti->ti_tid;
  	p->p_psr = ti->ti_cpuid;
--- 3056,3062 ----
  }
  
  static void
! getlwp(struct OURproc *p, struct thrdentry64 *ti)
  {
  	p->p_lwp = ti->ti_tid;
  	p->p_psr = ti->ti_cpuid;
***************
*** 3036,3042 ****
  #define	burst	((size_t)10)
  
  static void
! getLWPs(struct proc *p)
  {
  	struct	thrdentry64	ti[burst];
  	tid64_t	idx = 0;
--- 3079,3085 ----
  #define	burst	((size_t)10)
  
  static void
! getLWPs(struct OURproc *p)
  {
  	struct	thrdentry64	ti[burst];
  	tid64_t	idx = 0;
***************
*** 3055,3061 ****
  }
  
  static void
! oneLWP(struct proc *p)
  {
  	struct thrdentry64	ti;
  	tid64_t	idx = 0;
--- 3098,3104 ----
  }
  
  static void
! oneLWP(struct OURproc *p)
  {
  	struct thrdentry64	ti;
  	tid64_t	idx = 0;
***************
*** 3067,3073 ****
  static void
  do_procs(void)
  {
! 	struct proc	p;
  	struct procentry64	pi[burst];
  	pid_t	idx = 0;
  	int	i, count;
--- 3110,3116 ----
  static void
  do_procs(void)
  {
! 	struct OURproc	p;
  	struct procentry64	pi[burst];
  	pid_t	idx = 0;
  	int	i, count;
***************
*** 3106,3112 ****
  }
  
  static void
! getproc(struct proc *p, struct kinfo_proc *kp)
  {
  	memset(p, 0, sizeof *p);
  	p->p_pid = kp->kp_proc.p_pid;
--- 3149,3155 ----
  }
  
  static void
! getproc(struct OURproc *p, struct kinfo_proc *kp)
  {
  	memset(p, 0, sizeof *p);
  	p->p_pid = kp->kp_proc.p_pid;
***************
*** 3159,3165 ****
  }
  
  static void
! getargv(struct proc *p, struct kinfo_proc *kp, kvm_t *kt)
  {
  	char	**args;
  	char	*ap, *pp, *xp;
--- 3202,3208 ----
  }
  
  static void
! getargv(struct OURproc *p, struct kinfo_proc *kp, kvm_t *kt)
  {
  	char	**args;
  	char	*ap, *pp, *xp;
***************
*** 3193,3199 ****
  }
  
  static void
! postproc(struct proc *p)
  {
  	cleanline(p);
  	switch (p->p_lstate[0]) {
--- 3236,3242 ----
  }
  
  static void
! postproc(struct OURproc *p)
  {
  	cleanline(p);
  	switch (p->p_lstate[0]) {
***************
*** 3235,3241 ****
  static void
  do_procs(void)
  {
! 	struct proc	p;
  	kvm_t	*kt;
  	struct kinfo_proc	*kp;
  	int	i, cnt;
--- 3278,3284 ----
  static void
  do_procs(void)
  {
! 	struct OURproc	p;
  	kvm_t	*kt;
  	struct kinfo_proc	*kp;
  	int	i, cnt;
***************
*** 3277,3283 ****
  }
  
  static void
! getproc(struct proc *p, struct kinfo_proc2 *kp)
  {
  	memset(p, 0, sizeof *p);
  	p->p_pid = kp->p_pid;
--- 3320,3326 ----
  }
  
  static void
! getproc(struct OURproc *p, struct kinfo_proc2 *kp)
  {
  	memset(p, 0, sizeof *p);
  	p->p_pid = kp->p_pid;
***************
*** 3321,3327 ****
  }
  
  static void
! getargv(struct proc *p, struct kinfo_proc2 *kp, kvm_t *kt)
  {
  	char	**args;
  	char	*ap, *pp, *xp;
--- 3364,3370 ----
  }
  
  static void
! getargv(struct OURproc *p, struct kinfo_proc2 *kp, kvm_t *kt)
  {
  	char	**args;
  	char	*ap, *pp, *xp;
***************
*** 3355,3361 ****
  }
  
  static void
! postproc(struct proc *p)
  {
  	cleanline(p);
  	switch (p->p_lstate[0]) {
--- 3398,3404 ----
  }
  
  static void
! postproc(struct OURproc *p)
  {
  	cleanline(p);
  	switch (p->p_lstate[0]) {
***************
*** 3400,3406 ****
  static void
  do_procs(void)
  {
! 	struct proc	p;
  	kvm_t	*kt;
  	struct kinfo_proc2	*kp;
  	int	i, cnt;
--- 3443,3449 ----
  static void
  do_procs(void)
  {
! 	struct OURproc	p;
  	kvm_t	*kt;
  	struct kinfo_proc2	*kp;
  	int	i, cnt;
***************
*** 3511,3517 ****
  extern kern_return_t task_for_pid(task_port_t task, pid_t pid, task_port_t *target);
  
  static void
! getproc(struct proc *p, struct kinfo_proc *kp)
  {
  	kern_return_t   error;
  	unsigned int	info_count = TASK_BASIC_INFO_COUNT;
--- 3554,3560 ----
  extern kern_return_t task_for_pid(task_port_t task, pid_t pid, task_port_t *target);
  
  static void
! getproc(struct OURproc *p, struct kinfo_proc *kp)
  {
  	kern_return_t   error;
  	unsigned int	info_count = TASK_BASIC_INFO_COUNT;
***************
*** 3712,3718 ****
  }
  
  static void
! getargv(struct proc *p, struct kinfo_proc *kp)
  {
  	size_t	size, argsz;
  	char	*argbuf;
--- 3755,3761 ----
  }
  
  static void
! getargv(struct OURproc *p, struct kinfo_proc *kp)
  {
  	size_t	size, argsz;
  	char	*argbuf;
***************
*** 3783,3789 ****
  }
  
  static void
! postproc(struct proc *p)
  {
  	cleanline(p);
  	if (p->p_lstate[0] < 0 || p->p_lstate[0] > 8) /* play safe */
--- 3826,3832 ----
  }
  
  static void
! postproc(struct OURproc *p)
  {
  	cleanline(p);
  	if (p->p_lstate[0] < 0 || p->p_lstate[0] > 8) /* play safe */
***************
*** 3801,3807 ****
  static void
  do_procs(void)
  {
! 	struct	proc p;
  	struct	kinfo_proc *kp = NULL;
  	size_t	i, cnt;
  	pid_t	pid0;
--- 3844,3850 ----
  static void
  do_procs(void)
  {
! 	struct	OURproc p;
  	struct	kinfo_proc *kp = NULL;
  	size_t	i, cnt;
  	pid_t	pid0;
***************
*** 3828,3833 ****
--- 3871,4036 ----
  	free(kp);	
  }
  
+ #elif defined(_MINIX)
+ 
+ /* our stuff here */
+ 
+ static unsigned long getmem(void) {
+ 	return 0;
+ }
+ 
+ static void	postproc(struct OURproc *p) {
+ }
+ 
+ /* NOT for tasks */
+ static void getargv(struct OURproc *p, int p_nr, struct mproc mp[], int memfd) {
+     if (p->p_state[0] == 'Z')
+         snprintf(p->p_psargs, sizeof(p->p_psargs), "%s", "<defunct>");
+     else {
+         vir_bytes procargs = mp[p_nr].mp_procargs;
+         phys_bytes iframe = procargs -
+                             ( mp[p_nr].mp_seg[S].mem_vir << CLICK_SHIFT ) +
+                             ( mp[p_nr].mp_seg[S].mem_phys << CLICK_SHIFT );
+         int cnt = ( mp[p_nr].mp_seg[S].mem_len << CLICK_SHIFT ) -
+                   ( iframe - ( mp[p_nr].mp_seg[S].mem_phys << CLICK_SHIFT ) );
+         union stack {
+             vir_bytes i;
+             char *    cp;
+             char      c;
+         } stk[ARG_MAX / sizeof(char*)];
+         union stack *sp = stk;
+         int argc, m;
+         char *argv0;
+ 
+         if (procargs == 0) goto errout; /* servers have no procargs */
+         if (memfd < 0) goto errout;
+ 
+         if (lseek(memfd, (off_t)iframe, 0) < 0) goto errout;
+         cnt = cnt < 0 ? 0 : cnt > ARG_MAX ? ARG_MAX : cnt;
+         if (read(memfd, (char*)stk, cnt) < 0) goto errout;
+ 
+         argc = sp[0].i;
+         if (argc == 0) goto errout; /* should not happen */
+ 
+         m = (long)sp[1].cp - (long)procargs;
+         if (m<0 || m>cnt) goto errout;
+         argv0 = &((char *) stk)[m];
+ 
+         argc--;
+         m=0;
+         while (argc) {
+             if (argv0[m] == '\0') {
+                 argv0[m] = ' ';
+                 argc--;
+             }
+             if (m == cnt) break; /* should not happen */
+             m++;
+         }
+ 
+         snprintf(p->p_psargs, sizeof(p->p_psargs), "%s", argv0);
+ 
+ errout:
+         if (p->p_psargs[0] == '\0')
+             snprintf(p->p_psargs, sizeof(p->p_psargs), "%s", mp[p_nr].mp_name);
+     }
+ }
+ 
+ static void getproc(struct OURproc *p, struct proc kp[], struct mproc mp[],
+                     struct fproc fp[], int i, int memfd) {
+     int p_nr = kp[i].p_nr;
+ 
+ 	memset(p, 0, sizeof *p);
+ 
+     /* for tasks and processes alike */
+     p->p_start = 0; /* non-existent in kernel structures :/ */
+     p->p_size = ( ( kp[i].p_memmap[T].mem_len +
+                     kp[i].p_memmap[S].mem_phys - kp[i].p_memmap[D].mem_phys +
+                     kp[i].p_memmap[S].mem_len ) << CLICK_SHIFT ) / 1024;
+     p->p_osz = p->p_size / KB_PER_PAGE + 1;
+     p->p_rssize = p->p_size;
+     p->p_orss = p->p_osz;
+     p->p_utime = kp[i].p_user_time / ( CLOCKS_PER_SEC * 6 );
+     p->p_ktime = kp[i].p_sys_time / ( CLOCKS_PER_SEC * 6 );
+     p->p_time = p->p_accutime = ( p->p_utime + p->p_ktime ) / 10;
+     p->p_addr = kp[i].p_memmap[S].mem_phys << CLICK_SHIFT; /* [T] not useful */
+     p->p_policy = SCHED_OTHER;
+     p->p_intpri = p->p_rtpri = p->p_oldpri = p->p_pri = kp[i].p_priority;
+ 
+     if (p_nr < 0 ) {  /* special case for tasks */
+         p->p_pid = p_nr;
+         snprintf(p->p_fname, sizeof(p->p_fname), "%s", kp[i].p_name);
+         snprintf(p->p_comm, sizeof(p->p_comm), "%s", kp[i].p_name);
+         snprintf(p->p_psargs, sizeof(p->p_psargs), "%s", kp[i].p_name);
+         p->p_clname="TS";
+         p->p_state[0] = p->p_lstate[0] = kp[i].p_rts_flags == 0 ? 'R' : 'W';
+         return;
+     }
+ 
+     /* only for normal processes */
+     p->p_pid = mp[p_nr].mp_pid;
+     snprintf(p->p_fname, sizeof(p->p_fname), "%s", mp[p_nr].mp_name);
+     p->p_state[0] = p->p_lstate[0] = mp[p_nr].mp_flags & ZOMBIE         ? 'Z' :
+                                      mp[p_nr].mp_flags & STOPPED        ? 'T' :
+                                      kp[i].p_rts_flags == 0             ? 'R' :
+                                      mp[p_nr].mp_flags & WAITING        ? 'S' :
+                                      mp[p_nr].mp_flags & PAUSED         ? 'S' :
+                                      mp[p_nr].mp_flags & SIGSUSPENDED   ? 'S' :
+                                      fp[p_nr].fp_suspended == SUSPENDED ? 'S' :
+                                                                           'W';
+     p->p_ppid = mp[mp[p_nr].mp_parent].mp_pid;
+     p->p_pgid = mp[p_nr].mp_procgrp;
+     p->p_sid = 0; /* session id, non-existent */
+     p->p_lwp = 0; /* LWP id, non-existent */
+     p->p_ttydev = makedev(major(fp[p_nr].fp_tty), minor(fp[p_nr].fp_tty));
+     p->p_flag = p->p_lflag = kp[i].p_rts_flags;
+     p->p_nice = mp[p_nr].mp_nice;
+     /* p_nlwp */
+     p->p_pflts = 0;
+     /* p_bufr, p_bufw, p_mrcv, p_msnd */
+     p->p_wchan = _ENDPOINT_P(kp[i].p_getfrom_e);
+     p->p_psr = 0; /* cpu 0 */
+     /* p_pctcpu, p_pctmem */
+     p->p_clname = "TS";
+     snprintf(p->p_comm, sizeof(p->p_comm), "%s", mp[p_nr].mp_name);
+     getargv(p, p_nr, mp, memfd);
+     p->p_uid = mp[p_nr].mp_realuid;
+     p->p_euid = mp[p_nr].mp_effuid;
+     p->p_gid = mp[p_nr].mp_realgid;
+     p->p_egid = mp[p_nr].mp_effgid;
+ }
+ 
+ static void do_procs(void) {
+     struct OURproc p;
+     struct proc proc[PROCS];
+     struct mproc mproc[PROCS];
+     struct fproc fproc[PROCS];
+ 	size_t i;
+ 	int	err;
+     int memfd = open("/dev/mem", O_RDONLY);
+ 
+ 	if (getsysinfo(PM_PROC_NR, SI_KPROC_TAB, proc) < 0) {
+ 		fprintf(stderr, "error getting kproc tab\n");
+ 		exit(3);
+ 	}
+ 	if (getsysinfo(PM_PROC_NR, SI_PROC_TAB, mproc) < 0) {
+ 		fprintf(stderr, "error getting mproc tab\n");
+ 		exit(3);
+ 	}
+ 	if (getsysinfo(FS_PROC_NR, SI_PROC_TAB, fproc) < 0) {
+ 		fprintf(stderr, "error getting fproc tab\n");
+ 		exit(3);
+ 	}
+ 	for (i = 0; i < PROCS; i++) {
+         if (proc[i].p_rts_flags & SLOT_FREE)    continue;
+ 
+ 		getproc(&p, proc, mproc, fproc, i, memfd);
+ 
+ 		if (selectproc(&p) == OKAY)
+ 			outproc(&p);
+ 	}
+     if (memfd) close(memfd);
+ }
+ 
  #endif	/* all */
  
  /************************************************************************
***************
*** 4231,4237 ****
  {
  	FILE	*fp;
  
! 	if ((fp = fopen(DEFAULT, "r")) != NULL) {
  		char	buf[LINE_MAX];
  		char	*cp, *x;
  
--- 4434,4440 ----
  {
  	FILE	*fp;
  
! 	if ((fp = fopen(PSCDEFAULT, "r")) != NULL) {
  		char	buf[LINE_MAX];
  		char	*cp, *x;
  
***************
*** 4406,4411 ****
--- 4609,4620 ----
  					dir = sstrdup(sp[i].f_mntonname);
  					break;
  				}
+ #elif defined(_MINIX)
+ 
+             /* such a useless option on Minix */
+             fprintf(stderr, "%s: please specify absolute pathname\n", progname);
+             dir = NULL;
+ 
  #else	/* SVR4 */
  			FILE	*fp;
  			struct mnttab	mt;
***************
*** 4855,4861 ****
  	options(argc, argv);
  	devices();
  #if !defined (__hpux) && !defined (_AIX) && !defined (__NetBSD__) && \
! 		!defined (__OpenBSD__) && !defined (__APPLE__)
  	chdir_to_proc();
  #endif
  #ifdef	__linux__
--- 5064,5070 ----
  	options(argc, argv);
  	devices();
  #if !defined (__hpux) && !defined (_AIX) && !defined (__NetBSD__) && \
! 		!defined (__OpenBSD__) && !defined (__APPLE__) && !defined(_MINIX)
  	chdir_to_proc();
  #endif
  #ifdef	__linux__
***************
*** 4957,4962 ****
--- 5166,5179 ----
  			free(kp);
  		}
  	}
+ #elif defined(_MINIX)
+     {
+         struct stat	st;
+         int	fd;
+ 
+         if (stat(ttyname(0), &st) == 0)
+             myproc.p_ttydev = makedev(major(st.st_rdev), minor(st.st_rdev));
+     }
  #else	/* SVR4 */
  	{
  		/*
Common subdirectories: heirloom-060122/psrinfo and heirloom-060122-patched/psrinfo
Only in heirloom-060122-patched/psrinfo: Makefile
diff -c heirloom-060122/psrinfo/psrinfo.c heirloom-060122-patched/psrinfo/psrinfo.c
*** heirloom-060122/psrinfo/psrinfo.c Sun May 29 12:55:44 2005
--- heirloom-060122-patched/psrinfo/psrinfo.c Fri Oct 20 02:31:20 2006
***************
*** 25,31 ****
   * 3. This notice may not be removed or altered from any source distribution.
   */
  
! #ifdef	__linux__
  
  #if __GNUC__ >= 3 && __GNUC_MINOR__ >= 4 || __GNUC__ >= 4
  #define	USED	__attribute__ ((used))
--- 25,31 ----
   * 3. This notice may not be removed or altered from any source distribution.
   */
  
! #if defined (__linux__) || defined (_MINIX)
  
  #if __GNUC__ >= 3 && __GNUC_MINOR__ >= 4 || __GNUC__ >= 4
  #define	USED	__attribute__ ((used))
***************
*** 138,148 ****
  		if (sflag) {
  			/*EMPTY*/;
  		} else if (vflag) {
! 			strftime(tim, sizeof tim, "%D %T",
! 					localtime(&chain[c]->c_now));
! 			printf("Status of processor %u as of %s\n", c, tim);
! 			strftime(tim, sizeof tim, "%D %T",
! 					localtime(&chain[c]->c_since));
  			printf("  Processor has been on-line since %s.\n", tim);
  			if (chain[c]->c_MHz)
  			printf("  The %s processor operates at %u MHz,\n",
--- 138,158 ----
  		if (sflag) {
  			/*EMPTY*/;
  		} else if (vflag) {
! #ifdef _MINIX
! 			strftime(tim, sizeof tim, "%m/%d/%y %H:%M:%S",
! 					localtime(&chain[c]->c_now));
! #else
! 			strftime(tim, sizeof tim, "%D %T",
! 					localtime(&chain[c]->c_now));
! #endif
! 			printf("Status of processor %u as of %s\n", c, tim);
! #ifdef _MINIX
! 			strftime(tim, sizeof tim, "%m/%d/%y %H:%M:%S",
! 					localtime(&chain[c]->c_since));
! #else
! 			strftime(tim, sizeof tim, "%D %T",
! 					localtime(&chain[c]->c_since));
! #endif
  			printf("  Processor has been on-line since %s.\n", tim);
  			if (chain[c]->c_MHz)
  			printf("  The %s processor operates at %u MHz,\n",
***************
*** 170,175 ****
--- 180,186 ----
  	}
  }
  
+ #ifndef _MINIX
  static char *
  pair(char *line)
  {
***************
*** 188,197 ****
--- 199,210 ----
  		}
  	return NULL;
  }
+ #endif
  
  /*
   * Get frequencies.
   */
+ #ifdef __linux__
  void
  freqs(void)
  {
***************
*** 240,250 ****
  		machine = "Pentium_4";
  	fclose(fp);
  }
  
  /*
   * Read cpu time statistics.
   */
! #ifndef	__R5900
  void
  stats(void)
  {
--- 253,269 ----
  		machine = "Pentium_4";
  	fclose(fp);
  }
+ #else   /* _MINIX */
+ void
+ freqs(void)
+ {
+ }
+ #endif
  
  /*
   * Read cpu time statistics.
   */
! #if !defined (__R5900) && !defined (_MINIX)
  void
  stats(void)
  {
***************
*** 275,287 ****
  	}
  	fclose(fp);
  }
! #else	/* __R5900 */
! /*
!  * No /proc/stats on PS2.
!  */
  void
  stats(void)
  {
  	FILE	*fp;
  	time_t	now;
  	float	up, idle;
--- 294,322 ----
  	}
  	fclose(fp);
  }
! #elif defined (_MINIX)
! 
  void
  stats(void)
  {
+ 	time_t now;
+ 
+ 	time(&now);
+ 
+     ncpu=0;
+     chain = srealloc(chain, sizeof *chain * (ncpu + 1));
+     chain[ncpu] = srealloc(NULL, sizeof **chain);
+     memset(chain[ncpu], 0, sizeof **chain);
+     chain[ncpu]->c_now = now;
+ }
+ 
+ #else	/* __R5900 */
+ /*
+  * No /proc/stats on PS2.
+  */
+ void
+ stats(void)
+ {
  	FILE	*fp;
  	time_t	now;
  	float	up, idle;
***************
*** 366,376 ****
--- 401,413 ----
  			usage();
  	hz = sysconf(_SC_CLK_TCK);
  	uname(&un);
+ #ifndef _MINIX  /* this is untrue for any non-intel CPU, just print ix86 */
  	if (strcmp(un.machine, "i586") == 0)
  		machine = "Pentium";
  	else if (strcmp(un.machine, "i686") == 0)
  		machine = "Pentium_Pro";
  	else
+ #endif
  		machine = un.machine;
  	stats();
  	if (vflag)
***************
*** 391,397 ****
  	return errcnt;
  }
  
! #else	/* !__linux__ */
  
  #include	<unistd.h>
  
--- 428,434 ----
  	return errcnt;
  }
  
! #else	/* !__linux__ !_MINIX */
  
  #include	<unistd.h>
  
***************
*** 403,406 ****
  	_exit(0177);
  }
  
! #endif	/* !__linux__ */
--- 440,443 ----
  	_exit(0177);
  }
  
! #endif	/* !__linux__ !_MINIX */
Common subdirectories: heirloom-060122/pwd and heirloom-060122-patched/pwd
Only in heirloom-060122-patched/pwd: Makefile
Common subdirectories: heirloom-060122/random and heirloom-060122-patched/random
Only in heirloom-060122-patched/random: Makefile
Common subdirectories: heirloom-060122/renice and heirloom-060122-patched/renice
Only in heirloom-060122-patched/renice: Makefile
Common subdirectories: heirloom-060122/rm and heirloom-060122-patched/rm
Only in heirloom-060122-patched/rm: Makefile
diff -c heirloom-060122/rm/rm.c heirloom-060122-patched/rm/rm.c
*** heirloom-060122/rm/rm.c Thu Nov 17 01:21:36 2005
--- heirloom-060122-patched/rm/rm.c Fri Oct 20 02:38:03 2006
***************
*** 119,124 ****
--- 119,127 ----
  	int yes = 0;
  	char c;
  
+     fflush(stdout);
+     fflush(stderr);
+ 
  	if (read(0, &c, 1) == 1) {
  		yes = (c == 'y' || c == 'Y');
  		while (c != '\n' && read(0, &c, 1) == 1);
***************
*** 327,336 ****
--- 330,341 ----
  			 * that the shell never prints a 'core dumped'
  			 * message.
  			 */
+ #ifndef _MINIX
  			struct rlimit	rl;
  
  			rl.rlim_cur = rl.rlim_max = 0;
  			setrlimit(RLIMIT_CORE, &rl);
+ #endif
  			raise(WTERMSIG(status));
  			pause();
  		}
Common subdirectories: heirloom-060122/rmdir and heirloom-060122-patched/rmdir
Only in heirloom-060122-patched/rmdir: Makefile
Common subdirectories: heirloom-060122/sdiff and heirloom-060122-patched/sdiff
Only in heirloom-060122-patched/sdiff: Makefile
diff -c heirloom-060122/sdiff/sdiff.c heirloom-060122-patched/sdiff/sdiff.c
*** heirloom-060122/sdiff/sdiff.c Sun May 29 12:55:44 2005
--- heirloom-060122-patched/sdiff/sdiff.c Fri Oct 20 12:02:59 2006
***************
*** 55,63 ****
--- 55,70 ----
  #define	putchar(c)	_IO_putc_unlocked(c, stdout)
  #endif
  
+ #ifdef _MINIX
+ #define LONGLONG long
+ #define LLONG_MAX   LONG_MAX
+ #define strtoll strtol
+ #else
+ #define LONGLONG long long
  #ifndef	LLONG_MAX
  #define	LLONG_MAX	9223372036854775807LL
  #endif
+ #endif
  
  #define	next(wc, s, n) (mb_cur_max > 1 && *(s) & 0200 ? \
  			((n) = mbtowi(&(wc), (s), mb_cur_max), \
***************
*** 68,77 ****
  #include <mbtowi.h>
  
  struct difference {
! 	long long	d_lbot;
! 	long long	d_ltop;
! 	long long	d_rbot;
! 	long long	d_rtop;
  	enum {
  		D_A,
  		D_C,
--- 75,84 ----
  #include <mbtowi.h>
  
  struct difference {
! 	LONGLONG	d_lbot;
! 	LONGLONG	d_ltop;
! 	LONGLONG	d_rbot;
! 	LONGLONG	d_rtop;
  	enum {
  		D_A,
  		D_C,
***************
*** 104,115 ****
  static void	sdiff(struct iblok *, struct iblok *, struct iblok *);
  static int	dget(struct iblok *, struct difference *);
  static int	pass(struct iblok *, struct difference *, char **, size_t *);
! static long long	dput(struct iblok *, struct iblok *,
  				struct difference *);
  static void	iput(struct iblok *, int, int, FILE *);
  static void	gput(int);
! static long long	cput(struct iblok *, struct iblok *,
! 				struct difference *, long long);
  static void	done(int);
  static void	ask(void);
  static void	iflush(char);
--- 111,122 ----
  static void	sdiff(struct iblok *, struct iblok *, struct iblok *);
  static int	dget(struct iblok *, struct difference *);
  static int	pass(struct iblok *, struct difference *, char **, size_t *);
! static LONGLONG	dput(struct iblok *, struct iblok *,
  				struct difference *);
  static void	iput(struct iblok *, int, int, FILE *);
  static void	gput(int);
! static LONGLONG	cput(struct iblok *, struct iblok *,
! 				struct difference *, LONGLONG);
  static void	done(int);
  static void	ask(void);
  static void	iflush(char);
***************
*** 306,312 ****
  static void
  sdiff(struct iblok *il, struct iblok *ir, struct iblok *id)
  {
! 	long long	cur = 1;
  	struct difference	di;
  
  	while (dget(id, &di) == 0) {
--- 313,319 ----
  static void
  sdiff(struct iblok *il, struct iblok *ir, struct iblok *id)
  {
! 	LONGLONG	cur = 1;
  	struct difference	di;
  
  	while (dget(id, &di) == 0) {
***************
*** 360,366 ****
  static int
  pass(struct iblok *ip, struct difference *dp, char **lp, size_t *sp)
  {
! 	long long	cnt = -1;
  
  	switch (dp->d_type) {
  	case D_A:
--- 367,373 ----
  static int
  pass(struct iblok *ip, struct difference *dp, char **lp, size_t *sp)
  {
! 	LONGLONG	cnt = -1;
  
  	switch (dp->d_type) {
  	case D_A:
***************
*** 382,391 ****
  	return 0;
  }
  
! static long long
! dput(struct iblok *il, struct iblok *ir, struct difference *dp)
! {
! 	long long	cnt = 0, c, c2;
  
  	switch (dp->d_type) {
  	case D_A:
--- 389,398 ----
  	return 0;
  }
  
! static LONGLONG
! dput(struct iblok *il, struct iblok *ir, struct difference *dp)
! {
! 	LONGLONG	cnt = 0, c, c2;
  
  	switch (dp->d_type) {
  	case D_A:
***************
*** 489,499 ****
  	printf("  %c  ", c);
  }
  
! static long long
! cput(struct iblok *il, struct iblok *ir,
! 		struct difference *dp, long long cur)
! {
! 	long long	cnt, c;
  
  	c = cnt = dp->d_lbot - cur + (dp->d_type == D_A);
  	while (c-- > 0) {
--- 496,506 ----
  	printf("  %c  ", c);
  }
  
! static LONGLONG
! cput(struct iblok *il, struct iblok *ir,
! 		struct difference *dp, LONGLONG cur)
! {
! 	LONGLONG	cnt, c;
  
  	c = cnt = dp->d_lbot - cur + (dp->d_type == D_A);
  	while (c-- > 0) {
Common subdirectories: heirloom-060122/sed and heirloom-060122-patched/sed
Only in heirloom-060122-patched/sed: Makefile
diff -c heirloom-060122/sed/sed.h heirloom-060122-patched/sed/sed.h
*** heirloom-060122/sed/sed.h Sun Feb  6 14:47:16 2005
--- heirloom-060122-patched/sed/sed.h Tue Oct 17 02:39:23 2006
***************
*** 72,77 ****
--- 72,83 ----
  };
  #endif	/* SUS || SU3 || S42 */
  
+ #ifdef _MINIX
+ #define LONGLONG long
+ #else
+ #define LONGLONG long long
+ #endif
+ 
  extern int	circf, ceof, nbra, sed;
  
  struct	yitem {
***************
*** 92,98 ****
  extern char	*linebuf;
  extern char	*holdsp;
  extern int	nflag;
! extern long long	*tlno;
  
  enum cmd {
  	ACOM	= 01,
--- 98,104 ----
  extern char	*linebuf;
  extern char	*holdsp;
  extern int	nflag;
! extern LONGLONG	*tlno;
  
  enum cmd {
  	ACOM	= 01,
diff -c heirloom-060122/sed/sed0.c heirloom-060122-patched/sed/sed0.c
*** heirloom-060122/sed/sed0.c Sat Mar 12 22:00:09 2005
--- heirloom-060122-patched/sed/sed0.c Tue Oct 17 02:39:50 2006
***************
*** 51,57 ****
  char	*linebuf;
  char	*holdsp;
  int	nflag;
! long long	*tlno;
  char	*cp;
  
  int	status;
--- 51,57 ----
  char	*linebuf;
  char	*holdsp;
  int	nflag;
! LONGLONG	*tlno;
  char	*cp;
  
  int	status;
***************
*** 700,706 ****
  address(char **expbuf)
  {
  	register char	*rcp, *ep;
! 	long long	lno;
  
  	*expbuf = NULL;
  	if(*cp == '$') {
--- 700,706 ----
  address(char **expbuf)
  {
  	register char	*rcp, *ep;
! 	LONGLONG	lno;
  
  	*expbuf = NULL;
  	if(*cp == '$') {
diff -c heirloom-060122/sed/sed1.c heirloom-060122-patched/sed/sed1.c
*** heirloom-060122/sed/sed1.c Sun Feb  6 14:47:16 2005
--- heirloom-060122-patched/sed/sed1.c Tue Oct 17 02:40:05 2006
***************
*** 110,116 ****
  static int	sflag;
  static int	jflag;
  static int	delflag;
! static long long	lnum;
  static char	ibuf[512];
  static int	ibrd;
  static int	mflag;
--- 110,116 ----
  static int	sflag;
  static int	jflag;
  static int	delflag;
! static LONGLONG	lnum;
  static char	ibuf[512];
  static int	ibrd;
  static int	mflag;
Common subdirectories: heirloom-060122/sed/test and heirloom-060122-patched/sed/test
Common subdirectories: heirloom-060122/setpgrp and heirloom-060122-patched/setpgrp
Only in heirloom-060122-patched/setpgrp: Makefile
diff -c heirloom-060122/setpgrp/setpgrp.c heirloom-060122-patched/setpgrp/setpgrp.c
*** heirloom-060122/setpgrp/setpgrp.c Sun May 29 12:55:44 2005
--- heirloom-060122-patched/setpgrp/setpgrp.c Fri Oct 20 12:13:11 2006
***************
*** 30,35 ****
--- 30,42 ----
  #include	<errno.h>
  #include	<signal.h>
  
+ #ifdef _MINIX
+ #define getpgid(a) getpgrp()
+ #define getsid(a) getpgrp()
+ #define setpgid(a,b) setsid()
+ #else
+ #endif
+ 
  #if __GNUC__ >= 3 && __GNUC_MINOR__ >= 4 || __GNUC__ >= 4
  #define	USED	__attribute__ ((used))
  #elif defined __GNUC__
Common subdirectories: heirloom-060122/shl and heirloom-060122-patched/shl
Only in heirloom-060122-patched/shl: Makefile
diff -c heirloom-060122/shl/Makefile.mk heirloom-060122-patched/shl/Makefile.mk
*** heirloom-060122/shl/Makefile.mk Mon Nov 21 23:25:46 2005
--- heirloom-060122-patched/shl/Makefile.mk Fri Oct 20 22:46:12 2006
***************
*** 10,20 ****
  	u=`uname`; \
  	if test "$$u" != FreeBSD && test "$$u" != HP-UX && \
  		test "$$u" != AIX && test "$$u" != NetBSD && \
! 		test "$$u" != OpenBSD && test "$$u" != DragonFly ; \
  	then \
  		$(UCBINST) -c $(TTYGRP) -m 2755 shl $(ROOT)$(DEFBIN)/shl &&\
  		$(STRIP) $(ROOT)$(DEFBIN)/shl &&\
  		$(MANINST) -c -m 644 shl.1 $(ROOT)$(MANDIR)/man1/shl.1; \
  	else \
  		exit 0; \
  	fi
--- 10,25 ----
  	u=`uname`; \
  	if test "$$u" != FreeBSD && test "$$u" != HP-UX && \
  		test "$$u" != AIX && test "$$u" != NetBSD && \
! 		test "$$u" != OpenBSD && test "$$u" != DragonFly && \
! 		test "$$u" != Minix ; \
  	then \
  		$(UCBINST) -c $(TTYGRP) -m 2755 shl $(ROOT)$(DEFBIN)/shl &&\
  		$(STRIP) $(ROOT)$(DEFBIN)/shl &&\
  		$(MANINST) -c -m 644 shl.1 $(ROOT)$(MANDIR)/man1/shl.1; \
+ 	elif test "$$u" = "Minix" ; then \
+ 		$(UCBINST) -c -m 755 shl $(ROOT)$(DEFBIN)/shl &&\
+ 		$(STRIP) $(ROOT)$(DEFBIN)/shl &&\
+ 		$(MANINST) -c -m 644 shl.1 $(ROOT)$(MANDIR)/man1/shl.1; \
  	else \
  		exit 0; \
  	fi
diff -c heirloom-060122/shl/shl.c heirloom-060122-patched/shl/shl.c
*** heirloom-060122/shl/shl.c Sun Jan 22 18:54:50 2006
--- heirloom-060122-patched/shl/shl.c Fri Oct 20 12:18:13 2006
***************
*** 34,40 ****
  
  #if !defined (__FreeBSD__) && !defined (__hpux) && !defined (_AIX) && \
  	!defined (__NetBSD__) && !defined (__OpenBSD__) && \
! 	!defined (__DragonFly__) && !defined (__APPLE__)
  
  /*
   * UnixWare 2.1 needs _KMEMUSER to access some flags for STREAMS. Maybe other
--- 34,40 ----
  
  #if !defined (__FreeBSD__) && !defined (__hpux) && !defined (_AIX) && \
  	!defined (__NetBSD__) && !defined (__OpenBSD__) && \
! 	!defined (__DragonFly__) && !defined (__APPLE__) && !defined (_MINIX)
  
  /*
   * UnixWare 2.1 needs _KMEMUSER to access some flags for STREAMS. Maybe other
Common subdirectories: heirloom-060122/sleep and heirloom-060122-patched/sleep
Only in heirloom-060122-patched/sleep: Makefile
Common subdirectories: heirloom-060122/sort and heirloom-060122-patched/sort
Only in heirloom-060122-patched/sort: Makefile
diff -c heirloom-060122/sort/sort.c heirloom-060122-patched/sort/sort.c
*** heirloom-060122/sort/sort.c Sun May 29 12:55:44 2005
--- heirloom-060122-patched/sort/sort.c Fri Oct 20 12:20:51 2006
***************
*** 63,69 ****
  #include <locale.h>
  #include <wchar.h>
  #include <wctype.h>
! #include <langinfo.h>
  #include <inttypes.h>
  #include <errno.h>
  
--- 63,73 ----
  #include <locale.h>
  #include <wchar.h>
  #include <wctype.h>
! #ifdef _MINIX
! #include "../cal/fake_langinfo.h"
! #else
! #include <langinfo.h>
! #endif
  #include <inttypes.h>
  #include <errno.h>
  
Common subdirectories: heirloom-060122/spell and heirloom-060122-patched/spell
Only in heirloom-060122-patched/spell: Makefile
diff -c heirloom-060122/spell/Makefile.mk heirloom-060122-patched/spell/Makefile.mk
*** heirloom-060122/spell/Makefile.mk Sun Jul 17 11:24:27 2005
--- heirloom-060122-patched/spell/Makefile.mk Fri Oct 20 12:26:08 2006
***************
*** 36,54 ****
  		hlista hlistb hstop hashmake hashcheck
  
  spell: spell.sh
! 	echo '#!$(SHELL)' | cat - spell.sh | sed ' \
! 		s,@DEFBIN@,$(DEFBIN),g; \
! 		s,@SV3BIN@,$(SV3BIN),g; \
! 		s,@DEFLIB@,$(DEFLIB),g; \
! 		s,@SPELLHIST@,$(SPELLHIST),g' >spell
  	chmod 755 spell
  
  compress: compress.sh
! 	echo '#!$(SHELL)' | cat - compress.sh | sed ' \
! 		s,@DEFBIN@,$(DEFBIN),g; \
! 		s,@SV3BIN@,$(SV3BIN),g; \
! 		s,@DEFLIB@,$(DEFLIB),g; \
! 		s,@SPELLHIST@,$(SPELLHIST),g' >compress
  	chmod 755 compress
  
  spellprog: spellprog.o hash.o hashlook.o huff.o
--- 36,46 ----
  		hlista hlistb hstop hashmake hashcheck
  
  spell: spell.sh
! 	echo '#!$(SHELL)' | cat - spell.sh | sed 's,@DEFBIN@,$(DEFBIN),g; s,@SV3BIN@,$(SV3BIN),g; s,@DEFLIB@,$(DEFLIB),g; s,@SPELLHIST@,$(SPELLHIST),g' >spell
  	chmod 755 spell
  
  compress: compress.sh
! 	echo '#!$(SHELL)' | cat - compress.sh | sed 's,@DEFBIN@,$(DEFBIN),g; s,@SV3BIN@,$(SV3BIN),g; s,@DEFLIB@,$(DEFLIB),g; s,@SPELLHIST@,$(SPELLHIST),g' >compress
  	chmod 755 compress
  
  spellprog: spellprog.o hash.o hashlook.o huff.o
***************
*** 58,64 ****
  	$(LD) $(LDFLAGS) spellin.o huff.o $(LCOMMON) $(LIBS) -o spellin
  
  host_spellin: spellin.c huff.c
! 	$(HOSTCC) spellin.c huff.c -o host_spellin
  
  hashcheck: hashcheck.o hash.o huff.o
  	$(LD) $(LDFLAGS) hashcheck.o hash.o huff.o $(LCOMMON) $(LIBS) -o hashcheck
--- 50,56 ----
  	$(LD) $(LDFLAGS) spellin.o huff.o $(LCOMMON) $(LIBS) -o spellin
  
  host_spellin: spellin.c huff.c
! 	$(HOSTCC) $(LDFLAGS) spellin.c huff.c -o host_spellin
  
  hashcheck: hashcheck.o hash.o huff.o
  	$(LD) $(LDFLAGS) hashcheck.o hash.o huff.o $(LCOMMON) $(LIBS) -o hashcheck
***************
*** 67,73 ****
  	$(LD) $(LDFLAGS) hashmake.o hash.o $(LCOMMON) $(LIBS) -o hashmake
  
  host_hashmake: hashmake.c hash.c
! 	$(HOSTCC) hashmake.c hash.c -o host_hashmake
  
  htemp1: list local extra host_hashmake
  	rm -f $@; cat list local extra | ./host_hashmake > $@
--- 59,65 ----
  	$(LD) $(LDFLAGS) hashmake.o hash.o $(LCOMMON) $(LIBS) -o hashmake
  
  host_hashmake: hashmake.c hash.c
! 	$(HOSTCC) $(LDFLAGS) hashmake.c hash.c -o host_hashmake
  
  htemp1: list local extra host_hashmake
  	rm -f $@; cat list local extra | ./host_hashmake > $@
Common subdirectories: heirloom-060122/split and heirloom-060122-patched/split
Only in heirloom-060122-patched/split: Makefile
diff -c heirloom-060122/split/split.c heirloom-060122-patched/split/split.c
*** heirloom-060122/split/split.c Sun May 29 12:55:44 2005
--- heirloom-060122-patched/split/split.c Fri Oct 20 12:29:30 2006
***************
*** 52,60 ****
  #endif
  #endif
  
! static const char	*progname;
! static long long	bytecount;
! static long long	linecount = 1000;
  static const char	*prefix = "x";
  static int		suffixlength = 2;
  static int		status;
--- 52,68 ----
  #endif
  #endif
  
! #ifdef _MINIX
! #define LONGLONG long
! #define strtoll strtol
! #define atoll atol
! #else
! #define LONGLONG long long
! #endif
! 
! static const char	*progname;
! static LONGLONG	bytecount;
! static LONGLONG	linecount = 1000;
  static const char	*prefix = "x";
  static int		suffixlength = 2;
  static int		status;
***************
*** 159,165 ****
  split(const char *fn)
  {
  	FILE	*fp, *op = NULL;
! 	long long	bytes = bytecount, lines = linecount, n, m;
  	char	b[4096];
  	int	c;
  
--- 167,173 ----
  split(const char *fn)
  {
  	FILE	*fp, *op = NULL;
! 	LONGLONG	bytes = bytecount, lines = linecount, n, m;
  	char	b[4096];
  	int	c;
  
***************
*** 205,213 ****
  static FILE *
  nextfile(void)
  {
! 	static long long	fileno;
! 	static char		*name, *sufp;
! 	long long	c;
  	const char	*cp;
  	char	*sp;
  	FILE	*fp;
--- 213,221 ----
  static FILE *
  nextfile(void)
  {
! 	static LONGLONG	fileno;
! 	static char		*name, *sufp;
! 	LONGLONG	c;
  	const char	*cp;
  	char	*sp;
  	FILE	*fp;
Common subdirectories: heirloom-060122/stty and heirloom-060122-patched/stty
Only in heirloom-060122-patched/stty: Makefile
diff -c heirloom-060122/stty/stty.c heirloom-060122-patched/stty/stty.c
*** heirloom-060122/stty/stty.c Sun Jan 22 18:55:11 2006
--- heirloom-060122-patched/stty/stty.c Fri Oct 20 12:49:16 2006
***************
*** 145,151 ****
  	{ "\n",		0,	0,	0,	04,	M_NSEPAR },
  	{ "eof",	0,	VEOF,	'\4',	0,	M_CC },
  	{ "eol",	0,	VEOL,	'\0',	0,	M_CC },
! 	{ "eol2",	0,	VEOL2,	'\0',	0,	M_CC },
  #ifdef	VSWTCH
  	{ "swtch",	0,	VSWTCH,	'\32',	0,	M_CC },
  #endif
--- 145,153 ----
  	{ "\n",		0,	0,	0,	04,	M_NSEPAR },
  	{ "eof",	0,	VEOF,	'\4',	0,	M_CC },
  	{ "eol",	0,	VEOL,	'\0',	0,	M_CC },
! #ifdef VEOL2
! 	{ "eol2",	0,	VEOL2,	'\0',	0,	M_CC },
! #endif
  #ifdef	VSWTCH
  	{ "swtch",	0,	VSWTCH,	'\32',	0,	M_CC },
  #endif
***************
*** 234,240 ****
  #ifdef	UCB
  	{ "tandem",	0,	IXOFF,	0,	040,	M_IFLAG },
  #endif	/* UCB */
! 	{ "imaxbel",	0,	IMAXBEL,0,	0,	M_IFLAG },
  #ifdef	IUTF8
  	{ "iutf8",	0,	IUTF8,	0,	0,	M_IFLAG },
  #endif
--- 236,244 ----
  #ifdef	UCB
  	{ "tandem",	0,	IXOFF,	0,	040,	M_IFLAG },
  #endif	/* UCB */
! #ifdef IMAXBEL
! 	{ "imaxbel",	0,	IMAXBEL,0,	0,	M_IFLAG },
! #endif
  #ifdef	IUTF8
  	{ "iutf8",	0,	IUTF8,	0,	0,	M_IFLAG },
  #endif
***************
*** 254,262 ****
  #else	/* UCB */
  	{ "onlcr",	0,	ONLCR,	ONLCR,	0102,	M_OFLAG },
  #endif	/* UCB */
! 	{ "ocrnl",	0,	OCRNL,	0,	0102,	M_OFLAG },
! 	{ "onocr",	0,	ONOCR,	0,	0102,	M_OFLAG },
! 	{ "onlret",	0,	ONLRET,	0,	0102,	M_OFLAG },
  #if defined (OFILL) && defined (OFDEL)
  	{ "nul-fill",	0,	OFILL,OFILL|OFDEL,0202,	M_OFLAG },
  	{ "del-fill",	0,OFILL|OFDEL,OFILL|OFDEL,0202,	M_OFLAG },
--- 258,272 ----
  #else	/* UCB */
  	{ "onlcr",	0,	ONLCR,	ONLCR,	0102,	M_OFLAG },
  #endif	/* UCB */
! #ifdef OCRNL
! 	{ "ocrnl",	0,	OCRNL,	0,	0102,	M_OFLAG },
! #endif
! #ifdef ONOCR
! 	{ "onocr",	0,	ONOCR,	0,	0102,	M_OFLAG },
! #endif
! #ifdef ONLRET
! 	{ "onlret",	0,	ONLRET,	0,	0102,	M_OFLAG },
! #endif
  #if defined (OFILL) && defined (OFDEL)
  	{ "nul-fill",	0,	OFILL,OFILL|OFDEL,0202,	M_OFLAG },
  	{ "del-fill",	0,OFILL|OFDEL,OFILL|OFDEL,0202,	M_OFLAG },
***************
*** 286,295 ****
  	{ "crterase",	0,	ECHOE,	0,	040,	M_LFLAG },
  	{ "echok",	0,	ECHOK,	ECHOK,	0,	M_LFLAG },
  	{ "lfkc",	0,	ECHOK,	0,	040,	M_LFLAG },
! 	{ "echoe",	0,ECHOE|ECHOKE,	ECHOE,	0122,	M_LFLAG },
! 	{ "-echoke",	0,ECHOE|ECHOKE,	ECHOE,	0122,	M_LFLAG },
! 	{ "echoprt",	0,ECHOE|ECHOPRT,0,	0122,	M_LFLAG },
! 	{ "crt",	0,ECHOE|ECHOKE,ECHOE|ECHOKE,0302,M_LFLAG },
  #endif	/* UCB */
  	{ "lfkc",	0,	ECHOK,	0,	040,	M_LFLAG },
  	{ "echonl",	0,	ECHONL,	0,	0,	M_LFLAG },
--- 296,313 ----
  	{ "crterase",	0,	ECHOE,	0,	040,	M_LFLAG },
  	{ "echok",	0,	ECHOK,	ECHOK,	0,	M_LFLAG },
  	{ "lfkc",	0,	ECHOK,	0,	040,	M_LFLAG },
! # ifdef ECHOKE
! 	{ "echoe",	0,ECHOE|ECHOKE,	ECHOE,	0122,	M_LFLAG },
! 	{ "-echoke",	0,ECHOE|ECHOKE,	ECHOE,	0122,	M_LFLAG },
! # endif
! # ifdef ECHOPRT
! 	{ "echoprt",	0,ECHOE|ECHOPRT,0,	0122,	M_LFLAG },
! # endif
! # ifdef ECHOKE
! 	{ "crt",	0,ECHOE|ECHOKE,ECHOE|ECHOKE,0302,M_LFLAG },
! # else
! 	{ "crt",	0,ECHOE,ECHOE,0302,M_LFLAG },
! # endif
  #endif	/* UCB */
  	{ "lfkc",	0,	ECHOK,	0,	040,	M_LFLAG },
  	{ "echonl",	0,	ECHONL,	0,	0,	M_LFLAG },
***************
*** 297,318 ****
  	{ "\n",		0,	0,	0,	04,	M_NSEPAR },
  	{ "tostop",	0,	TOSTOP,	0,	0,	M_LFLAG },
  #ifndef	UCB
! 	{ "echoctl",	0,	ECHOCTL,0,	0,	M_LFLAG },
! #else	/* UCB */
! 	{ "echoctl",	0,	ECHOCTL,ECHOCTL,0,	M_LFLAG },
! 	{ "ctlecho",	0,	ECHOCTL,0,	040,	M_LFLAG },
! 	{ "prterase",	0,	ECHOPRT,0,	040,	M_LFLAG },
! #endif	/* UCB */
! 	{ "echoprt",	0,	ECHOPRT,0,	04,	M_LFLAG },
! #ifndef	UCB
! 	{ "echoke",	0,	ECHOKE,	0,	0,	M_LFLAG },
! #else	/* UCB */
! 	{ "echoke",	0,	ECHOKE,	0,	04,	M_LFLAG },
! 	{ "crtkill",	0,	ECHOKE,	0,	040,	M_LFLAG },
! #endif	/* UCB */
! 	{ "defecho",	0,	0,	0,	0,	M_INVAL },
! 	{ "flusho",	0,	FLUSHO,	0,	0,	M_LFLAG },
! 	{ "pendin",	0,	PENDIN,	0,	0,	M_LFLAG },
  	{ "iexten",	0,	IEXTEN,	0,	0,	M_LFLAG },
  	{ "\n",		0,	0,	0,	04,	M_SEPAR },
  	{ "opost",	0,	OPOST,	OPOST,	04,	M_OFLAG },
--- 315,352 ----
  	{ "\n",		0,	0,	0,	04,	M_NSEPAR },
  	{ "tostop",	0,	TOSTOP,	0,	0,	M_LFLAG },
  #ifndef	UCB
! # ifdef ECHOCTL
! 	{ "echoctl",	0,	ECHOCTL,0,	0,	M_LFLAG },
! # endif
! #else	/* UCB */
! # ifdef ECHOCTL
! 	{ "echoctl",	0,	ECHOCTL,ECHOCTL,0,	M_LFLAG },
! 	{ "ctlecho",	0,	ECHOCTL,0,	040,	M_LFLAG },
! # endif
! # ifdef ECHOPRT
! 	{ "prterase",	0,	ECHOPRT,0,	040,	M_LFLAG },
! # endif
! #endif	/* UCB */
! #ifdef ECHOPRT
! 	{ "echoprt",	0,	ECHOPRT,0,	04,	M_LFLAG },
! #endif
! #ifndef	UCB
! # ifdef ECHOKE
! 	{ "echoke",	0,	ECHOKE,	0,	0,	M_LFLAG },
! # endif
! #else	/* UCB */
! # ifdef ECHOKE
! 	{ "echoke",	0,	ECHOKE,	0,	04,	M_LFLAG },
! 	{ "crtkill",	0,	ECHOKE,	0,	040,	M_LFLAG },
! # endif
! #endif	/* UCB */
! 	{ "defecho",	0,	0,	0,	0,	M_INVAL },
! #ifdef FLUSHO
! 	{ "flusho",	0,	FLUSHO,	0,	0,	M_LFLAG },
! #endif
! #ifdef PENDIN
! 	{ "pendin",	0,	PENDIN,	0,	0,	M_LFLAG },
! #endif
  	{ "iexten",	0,	IEXTEN,	0,	0,	M_LFLAG },
  	{ "\n",		0,	0,	0,	04,	M_SEPAR },
  	{ "opost",	0,	OPOST,	OPOST,	04,	M_OFLAG },
***************
*** 320,328 ****
  	{ "olcuc",	0,	OLCUC,	0,	04,	M_OFLAG },
  #endif
  	{ "onlcr",	0,	ONLCR,	0,	04,	M_OFLAG },
! 	{ "ocrnl",	0,	OCRNL,	0,	04,	M_OFLAG },
! 	{ "onocr",	0,	ONOCR,	0,	04,	M_OFLAG },
! 	{ "onlret",	0,	ONLRET,	0,	04,	M_OFLAG },
  #ifdef	OFILL
  	{ "ofill",	0,	OFILL,	0,	04,	M_OFLAG },
  #endif
--- 354,368 ----
  	{ "olcuc",	0,	OLCUC,	0,	04,	M_OFLAG },
  #endif
  	{ "onlcr",	0,	ONLCR,	0,	04,	M_OFLAG },
! #ifdef OCRNL
! 	{ "ocrnl",	0,	OCRNL,	0,	04,	M_OFLAG },
! #endif
! #ifdef ONOCR
! 	{ "onocr",	0,	ONOCR,	0,	04,	M_OFLAG },
! #endif
! #ifdef ONLRET
! 	{ "onlret",	0,	ONLRET,	0,	04,	M_OFLAG },
! #endif
  #ifdef	OFILL
  	{ "ofill",	0,	OFILL,	0,	04,	M_OFLAG },
  #endif
***************
*** 1031,1037 ****
  		ts.c_iflag |= ICRNL;
  		ts.c_oflag |= ONLCR;
  		ts.c_iflag &= ~(tcflag_t)(INLCR|IGNCR);
! 		ts.c_oflag &= ~(tcflag_t)(OCRNL|ONLRET);
  	} else {
  		ts.c_iflag &= ~(tcflag_t)ICRNL;
  		ts.c_oflag &= ~(tcflag_t)ONLCR;
--- 1071,1089 ----
  		ts.c_iflag |= ICRNL;
  		ts.c_oflag |= ONLCR;
  		ts.c_iflag &= ~(tcflag_t)(INLCR|IGNCR);
! #ifdef OCRNL
! # ifdef ONLRET
! 		ts.c_oflag &= ~(tcflag_t)(OCRNL|ONLRET);
! # else
! 		ts.c_oflag &= ~(tcflag_t)(OCRNL);
! # endif
! #else
! # ifdef ONLRET
! 		ts.c_oflag &= ~(tcflag_t)(ONLRET);
! # else
! 		ts.c_oflag &= ~(tcflag_t)(0);
! # endif
! #endif
  	} else {
  		ts.c_iflag &= ~(tcflag_t)ICRNL;
  		ts.c_oflag &= ~(tcflag_t)ONLCR;
***************
*** 1053,1059 ****
  	ts.c_cc[VKILL] = '\25';
  	ts.c_cc[VEOF] = '\4';
  	ts.c_cc[VEOL] = vdis;
! 	ts.c_cc[VEOL2] = vdis;
  #ifdef	VSWTCH
  	ts.c_cc[VSWTCH] = vdis;
  #endif
--- 1105,1113 ----
  	ts.c_cc[VKILL] = '\25';
  	ts.c_cc[VEOF] = '\4';
  	ts.c_cc[VEOL] = vdis;
! #ifdef VEOL2
! 	ts.c_cc[VEOL2] = vdis;
! #endif
  #ifdef	VSWTCH
  	ts.c_cc[VSWTCH] = vdis;
  #endif
***************
*** 1071,1078 ****
  #endif
  	ts.c_cc[VLNEXT] = '\26';
  	ts.c_cflag = CS8|CREAD;
! 	ts.c_lflag = ISIG|ICANON|ECHO|ECHOE|ECHOK|ECHOKE|IEXTEN;
! 	ts.c_iflag = BRKINT|IGNPAR|ICRNL|IXON|IMAXBEL;
  #ifdef	IUTF8
  	if (MB_CUR_MAX > 1) {
  		wchar_t	wc;
--- 1125,1140 ----
  #endif
  	ts.c_cc[VLNEXT] = '\26';
  	ts.c_cflag = CS8|CREAD;
! #ifdef ECHOKE
! 	ts.c_lflag = ISIG|ICANON|ECHO|ECHOE|ECHOK|ECHOKE|IEXTEN;
! #else
! 	ts.c_lflag = ISIG|ICANON|ECHO|ECHOE|ECHOK|IEXTEN;
! #endif
! #ifdef IMAXBEL
! 	ts.c_iflag = BRKINT|IGNPAR|ICRNL|IXON|IMAXBEL;
! #else
! 	ts.c_iflag = BRKINT|IGNPAR|ICRNL|IXON;
! #endif
  #ifdef	IUTF8
  	if (MB_CUR_MAX > 1) {
  		wchar_t	wc;
***************
*** 1274,1280 ****
  			(int)ts.c_cc[VKILL],
  			(int)ts.c_cc[VEOF],
  			(int)ts.c_cc[VEOL],
! 			(int)ts.c_cc[VEOL2],
  #ifdef	VSWTCH
  			(int)ts.c_cc[VSWTCH],
  #else
--- 1336,1344 ----
  			(int)ts.c_cc[VKILL],
  			(int)ts.c_cc[VEOF],
  			(int)ts.c_cc[VEOL],
! #ifdef VEOL2
! 			(int)ts.c_cc[VEOL2],
! #endif
  #ifdef	VSWTCH
  			(int)ts.c_cc[VSWTCH],
  #else
***************
*** 1336,1342 ****
  	ts.c_cc[VKILL] = vkill;
  	ts.c_cc[VEOF] = veof;
  	ts.c_cc[VEOL] = veol;
! 	ts.c_cc[VEOL2] = veol2;
  #ifdef	VSWTCH
  	ts.c_cc[VSWTCH] = vswtch;
  #endif
--- 1400,1408 ----
  	ts.c_cc[VKILL] = vkill;
  	ts.c_cc[VEOF] = veof;
  	ts.c_cc[VEOL] = veol;
! #ifdef VEOL2
! 	ts.c_cc[VEOL2] = veol2;
! #endif
  #ifdef	VSWTCH
  	ts.c_cc[VSWTCH] = vswtch;
  #endif
***************
*** 1471,1479 ****
  {
  	if (not)
  		inval();
! 	ts.c_lflag |= ECHOE|ECHOCTL;
! 	if (cfgetospeed(&ts) >= B1200)
! 		ts.c_lflag |= ECHOKE;
  }
  
  static void
--- 1537,1551 ----
  {
  	if (not)
  		inval();
! #ifdef ECHOCTL
! 	ts.c_lflag |= ECHOE|ECHOCTL;
! #else
! 	ts.c_lflag |= ECHOE;
! #endif
! #ifdef ECHOKE
! 	if (cfgetospeed(&ts) >= B1200)
! 		ts.c_lflag |= ECHOKE;
! #endif
  }
  
  static void
Common subdirectories: heirloom-060122/su and heirloom-060122-patched/su
Only in heirloom-060122-patched/su: Makefile
diff -c heirloom-060122/su/su.c heirloom-060122-patched/su/su.c
*** heirloom-060122/su/su.c Sun May 29 12:55:45 2005
--- heirloom-060122-patched/su/su.c Fri Oct 20 12:52:08 2006
***************
*** 61,66 ****
--- 61,69 ----
  #endif	/* SHADOW_PWD */
  #define	PAM_MAX_RESP_SIZE	512
  #endif	/* !PAM */
+ #ifndef LINE_MAX
+ #define LINE_MAX 2048   /* POSIX 2 LINE_MAX */
+ #endif
  
  enum logtype {
  	LT_NONE,
Common subdirectories: heirloom-060122/sum and heirloom-060122-patched/sum
Only in heirloom-060122-patched/sum: Makefile
diff -c heirloom-060122/sum/sum.c heirloom-060122-patched/sum/sum.c
*** heirloom-060122/sum/sum.c Sun May 29 12:55:45 2005
--- heirloom-060122-patched/sum/sum.c Fri Oct 20 12:54:45 2006
***************
*** 65,70 ****
--- 65,78 ----
  #define	UNIT	512
  #endif
  
+ #ifdef _MINIX
+ #define LONGLONG long
+ #define NP_LLU "lu"
+ #else
+ #define LONGLONG long long
+ #define NP_LLU "llu"
+ #endif
+ 
  static char	*progname;
  static int	rflag;
  
***************
*** 77,83 ****
  	int	fd;
  	ssize_t	sz, i;
  	char	buf[4096];
! 	unsigned long long	nbytes;
  
  	if (name) {
  		if ((fd = open(name, O_RDONLY)) < 0) {
--- 85,91 ----
  	int	fd;
  	ssize_t	sz, i;
  	char	buf[4096];
! 	unsigned LONGLONG	nbytes;
  
  	if (name) {
  		if ((fd = open(name, O_RDONLY)) < 0) {
***************
*** 111,123 ****
  		err = 1;
  	}
  	if (rflag)
! 		printf("%.5u %5llu", (unsigned)sum,
! 				(unsigned long long)(nbytes+UNIT-1)/UNIT);
  	else {
  		s = (s & 0xFFFF) + (s >> 16);
  		s = (s & 0xFFFF) + (s >> 16);
! 		printf("%u %llu", (unsigned)s,
! 				(unsigned long long)(nbytes+UNIT-1)/UNIT);
  	}
  	if(name)
  		printf(" %s", name);
--- 119,131 ----
  		err = 1;
  	}
  	if (rflag)
! 		printf("%.5u %5" NP_LLU, (unsigned)sum,
! 				(unsigned LONGLONG)(nbytes+UNIT-1)/UNIT);
  	else {
  		s = (s & 0xFFFF) + (s >> 16);
  		s = (s & 0xFFFF) + (s >> 16);
! 		printf("%u %" NP_LLU, (unsigned)s,
! 				(unsigned LONGLONG)(nbytes+UNIT-1)/UNIT);
  	}
  	if(name)
  		printf(" %s", name);
Common subdirectories: heirloom-060122/sync and heirloom-060122-patched/sync
Only in heirloom-060122-patched/sync: Makefile
Common subdirectories: heirloom-060122/tabs and heirloom-060122-patched/tabs
Only in heirloom-060122-patched/tabs: Makefile
diff -c heirloom-060122/tabs/tabs.c heirloom-060122-patched/tabs/tabs.c
*** heirloom-060122/tabs/tabs.c Sun May 29 12:55:45 2005
--- heirloom-060122-patched/tabs/tabs.c Fri Oct 20 12:58:31 2006
***************
*** 76,82 ****
  {
  	if (devsp) {
  		tcsetattr(1, TCSADRAIN, &devts);
! 		fchmod(1, devsp->st_mode & 07777);
  	}
  	exit(signo ? signo | 0200 : status);
  }
--- 76,84 ----
  {
  	if (devsp) {
  		tcsetattr(1, TCSADRAIN, &devts);
! #ifndef _MINIX
! 		fchmod(1, devsp->st_mode & 07777);
! #endif
  	}
  	exit(signo ? signo | 0200 : status);
  }
***************
*** 92,100 ****
  	if (tcgetattr(1, &devts) == 0) {
  		if (fstat(1, &st) == 0) {
  			devsp = &st;
! 			fchmod(1, 0);
! 			nts = devts;
! 			nts.c_oflag &= ~(ONLCR|OCRNL|ONOCR|ONLRET);
  			tcsetattr(1, TCSADRAIN, &nts);
  		}
  	}
--- 94,108 ----
  	if (tcgetattr(1, &devts) == 0) {
  		if (fstat(1, &st) == 0) {
  			devsp = &st;
! #ifndef _MINIX
! 			fchmod(1, 0);
! #endif
! 			nts = devts;
! #ifdef _MINIX
! 			nts.c_oflag &= ~(ONLCR);
! #else
! 			nts.c_oflag &= ~(ONLCR|OCRNL|ONOCR|ONLRET);
! #endif
  			tcsetattr(1, TCSADRAIN, &nts);
  		}
  	}
Common subdirectories: heirloom-060122/tail and heirloom-060122-patched/tail
Only in heirloom-060122-patched/tail: Makefile
diff -c heirloom-060122/tail/tail.c heirloom-060122-patched/tail/tail.c
*** heirloom-060122/tail/tail.c Fri Jun  3 14:44:31 2005
--- heirloom-060122-patched/tail/tail.c Fri Oct 20 13:57:12 2006
***************
*** 49,59 ****
  
  #include	<sys/types.h>
  #include	<sys/stat.h>
! #include	<sys/mman.h>
  #include	<sys/resource.h>
  #include	<fcntl.h>
  #include	<unistd.h>
! #include	<poll.h>
  #include	<stdio.h>
  #include	<string.h>
  #include	<stdlib.h>
--- 49,63 ----
  
  #include	<sys/types.h>
  #include	<sys/stat.h>
! #ifndef _MINIX
! #include	<sys/mman.h>
! #endif
  #include	<sys/resource.h>
  #include	<fcntl.h>
  #include	<unistd.h>
! #ifndef _MINIX
! #include	<poll.h>
! #endif
  #include	<stdio.h>
  #include	<string.h>
  #include	<stdlib.h>
***************
*** 63,68 ****
--- 67,81 ----
  #include	<ctype.h>
  #include	"atoll.h"
  
+ #ifdef _MINIX
+ #define LONGLONG long
+ #define LLONG_MAX LONG_MAX
+ #define LINE_MAX    2048    /* POSIX 2 LINE_MAX */
+ #define strtoull strtoul
+ #else
+ #define LONGLONG long long
+ #endif
+ 
  #define	check0(n)	((n) > 0 ? (n) : 512)
  
  enum	from {
***************
*** 71,77 ****
  };
  
  struct	count {
! 	long long	c_off;		/* offset */
  	enum from	c_frm;		/* count from start (0) or end (1) */
  	int		c_typ;		/* 'b' 'c' 'l' */
  };
--- 84,90 ----
  };
  
  struct	count {
! 	LONGLONG	c_off;		/* offset */
  	enum from	c_frm;		/* count from start (0) or end (1) */
  	int		c_typ;		/* 'b' 'c' 'l' */
  };
***************
*** 143,151 ****
  	size_t	bufsize;
  	ssize_t	sz;
  
! 	buf = srealloc(NULL, bufsize = check0(sp->st_blksize));
! 	for (;;) {
! 		poll(NULL, 0, 1000);
  		while ((sz = read(fd, buf, bufsize)) > 0)
  			bwrite(1, buf, sz);
  	}
--- 156,170 ----
  	size_t	bufsize;
  	ssize_t	sz;
  
! #ifdef _MINIX
! 	buf = srealloc(NULL, bufsize = 512);
! #else
! 	buf = srealloc(NULL, bufsize = check0(sp->st_blksize));
! #endif
! 	for (;;) {
! #ifndef _MINIX      /* just block on read() */
! 		poll(NULL, 0, 1000);
! #endif
  		while ((sz = read(fd, buf, bufsize)) > 0)
  			bwrite(1, buf, sz);
  	}
***************
*** 160,166 ****
  	size_t	bufsize;
  	ssize_t	sz;
  
! 	buf = srealloc(NULL, bufsize = check0(sp->st_blksize));
  	while ((sz = read(fd, buf, bufsize)) > 0)
  		bwrite(1, buf, sz);
  	free(buf);
--- 179,189 ----
  	size_t	bufsize;
  	ssize_t	sz;
  
! #ifdef _MINIX
! 	buf = srealloc(NULL, bufsize = 512);
! #else
! 	buf = srealloc(NULL, bufsize = check0(sp->st_blksize));
! #endif
  	while ((sz = read(fd, buf, bufsize)) > 0)
  		bwrite(1, buf, sz);
  	free(buf);
***************
*** 170,178 ****
  static int
  endtail(struct count *cnt, int fd, struct stat *sp)
  {
! 	char	*buf = NULL, *map = MAP_FAILED;
! 	size_t	bufsize;
! 	long long	n, mapsize = 0;
  	long	i, j, k, lastnl;
  	int	partial, incomplete = 0;
  	char	*spc;
--- 193,205 ----
  static int
  endtail(struct count *cnt, int fd, struct stat *sp)
  {
! #ifdef _MINIX
! 	char	*buf = NULL;
! #else
! 	char	*buf = NULL, *map = MAP_FAILED;
! #endif
! 	size_t	bufsize;
! 	LONGLONG	n, mapsize = 0;
  	long	i, j, k, lastnl;
  	int	partial, incomplete = 0;
  	char	*spc;
***************
*** 186,191 ****
--- 213,219 ----
  		if (sp->st_size <= n || lseek(fd, -n, SEEK_END) != (off_t)-1)
  			return copy(fd, sp);
  	}
+ #ifndef _MINIX  /* no mmap() on Minix */
  	if (fflag == 0 && S_ISREG(sp->st_mode) && sp->st_size > 0) {
  #ifdef	RLIMIT_AS
  		struct rlimit	rs;
***************
*** 234,240 ****
  		spcsize = i + 1;
  		partial = 1;
  		lseek(fd, sp->st_size, SEEK_SET);
! 	} else {
  		long	alcmax;
  		int	chunk;
  rdin:
--- 262,270 ----
  		spcsize = i + 1;
  		partial = 1;
  		lseek(fd, sp->st_size, SEEK_SET);
! 	} else
! #endif
!     {
  		long	alcmax;
  		int	chunk;
  rdin:
***************
*** 257,262 ****
--- 287,296 ----
  			alcmax = n + 1;
  		else
  			alcmax = LONG_MAX - chunk;
+ #ifdef _MINIX /* seeking before start of file fails */
+         if (alcmax > sp->st_size)
+             alcmax = sp->st_size;
+ #endif
  		if (S_ISREG(sp->st_mode) || S_ISBLK(sp->st_mode))
  			lseek(fd, -alcmax, SEEK_END);
  		for (;;) {
***************
*** 339,346 ****
  out:
  	if (buf)
  		free(buf);
! 	if (map != MAP_FAILED)
! 		munmap(map, mapsize);
  	return 0;
  }
  
--- 373,382 ----
  out:
  	if (buf)
  		free(buf);
! #ifndef _MINIX
! 	if (map != MAP_FAILED)
! 		munmap(map, mapsize);
! #endif
  	return 0;
  }
  
***************
*** 351,359 ****
  	size_t	bufsize;
  	char	*p = NULL;
  	int	sz;
! 	long long	n;
! 
! 	buf = srealloc(NULL, bufsize = check0(sp->st_blksize));
  	if (cnt->c_off > 0) {
  		if (cnt->c_typ == 'l') {
  			n = cnt->c_off;
--- 387,399 ----
  	size_t	bufsize;
  	char	*p = NULL;
  	int	sz;
! 	LONGLONG	n;
! 
! #ifdef _MINIX
! 	buf = srealloc(NULL, bufsize = 512);
! #else
! 	buf = srealloc(NULL, bufsize = check0(sp->st_blksize));
! #endif
  	if (cnt->c_off > 0) {
  		if (cnt->c_typ == 'l') {
  			n = cnt->c_off;
***************
*** 390,396 ****
  getcount(const char *arg, int type)
  {
  	static struct count	cnt;
! 	long long	off;
  	char	*x;
  
  	cnt.c_frm = FR_END;
--- 430,436 ----
  getcount(const char *arg, int type)
  {
  	static struct count	cnt;
! 	LONGLONG	off;
  	char	*x;
  
  	cnt.c_frm = FR_END;
***************
*** 499,505 ****
  		fprintf(stderr, "%s: cannot stat stdout\n", progname);
  		exit(8);
  	}
! 	outblk = check0(st.st_blksize);
  	if (optind < argc) {
  		if ((fd = open(argv[optind], O_RDONLY)) < 0) {
  			fprintf(stderr, "%s: cannot open input\n", progname);
--- 539,549 ----
  		fprintf(stderr, "%s: cannot stat stdout\n", progname);
  		exit(8);
  	}
! #ifdef _MINIX
! 	outblk = 512;
! #else
! 	outblk = check0(st.st_blksize);
! #endif
  	if (optind < argc) {
  		if ((fd = open(argv[optind], O_RDONLY)) < 0) {
  			fprintf(stderr, "%s: cannot open input\n", progname);
Common subdirectories: heirloom-060122/tapecntl and heirloom-060122-patched/tapecntl
Only in heirloom-060122-patched/tapecntl: Makefile
diff -c heirloom-060122/tapecntl/tapecntl.c heirloom-060122-patched/tapecntl/tapecntl.c
*** heirloom-060122/tapecntl/tapecntl.c Sun Jan 22 18:55:40 2006
--- heirloom-060122-patched/tapecntl/tapecntl.c Fri Oct 20 14:04:55 2006
***************
*** 46,52 ****
  #if defined (__linux__) || defined (__sun) || defined (__FreeBSD__) \
  	|| defined (__hpux) || defined (_AIX) || defined (__NetBSD__) \
  	|| defined (__OpenBSD__) || defined (__DragonFly__) \
! 	|| defined (__APPLE__)
  #include <sys/ioctl.h>
  #include <sys/mtio.h>
  #else	/* SVR4.2MP */
--- 46,52 ----
  #if defined (__linux__) || defined (__sun) || defined (__FreeBSD__) \
  	|| defined (__hpux) || defined (_AIX) || defined (__NetBSD__) \
  	|| defined (__OpenBSD__) || defined (__DragonFly__) \
! 	|| defined (__APPLE__) || defined (_MINIX)
  #include <sys/ioctl.h>
  #include <sys/mtio.h>
  #else	/* SVR4.2MP */
***************
*** 579,585 ****
  	stats_density = md.default_density;
  }
  #elif defined (__FreeBSD__) || defined (__NetBSD__) || defined (__OpenBSD__) \
! 	|| defined (__DragonFly__) || defined (__APPLE__)
  static int
  process(int fd, enum oper op)
  {
--- 579,585 ----
  	stats_density = md.default_density;
  }
  #elif defined (__FreeBSD__) || defined (__NetBSD__) || defined (__OpenBSD__) \
! 	|| defined (__DragonFly__) || defined (__APPLE__) || defined (_MINIX)
  static int
  process(int fd, enum oper op)
  {
***************
*** 628,642 ****
--- 628,646 ----
  	case OP_OFFLINE:
  		m.mt_op = MTOFFL;
  		break;
+ #ifdef MTSETDNSTY
  	case OP_DENSITY:
  		m.mt_op = MTSETDNSTY;
  		m.mt_count = count;
  		break;
  		break;
+ #endif
+ #ifdef MTSETBSIZ
  	case OP_FIXED:
  		m.mt_op = MTSETBSIZ;
  		m.mt_count = count;
  		break;
+ #endif
  #ifdef	MTCOMP
  	case OP_COMPRESSION:
  		m.mt_op = MTCOMP;
***************
*** 656,663 ****
  		return -1;
  	stats_flags_ok = 1;
  	stats_flags = mg.mt_dsreg;
! 	stats_density = mg.mt_density;
! 	stats_recsiz = mg.mt_blksiz;
  	return 0;
  }
  #elif defined (__hpux) || defined (_AIX)
--- 660,669 ----
  		return -1;
  	stats_flags_ok = 1;
  	stats_flags = mg.mt_dsreg;
! #ifndef _MINIX
! 	stats_density = mg.mt_density;
! 	stats_recsiz = mg.mt_blksiz;
! #endif
  	return 0;
  }
  #elif defined (__hpux) || defined (_AIX)
Common subdirectories: heirloom-060122/tar and heirloom-060122-patched/tar
Only in heirloom-060122-patched/tar: Makefile
diff -c heirloom-060122/tar/tar.c heirloom-060122-patched/tar/tar.c
*** heirloom-060122/tar/tar.c Sun Jan 22 18:56:47 2006
--- heirloom-060122-patched/tar/tar.c Fri Oct 20 14:37:30 2006
***************
*** 70,76 ****
  #include "sigset.h"
  #include <string.h>
  #include <stdlib.h>
! #include <malloc.h>
  #include <libgen.h>
  #include <errno.h>
  #include <pwd.h>
--- 70,78 ----
  #include "sigset.h"
  #include <string.h>
  #include <stdlib.h>
! #ifndef _MINIX
! #include <malloc.h>
! #endif
  #include <libgen.h>
  #include <errno.h>
  #include <pwd.h>
***************
*** 84,90 ****
  
  #if defined (__linux__) || defined (__sun) || defined (__FreeBSD__) || \
  	defined (__hpux) || defined (_AIX) || defined (__NetBSD__) || \
! 	defined (__OpenBSD__) || defined (__DragonFly__) || defined (__APPLE__)
  #include <sys/mtio.h>
  #else	/* SVR4.2MP */
  #include <sys/scsi.h>
--- 86,93 ----
  
  #if defined (__linux__) || defined (__sun) || defined (__FreeBSD__) || \
  	defined (__hpux) || defined (_AIX) || defined (__NetBSD__) || \
! 	defined (__OpenBSD__) || defined (__DragonFly__) || defined (__APPLE__) || \
!     defined (_MINIX)
  #include <sys/mtio.h>
  #else	/* SVR4.2MP */
  #include <sys/scsi.h>
***************
*** 115,120 ****
--- 118,144 ----
  #endif
  #endif
  
+ #ifdef _MINIX
+ #define LONGLONG long
+ #define LONGLONG0 0L
+ #define NP_LL "l"
+ #define lchown chown
+ #define strtoll strtol
+ #define atoll atol
+ #define fseeko fseek
+ #ifndef S_IFSOCK
+ #define S_IFSOCK 0140000L
+ #endif
+ #define OUR_FILE_LIMIT 017777777777L
+ #define OUR_FILE_LIMIT_STR "2 GB"
+ #else
+ #define LONGLONG long long
+ #define LONGLONG0 0LL
+ #define NP_LL "ll"
+ #define OUR_FILE_LIMIT 077777777777LL
+ #define OUR_FILE_LIMIT_STR "8 GB"
+ #endif
+ 
  #if defined (__FreeBSD__) || defined (__NetBSD__) || defined (__OpenBSD__) || \
  	defined (__DragonFly__) || defined (__APPLE__)
  /*
***************
*** 217,226 ****
  } bflag;
  static int	gnuflag = -1;
  static int	oldflag = -1;
! static long long	volsize;
! static char	*Fflag, *Xflag;
! static int	term, chksum, wflag, recno, first, linkerrok;
! static int	freemem = 1;
  static int	nblock = 1;
  static struct stat	mtstat;
  static int	tapeblock = -1;
--- 241,250 ----
  } bflag;
  static int	gnuflag = -1;
  static int	oldflag = -1;
! static LONGLONG	volsize;
! static char	*Fflag, *Xflag;
! static int	term, chksum, wflag, recno, first, linkerrok;
! static int	freememory = 1;
  static int	nblock = 1;
  static struct stat	mtstat;
  static int	tapeblock = -1;
***************
*** 238,244 ****
  struct	magtape {
  	const char	*device;
  	long	block;
! 	long long	size;
  	int	nflag;
  };
  
--- 262,268 ----
  struct	magtape {
  	const char	*device;
  	long	block;
! 	LONGLONG	size;
  	int	nflag;
  };
  
***************
*** 281,288 ****
  static uid_t	myuid;
  static gid_t	mygid;
  
! static long long	rdtotal;
! static long long	wrtotal;
  
  static int	N = 300;
  
--- 305,312 ----
  static uid_t	myuid;
  static gid_t	mygid;
  
! static LONGLONG	rdtotal;
! static LONGLONG	wrtotal;
  
  static int	N = 300;
  
***************
*** 295,303 ****
  static void	tgetdir(struct stat *);
  static void	tgetnam(void);
  static void	tgetgnu(char **, long *);
! static void	tgetpax(struct stat *, long long *, long long *);
! static enum paxrec	tgetrec(char **, char **, char **);
! static long long	tgetval(const char *, int);
  static void	passtape(struct stat *);
  static void	putfile(const char *, const char *, int, int);
  static void	putreg(const char *, const char *, int, struct stat *);
--- 319,327 ----
  static void	tgetdir(struct stat *);
  static void	tgetnam(void);
  static void	tgetgnu(char **, long *);
! static void	tgetpax(struct stat *, LONGLONG *, LONGLONG *);
! static enum paxrec	tgetrec(char **, char **, char **);
! static LONGLONG	tgetval(const char *, int);
  static void	passtape(struct stat *);
  static void	putfile(const char *, const char *, int, int);
  static void	putreg(const char *, const char *, int, struct stat *);
***************
*** 305,311 ****
  static void	wrhdr(const char *, const char *, struct stat *);
  static void	wrpax(const char *, const char *, struct stat *);
  static void	addrec(char **, long *, long *,
! 			const char *, const char *, long long);
  static void	paxnam(struct header *, const char *);
  static void	doxtract(char *[]);
  static int	xtrreg(const char *, struct stat *);
--- 329,335 ----
  static void	wrhdr(const char *, const char *, struct stat *);
  static void	wrpax(const char *, const char *, struct stat *);
  static void	addrec(char **, long *, long *,
! 			const char *, const char *, LONGLONG);
  static void	paxnam(struct header *, const char *);
  static void	doxtract(char *[]);
  static int	xtrreg(const char *, struct stat *);
***************
*** 341,347 ****
  static int	mkname(struct header *, const char *);
  static char	*linkof(struct header *, char *);
  static int	mklink(struct header *, const char *, const char *);
! static void	blocksof(const char *, struct stat *, long long *, long long *);
  static void	tchown(int (*)(const char *, uid_t, gid_t),
  			const char *, uid_t, gid_t);
  static void	edone(int);
--- 365,371 ----
  static int	mkname(struct header *, const char *);
  static char	*linkof(struct header *, char *);
  static int	mklink(struct header *, const char *, const char *);
! static void	blocksof(const char *, struct stat *, LONGLONG *, LONGLONG *);
  static void	tchown(int (*)(const char *, uid_t, gid_t),
  			const char *, uid_t, gid_t);
  static void	edone(int);
***************
*** 805,811 ****
  static void
  tgetdir(register struct stat *sp)
  {
! 	long long	lval1, lval2;
  
  	readtape( (char *) &dblock);
  	if (dblock.dbuf.name[0] && gnuflag < 0)
--- 829,835 ----
  static void
  tgetdir(register struct stat *sp)
  {
! 	LONGLONG	lval1, lval2;
  
  	readtape( (char *) &dblock);
  	if (dblock.dbuf.name[0] && gnuflag < 0)
***************
*** 845,853 ****
  			done(2);
  	}
  	if ((paxrec & PR_SUN_DEVMAJOR) == 0)
! 		sscanf(dblock.dbuf.devmajor, "%llo", &lval1);
! 	if ((paxrec & PR_SUN_DEVMINOR) == 0)
! 		sscanf(dblock.dbuf.devminor, "%llo", &lval2);
  	sp->st_rdev = makedev(lval1, lval2);
  	if (tfile != NULL) {
  		if (strchr(hbuf.name, '\n') == NULL) {
--- 869,877 ----
  			done(2);
  	}
  	if ((paxrec & PR_SUN_DEVMAJOR) == 0)
! 		sscanf(dblock.dbuf.devmajor, "%" NP_LL "o", &lval1);
! 	if ((paxrec & PR_SUN_DEVMINOR) == 0)
! 		sscanf(dblock.dbuf.devminor, "%" NP_LL "o", &lval2);
  	sp->st_rdev = makedev(lval1, lval2);
  	if (tfile != NULL) {
  		if (strchr(hbuf.name, '\n') == NULL) {
***************
*** 913,919 ****
  tgetgnu(char **np, long *sp)
  {
  	char	buf[TBLOCK];
! 	long long	blocks;
  	long	n, bytes;
  
  	n = tgetval(dblock.dbuf.size, sizeof dblock.dbuf.size);
--- 937,943 ----
  tgetgnu(char **np, long *sp)
  {
  	char	buf[TBLOCK];
! 	LONGLONG	blocks;
  	long	n, bytes;
  
  	n = tgetval(dblock.dbuf.size, sizeof dblock.dbuf.size);
***************
*** 933,944 ****
  }
  
  static void
! tgetpax(struct stat *sp, long long *devmajor, long long *devminor)
  {
  	char	*keyword, *value;
  	char	buf[TBLOCK];
  	char	*block, *bp;
! 	long long	n, blocks, bytes;
  	enum paxrec	pr;
  
  	n = tgetval(dblock.dbuf.size, sizeof dblock.dbuf.size);
--- 957,968 ----
  }
  
  static void
! tgetpax(struct stat *sp, LONGLONG *devmajor, LONGLONG *devminor)
  {
  	char	*keyword, *value;
  	char	buf[TBLOCK];
  	char	*block, *bp;
! 	LONGLONG	n, blocks, bytes;
  	enum paxrec	pr;
  
  	n = tgetval(dblock.dbuf.size, sizeof dblock.dbuf.size);
***************
*** 1060,1069 ****
  	return pr;
  }
  
! static long long
! tgetval(const char *s, int k)
! {
! 	long long	n = 0;
  	int	i, h = 0;
  
  	if (gnuflag>0 && s[0] & 0200) {
--- 1084,1093 ----
  	return pr;
  }
  
! static LONGLONG
! tgetval(const char *s, int k)
! {
! 	LONGLONG	n = 0;
  	int	i, h = 0;
  
  	if (gnuflag>0 && s[0] & 0200) {
***************
*** 1087,1093 ****
  static void
  passtape(register struct stat *sp)
  {
! 	long long blocks;
  	char buf[TBLOCK];
  
  	switch (dblock.dbuf.linkflag) {
--- 1111,1117 ----
  static void
  passtape(register struct stat *sp)
  {
! 	LONGLONG blocks;
  	char buf[TBLOCK];
  
  	switch (dblock.dbuf.linkflag) {
***************
*** 1110,1116 ****
  			if (((mtstat.st_mode&S_IFMT) == S_IFBLK ||
  					(mtstat.st_mode&S_IFMT) == S_IFREG) &&
  					recno >= nblock && blocks >= nblock) {
! 				long long	lpos;
  				lpos = (blocks/nblock)*nblock*TBLOCK;
  				if ((volsize == 0 || rdtotal+lpos < volsize) &&
  						lseek(mt, lpos, SEEK_CUR)
--- 1134,1140 ----
  			if (((mtstat.st_mode&S_IFMT) == S_IFBLK ||
  					(mtstat.st_mode&S_IFMT) == S_IFREG) &&
  					recno >= nblock && blocks >= nblock) {
! 				LONGLONG	lpos;
  				lpos = (blocks/nblock)*nblock*TBLOCK;
  				if ((volsize == 0 || rdtotal+lpos < volsize) &&
  						lseek(mt, lpos, SEEK_CUR)
***************
*** 1151,1159 ****
  		return;
  	}
  	if ((stbuf.st_mode&S_IFMT) == S_IFREG &&
! 			stbuf.st_size > 077777777777LL) {
! 		if (gnuflag > 0 || oldflag > 0) {
! 			fprintf(stderr, "%s: %s too large (limit 8 GB)\n",
  					progname, longname);
  			return;
  		}
--- 1175,1183 ----
  		return;
  	}
  	if ((stbuf.st_mode&S_IFMT) == S_IFREG &&
! 			stbuf.st_size > OUR_FILE_LIMIT) {
! 		if (gnuflag > 0 || oldflag > 0) {
! 			fprintf(stderr, "%s: %s too large (limit " OUR_FILE_LIMIT_STR ")\n",
  					progname, longname);
  			return;
  		}
***************
*** 1267,1276 ****
  			int	namelen = strlen(longname);
  			ip = calloc(1, sizeof *ip);
  			if (ip == 0 || (ip->pathname=malloc(namelen+1)) == 0) {
! 				if (freemem) {
! 					write(2, "Out of memory. "
! 						"Link information lost\n", 37);
! 					freemem = 0;
  					edone(1);
  				}
  			} else {
--- 1291,1300 ----
  			int	namelen = strlen(longname);
  			ip = calloc(1, sizeof *ip);
  			if (ip == 0 || (ip->pathname=malloc(namelen+1)) == 0) {
! 				if (freememory) {
! 					write(2, "Out of memory. "
! 						"Link information lost\n", 37);
! 					freememory = 0;
  					edone(1);
  				}
  			} else {
***************
*** 1332,1338 ****
  static void
  putreg(const char *longname, const char *shortname, int infile, struct stat *sp)
  {
! 	long long blocks;
  	char buf[TBLOCK];
  	int i;
  
--- 1356,1362 ----
  static void
  putreg(const char *longname, const char *shortname, int infile, struct stat *sp)
  {
! 	LONGLONG blocks;
  	char buf[TBLOCK];
  	int i;
  
***************
*** 1389,1411 ****
  static void
  wrhdr(const char *longname, const char *symblink, struct stat *sp)
  {
! 	long long blocks;
  
  	blocks = (sp->st_mode&S_IFMT) == S_IFREG ?
  			(sp->st_size + (TBLOCK-1)) / TBLOCK : 0;
  	if (vflag) {
  		if (nflag)
! 			fprintf(stderr, "seek = %lldK\t",
  					(wrtotal+recno*2+1023)/1024);
  		fprintf(stderr, "a %s%s ", longname,
  				(sp->st_mode&S_IFMT) == S_IFDIR ? "/" : "");
  		if (symblink)
  			fprintf(stderr, "symbolic link to %s\n", symblink);
  		else if (nflag)
! 			fprintf(stderr, "%lldK\n",
! 					blocks&01?blocks|02:blocks>>1);
! 		else
! 			fprintf(stderr, "%lld tape blocks\n", blocks);
  	}
  	sprintf(dblock.dbuf.chksum, "%7.7o", checksum(0));
  	if (paxrec != PR_NONE && oldflag <= 0 && gnuflag <= 0)
--- 1413,1435 ----
  static void
  wrhdr(const char *longname, const char *symblink, struct stat *sp)
  {
! 	LONGLONG blocks;
  
  	blocks = (sp->st_mode&S_IFMT) == S_IFREG ?
  			(sp->st_size + (TBLOCK-1)) / TBLOCK : 0;
  	if (vflag) {
  		if (nflag)
! 			fprintf(stderr, "seek = %" NP_LL "dK\t",
  					(wrtotal+recno*2+1023)/1024);
  		fprintf(stderr, "a %s%s ", longname,
  				(sp->st_mode&S_IFMT) == S_IFDIR ? "/" : "");
  		if (symblink)
  			fprintf(stderr, "symbolic link to %s\n", symblink);
  		else if (nflag)
! 			fprintf(stderr, "%" NP_LL "dK\n",
! 					blocks&01?blocks|02:blocks>>1);
! 		else
! 			fprintf(stderr, "%" NP_LL "d tape blocks\n", blocks);
  	}
  	sprintf(dblock.dbuf.chksum, "%7.7o", checksum(0));
  	if (paxrec != PR_NONE && oldflag <= 0 && gnuflag <= 0)
***************
*** 1419,1425 ****
  	char	oblock[TBLOCK];
  	char	*pdata = NULL;
  	long	psize = 0, pcur = 0;
! 	long long	blocks, i;
  
  	memcpy(oblock, (char *)&dblock, TBLOCK);
  	memset((char *)&dblock, 0, TBLOCK);
--- 1443,1449 ----
  	char	oblock[TBLOCK];
  	char	*pdata = NULL;
  	long	psize = 0, pcur = 0;
! 	LONGLONG	blocks, i;
  
  	memcpy(oblock, (char *)&dblock, TBLOCK);
  	memset((char *)&dblock, 0, TBLOCK);
***************
*** 1466,1478 ****
  
  static void
  addrec(char **pdata, long *psize, long *pcur,
! 		const char *keyword, const char *sval, long long lval)
  {
  	char	dval[25], xval[25];
  	long	od, d, r;
  
  	if (sval == 0) {
! 		sprintf(xval, "%lld", lval);
  		sval = xval;
  	}
  	r = strlen(keyword) + strlen(sval) + 3;
--- 1490,1502 ----
  
  static void
  addrec(char **pdata, long *psize, long *pcur,
! 		const char *keyword, const char *sval, LONGLONG lval)
  {
  	char	dval[25], xval[25];
  	long	od, d, r;
  
  	if (sval == 0) {
! 		sprintf(xval, "%" NP_LL "d", lval);
  		sval = xval;
  	}
  	r = strlen(keyword) + strlen(sval) + 3;
***************
*** 1607,1613 ****
  static int
  xtrreg(const char *name, struct stat *sp)
  {
! 	long long blocks, bytes;
  	char buf[TBLOCK];
  	int ofile;
  
--- 1631,1637 ----
  static int
  xtrreg(const char *name, struct stat *sp)
  {
! 	LONGLONG blocks, bytes;
  	char buf[TBLOCK];
  	int ofile;
  
***************
*** 1693,1703 ****
  }
  
  static void
! blocksof(const char *name, struct stat *sp, long long *blocks, long long *bytes)
  {
  	*blocks = ((*bytes = sp->st_size) + TBLOCK-1)/TBLOCK;
  	if (vflag)
! 		fprintf(stderr, "x %s, %lld bytes, ""%lld%s\n",
  			name, *bytes,
  			nflag ? (*blocks&01?*blocks|02:*blocks)>>1 : *blocks,
  			nflag ? "K" : " tape blocks");
--- 1717,1727 ----
  }
  
  static void
! blocksof(const char *name, struct stat *sp, LONGLONG *blocks, LONGLONG *bytes)
  {
  	*blocks = ((*bytes = sp->st_size) + TBLOCK-1)/TBLOCK;
  	if (vflag)
! 		fprintf(stderr, "x %s, %" NP_LL "d bytes, ""%" NP_LL "d%s\n",
  			name, *bytes,
  			nflag ? (*blocks&01?*blocks|02:*blocks)>>1 : *blocks,
  			nflag ? "K" : " tape blocks");
***************
*** 1769,1777 ****
  
  	pmode(st, linkflag);
  	printf("%3ld/%-3ld", (long)st->st_uid, (long)st->st_gid);
! 	printf(" %6lld", (long long)st->st_size);
! 	tp = localtime(&st->st_mtime);
! 	strftime(buf, sizeof buf, "%b %e %H:%M %Y", tp);
  	printf(" %17.17s ", buf);
  }
  
--- 1793,1805 ----
  
  	pmode(st, linkflag);
  	printf("%3ld/%-3ld", (long)st->st_uid, (long)st->st_gid);
! 	printf(" %6" NP_LL "d", (LONGLONG)st->st_size);
! 	tp = localtime(&st->st_mtime);
! #ifdef _MINIX
! 	strftime(buf, sizeof buf, "%b %d %H:%M %Y", tp);
! #else
! 	strftime(buf, sizeof buf, "%b %e %H:%M %Y", tp);
! #endif
  	printf(" %17.17s ", buf);
  }
  
***************
*** 1889,1896 ****
  				sp->st_uid : (paxrec |= PR_UID, 60001)));
  	sprintf(dblock.dbuf.gid, "%7.7lo", (long)(sp->st_gid <= 07777777 ?
  				sp->st_gid : (paxrec |= PR_GID, 60001)));
! 	sprintf(dblock.dbuf.size, "%11.11llo", (sp->st_mode&S_IFMT)==S_IFREG ?
! 			(long long)sp->st_size&077777777777LL : 0LL);
  	sprintf(dblock.dbuf.mtime, "%11.11lo", (long)sp->st_mtime);
  	if (oldflag <= 0) {
  		strcpy(dblock.dbuf.magic, gnuflag>0 ? "ustar  " : "ustar");
--- 1917,1924 ----
  				sp->st_uid : (paxrec |= PR_UID, 60001)));
  	sprintf(dblock.dbuf.gid, "%7.7lo", (long)(sp->st_gid <= 07777777 ?
  				sp->st_gid : (paxrec |= PR_GID, 60001)));
! 	sprintf(dblock.dbuf.size, "%11.11" NP_LL "o", (sp->st_mode&S_IFMT)==S_IFREG ?
! 			(LONGLONG)sp->st_size&OUR_FILE_LIMIT : LONGLONG0);
  	sprintf(dblock.dbuf.mtime, "%11.11lo", (long)sp->st_mtime);
  	if (oldflag <= 0) {
  		strcpy(dblock.dbuf.magic, gnuflag>0 ? "ustar  " : "ustar");
***************
*** 2156,2162 ****
  	if (tapeblock > 0 && rew) {
  #if defined (__linux__) || defined (__sun) || defined (__FreeBSD__) || \
  	defined (__hpux) || defined (_AIX) || defined (__NetBSD__) || \
! 	defined (__OpenBSD__) || defined (__DragonFly__) || defined (__APPLE__)
  		struct mtop	mo;
  		mo.mt_op = n > 0 ? MTFSR : MTBSR;
  		mo.mt_count = (n > 0 ? n : -n) / tapeblock;
--- 2184,2191 ----
  	if (tapeblock > 0 && rew) {
  #if defined (__linux__) || defined (__sun) || defined (__FreeBSD__) || \
  	defined (__hpux) || defined (_AIX) || defined (__NetBSD__) || \
! 	defined (__OpenBSD__) || defined (__DragonFly__) || defined (__APPLE__) || \
!     defined (_MINIX)
  		struct mtop	mo;
  		mo.mt_op = n > 0 ? MTFSR : MTBSR;
  		mo.mt_count = (n > 0 ? n : -n) / tapeblock;
***************
*** 2679,2685 ****
  		if (ioctl(mt, MTIOCGET, &mg) == 0)
  			tapeblock = mg.mt_blksiz;
  	}
! #elif defined (__hpux) || defined (_AIX)
  #else	/* SVR4.2MP */
  	if ((mtstat.st_mode&S_IFMT) == S_IFCHR) {
  		struct blklen	bl;
--- 2708,2714 ----
  		if (ioctl(mt, MTIOCGET, &mg) == 0)
  			tapeblock = mg.mt_blksiz;
  	}
! #elif defined (__hpux) || defined (_AIX) || defined (_MINIX)
  #else	/* SVR4.2MP */
  	if ((mtstat.st_mode&S_IFMT) == S_IFCHR) {
  		struct blklen	bl;
***************
*** 2703,2709 ****
  			NBLOCK = tapeblock;
  #if defined (__linux__) || defined (__sun) || defined (__FreeBSD__) || \
  	defined (__NetBSD__) || defined (__OpenBSD__) || \
! 	defined (__DragonFly__) || defined (__APPLE__)
  		if (bflag == 0 && cflag && twice == 0) {
  			if (nblock == 1) {
  				if ((nblock = tapeblock) > NBLOCK)
--- 2732,2738 ----
  			NBLOCK = tapeblock;
  #if defined (__linux__) || defined (__sun) || defined (__FreeBSD__) || \
  	defined (__NetBSD__) || defined (__OpenBSD__) || \
! 	defined (__DragonFly__) || defined (__APPLE__) || defined (_MINIX)
  		if (bflag == 0 && cflag && twice == 0) {
  			if (nblock == 1) {
  				if ((nblock = tapeblock) > NBLOCK)
***************
*** 2716,2727 ****
--- 2745,2760 ----
  	__DragonFly__ || __APPLE__ */
  	}
  	if (twice == 0 && bflag == 0 && tapeblock < 0) {
+ #ifdef _MINIX
+         nblock = 1;
+ #else
  		if ((nblock = mtstat.st_blksize >> 9) > NBLOCK)
  			nblock = NBLOCK;
  		else if (nblock <= 0)
  			nblock = 1;
  		else if ((mtstat.st_mode&S_IFMT) != S_IFCHR)
  			bflag = B_AUTO;
+ #endif
  	}
  	twice = 1;
  	if (nblock > NBLOCK)
***************
*** 3088,3096 ****
  sequence(void)
  {
  	static char	buf[25];
! 	static long long	d;
! 
! 	sprintf(buf, "%10.10lld", ++d);
  	return buf;
  }
  
--- 3121,3129 ----
  sequence(void)
  {
  	static char	buf[25];
! 	static LONGLONG	d;
! 
! 	sprintf(buf, "%10.10" NP_LL "d", ++d);
  	return buf;
  }
  
Common subdirectories: heirloom-060122/tcopy and heirloom-060122-patched/tcopy
Only in heirloom-060122-patched/tcopy: Makefile
diff -c heirloom-060122/tcopy/tcopy.c heirloom-060122-patched/tcopy/tcopy.c
*** heirloom-060122/tcopy/tcopy.c Sun Jan 22 18:57:13 2006
--- heirloom-060122-patched/tcopy/tcopy.c Fri Oct 20 14:49:17 2006
***************
*** 65,83 ****
  #include <sys/ioctl.h>
  #if defined (__linux__) || defined (__sun) || defined (__FreeBSD__) || \
  	defined (__hpux) || defined (_AIX) || defined (__NetBSD__) || \
! 	defined (__OpenBSD__) || defined (__DragonFly__) || defined (__APPLE__)
  #include <sys/mtio.h>
  #else	/* SVR4.2MP */
  #include <sys/tape.h>
  #endif	/* SVR4.2MP */
  
  #define SIZE	(256 * 1024)
  
  static char buff[SIZE];
  static int filen=1;
! static long long count, lcount;
! static int nfile;
! static long long size, tsize;
  static int ln;
  static char *inf, *outf;
  static int copy;
--- 65,92 ----
  #include <sys/ioctl.h>
  #if defined (__linux__) || defined (__sun) || defined (__FreeBSD__) || \
  	defined (__hpux) || defined (_AIX) || defined (__NetBSD__) || \
! 	defined (__OpenBSD__) || defined (__DragonFly__) || defined (__APPLE__) || \
!     defined (_MINIX)
  #include <sys/mtio.h>
  #else	/* SVR4.2MP */
  #include <sys/tape.h>
  #endif	/* SVR4.2MP */
  
+ #ifdef _MINIX
+ #define LONGLONG long
+ #define P_LLD "%ld"
+ #else
+ #define LONGLONG long long
+ #define P_LLD "%lld"
+ #endif
+ 
  #define SIZE	(256 * 1024)
  
  static char buff[SIZE];
  static int filen=1;
! static LONGLONG count, lcount;
! static int nfile;
! static LONGLONG size, tsize;
  static int ln;
  static char *inf, *outf;
  static int copy;
***************
*** 131,141 ****
  		    if (n != ln) {
  			if (ln > 0)
  			    if (count - lcount > 1)
! 				printf("file %d: records %lld to %lld: "
  						"size %d\n",
  					filen, lcount, count-1, ln);
  			    else
! 				printf("file %d: record %lld: size %d\n",
  					filen, lcount, ln);
  			ln = n;
  			lcount = count;
--- 140,150 ----
  		    if (n != ln) {
  			if (ln > 0)
  			    if (count - lcount > 1)
! 				printf("file %d: records " P_LLD " to " P_LLD ": "
  						"size %d\n",
  					filen, lcount, count-1, ln);
  			    else
! 				printf("file %d: record " P_LLD ": size %d\n",
  					filen, lcount, ln);
  			ln = n;
  			lcount = count;
***************
*** 143,149 ****
  		}
  		else if (n < 0) {
  			fprintf(stderr, "file %d: read error "
! 				"after %lld records: %lld bytes\n",
  				filen, count-1, size);
  			status = 4;
  		}
--- 152,158 ----
  		}
  		else if (n < 0) {
  			fprintf(stderr, "file %d: read error "
! 				"after " P_LLD " records: " P_LLD " bytes\n",
  				filen, count-1, size);
  			status = 4;
  		}
***************
*** 154,171 ****
  			}
  			if (ln > 0)
  			    if (count - lcount > 1)
! 				printf("file %d: records %lld to %lld: "
  						"size %d\n",
  					filen, lcount, count-1, ln);
  			    else
! 				printf("file %d: record %lld: size %d\n",
! 					filen, lcount, ln);
! 			printf("file %d: eof after %lld records: %lld bytes\n",
  				filen, count-1, size);
  			if (copy) {
  #if defined (__linux__) || defined (__sun) || defined (__FreeBSD__) || \
  	defined (__hpux) || defined (_AIX) || defined (__NetBSD__) || \
! 	defined (__OpenBSD__) || defined (__DragonFly__) || defined (__APPLE__)
  				struct mtop op;
  				op.mt_op = MTWEOF;
  				op.mt_count = 1;
--- 163,181 ----
  			}
  			if (ln > 0)
  			    if (count - lcount > 1)
! 				printf("file %d: records " P_LLD " to " P_LLD ": "
  						"size %d\n",
  					filen, lcount, count-1, ln);
  			    else
! 				printf("file %d: record " P_LLD ": size %d\n",
! 					filen, lcount, ln);
! 			printf("file %d: eof after " P_LLD " records: " P_LLD " bytes\n",
  				filen, count-1, size);
  			if (copy) {
  #if defined (__linux__) || defined (__sun) || defined (__FreeBSD__) || \
  	defined (__hpux) || defined (_AIX) || defined (__NetBSD__) || \
! 	defined (__OpenBSD__) || defined (__DragonFly__) || defined (__APPLE__) || \
!     defined (_MINIX)
  				struct mtop op;
  				op.mt_op = MTWEOF;
  				op.mt_count = 1;
***************
*** 190,196 ****
  	}
  	if (copy)
  		(void) close(outp);
! 	printf("total length: %lld bytes\n", tsize);
  	return status;
  }
  
--- 200,206 ----
  	}
  	if (copy)
  		(void) close(outp);
! 	printf("total length: " P_LLD " bytes\n", tsize);
  	return status;
  }
  
***************
*** 202,213 ****
  		--count;
  	if (count)
  		if (count > lcount)
! 			printf("file %d: records %lld to %lld: size %d\n",
! 				filen, lcount, count, ln);
! 		else
! 			printf("file %d: record %lld: size %d\n",
! 				filen, lcount, ln);
! 	printf("rubout at file %d: record %lld\n", filen, count);
! 	printf("total length: %lld bytes\n", tsize+size);
  	exit(1);
  }
--- 212,223 ----
  		--count;
  	if (count)
  		if (count > lcount)
! 			printf("file %d: records " P_LLD " to " P_LLD ": size %d\n",
! 				filen, lcount, count, ln);
! 		else
! 			printf("file %d: record " P_LLD ": size %d\n",
! 				filen, lcount, ln);
! 	printf("rubout at file %d: record " P_LLD "\n", filen, count);
! 	printf("total length: " P_LLD " bytes\n", tsize+size);
  	exit(1);
  }
Common subdirectories: heirloom-060122/tee and heirloom-060122-patched/tee
Only in heirloom-060122-patched/tee: Makefile
diff -c heirloom-060122/tee/tee.c heirloom-060122-patched/tee/tee.c
*** heirloom-060122/tee/tee.c Sun May 29 12:55:45 2005
--- heirloom-060122-patched/tee/tee.c Fri Oct 20 16:08:25 2006
***************
*** 113,120 ****
  		errcnt |= 010;
  		return;
  	}
! 	bufsize = totty ? 512 : st.st_blksize < 512 ? 512 :
! 		st.st_blksize > 32768 ? 32768 : st.st_blksize;
  	buf = smalloc(bufsize);
  	while ((rsz = read(0, buf, bufsize)) > 0)
  		for (f = f0; f; f = f->f_nxt)
--- 113,124 ----
  		errcnt |= 010;
  		return;
  	}
! #ifdef _MINIX
!     bufsize = 512;
! #else
! 	bufsize = totty ? 512 : st.st_blksize < 512 ? 512 :
! 		st.st_blksize > 32768 ? 32768 : st.st_blksize;
! #endif
  	buf = smalloc(bufsize);
  	while ((rsz = read(0, buf, bufsize)) > 0)
  		for (f = f0; f; f = f->f_nxt)
Common subdirectories: heirloom-060122/test and heirloom-060122-patched/test
Only in heirloom-060122-patched/test: Makefile
diff -c heirloom-060122/test/defs.h heirloom-060122-patched/test/defs.h
*** heirloom-060122/test/defs.h Sat Jul  2 12:36:39 2005
--- heirloom-060122-patched/test/defs.h Fri Oct 20 16:11:14 2006
***************
*** 32,37 ****
--- 32,43 ----
  #include <wchar.h>
  #include <unistd.h>
  
+ #ifdef _MINIX
+ #define LONGLONG long
+ #else
+ #define LONGLONG long long
+ #endif
+ 
  #if defined (__GLIBC__) && defined (_IO_getc_unlocked)
  #undef	putchar
  #define	putchar(c)	_IO_putc_unlocked(c, stdout)
***************
*** 73,79 ****
  #define	prp()		fputs("test: ", stdout)
  #define	prs(s)		fputs(s, stdout)
  #define	sigchk()
! extern long long	stoifll(const char *);
  
  extern int	mb_cur_max;
  #define	nextc(wc, sp)	(mb_cur_max > 1 && *(sp) & 0200 ? \
--- 79,85 ----
  #define	prp()		fputs("test: ", stdout)
  #define	prs(s)		fputs(s, stdout)
  #define	sigchk()
! extern LONGLONG	stoifll(const char *);
  
  extern int	mb_cur_max;
  #define	nextc(wc, sp)	(mb_cur_max > 1 && *(sp) & 0200 ? \
diff -c heirloom-060122/test/helper.c heirloom-060122-patched/test/helper.c
*** heirloom-060122/test/helper.c Wed Jun 29 18:39:45 2005
--- heirloom-060122-patched/test/helper.c Fri Oct 20 16:11:58 2006
***************
*** 82,92 ****
  	return(errno == EACCES ? 3 : 1);
  }
  
! long long
  stoifll(const char *icp)
  {
  	const unsigned char	*cp;
! 	long long	r = 0;
  	int		sign = 1;
  	unsigned char	c;
  
--- 82,92 ----
  	return(errno == EACCES ? 3 : 1);
  }
  
! LONGLONG
  stoifll(const char *icp)
  {
  	const unsigned char	*cp;
! 	LONGLONG	r = 0;
  	int		sign = 1;
  	unsigned char	c;
  
diff -c heirloom-060122/test/test.c heirloom-060122-patched/test/test.c
*** heirloom-060122/test/test.c Wed Jun 29 18:39:27 2005
--- heirloom-060122-patched/test/test.c Fri Oct 20 16:17:00 2006
***************
*** 43,48 ****
--- 43,56 ----
  #include <sys/types.h>
  #include <sys/stat.h>
  
+ #ifdef _MINIX
+ #ifndef S_IFSOCK
+ #define S_IFSOCK 0140000
+ #endif
+ /* cc will complain a lot about incompatible pointers for several function,
+  * e.g. when unsigned char * is passed to strcmp. just ignore the */
+ #endif
+ 
  static int	ap, ac;
  static unsigned char **av;
  
***************
*** 146,152 ****
  	int	p1;
  	register unsigned char	*a;
  	unsigned char	*p2;
! 	long long	ll_1, ll_2;
  
  	a = nxtarg(0);
  	if (eq(a, "("))
--- 154,160 ----
  	int	p1;
  	register unsigned char	*a;
  	unsigned char	*p2;
! 	LONGLONG	ll_1, ll_2;
  
  	a = nxtarg(0);
  	if (eq(a, "("))
Common subdirectories: heirloom-060122/time and heirloom-060122-patched/time
Only in heirloom-060122-patched/time: Makefile
Common subdirectories: heirloom-060122/touch and heirloom-060122-patched/touch
Only in heirloom-060122-patched/touch: Makefile
Common subdirectories: heirloom-060122/tr and heirloom-060122-patched/tr
Only in heirloom-060122-patched/tr: Makefile
Common subdirectories: heirloom-060122/true and heirloom-060122-patched/true
Only in heirloom-060122-patched/true: Makefile
Common subdirectories: heirloom-060122/tsort and heirloom-060122-patched/tsort
Only in heirloom-060122-patched/tsort: Makefile
Common subdirectories: heirloom-060122/tty and heirloom-060122-patched/tty
Only in heirloom-060122-patched/tty: Makefile
diff -c heirloom-060122/tty/tty.c heirloom-060122-patched/tty/tty.c
*** heirloom-060122/tty/tty.c Sun Jan 22 18:57:37 2006
--- heirloom-060122-patched/tty/tty.c Fri Oct 20 16:22:42 2006
***************
*** 40,46 ****
  #include <stdlib.h>
  #if !defined (__linux) && !defined (__FreeBSD__) && !defined (__hpux) && \
  	!defined (_AIX) && !defined (__NetBSD__) && !defined (__OpenBSD__) && \
! 	!defined (__DragonFly__) && !defined (__APPLE__)
  #include <sys/stermio.h>
  #endif	/* !__linux__, !__FreeBSD__, !__hpux, !_AIX, !__NetBSD__,
  	   !__OpenBSD__, !__DragonFly__, !__APPLE__ */
--- 40,46 ----
  #include <stdlib.h>
  #if !defined (__linux) && !defined (__FreeBSD__) && !defined (__hpux) && \
  	!defined (_AIX) && !defined (__NetBSD__) && !defined (__OpenBSD__) && \
! 	!defined (__DragonFly__) && !defined (__APPLE__) && !defined (_MINIX)
  #include <sys/stermio.h>
  #endif	/* !__linux__, !__FreeBSD__, !__hpux, !_AIX, !__NetBSD__,
  	   !__OpenBSD__, !__DragonFly__, !__APPLE__ */
Common subdirectories: heirloom-060122/ul and heirloom-060122-patched/ul
Only in heirloom-060122-patched/ul: Makefile
Common subdirectories: heirloom-060122/uname and heirloom-060122-patched/uname
Only in heirloom-060122-patched/uname: Makefile
diff -c heirloom-060122/uname/uname.c heirloom-060122-patched/uname/uname.c
*** heirloom-060122/uname/uname.c Sun May 29 12:55:46 2005
--- heirloom-060122-patched/uname/uname.c Fri Oct 20 16:34:20 2006
***************
*** 42,48 ****
  #include	<errno.h>
  #include	<libgen.h>
  
! #if defined (__i386__)
  #define	PROCESSOR	"ia32"
  #elif defined (__x86_64__)
  #define	PROCESSOR	"x86_64"
--- 42,48 ----
  #include	<errno.h>
  #include	<libgen.h>
  
! #if defined (__i386__) || defined (__i386)
  #define	PROCESSOR	"ia32"
  #elif defined (__x86_64__)
  #define	PROCESSOR	"x86_64"
***************
*** 70,75 ****
--- 70,90 ----
  static char	*progname;		/* argv[0] to main() */
  static char	*system_name;		/* new system name */
  
+ #ifdef _MINIX
+ #include <fcntl.h>
+ 
+ int sethostname(const char *name, size_t len) {
+     int fd;
+ 
+     fd = open("/etc/hostname.file", O_WRONLY);
+     if (fd < 0) return -1;
+     write(fd, name, len);
+     write(fd, "\n", 1);
+     close(fd);
+     return 0;
+ }
+ #endif
+ 
  static void
  usage(void)
  {
Common subdirectories: heirloom-060122/uniq and heirloom-060122-patched/uniq
Only in heirloom-060122-patched/uniq: Makefile
Common subdirectories: heirloom-060122/units and heirloom-060122-patched/units
Only in heirloom-060122-patched/units: Makefile
diff -c heirloom-060122/units/units.c heirloom-060122-patched/units/units.c
*** heirloom-060122/units/units.c Sun May 29 12:55:46 2005
--- heirloom-060122-patched/units/units.c Fri Oct 20 16:37:59 2006
***************
*** 47,52 ****
--- 47,56 ----
  #include "sigset.h"
  #include <limits.h>
  
+ #ifndef LINE_MAX
+ #define LINE_MAX 2048   /* POSIX 2 LINE_MAX */
+ #endif
+ 
  #ifdef	__GLIBC__
  #ifdef	_IO_getc_unlocked
  #undef	getc
Common subdirectories: heirloom-060122/users and heirloom-060122-patched/users
Only in heirloom-060122-patched/users: Makefile
diff -c heirloom-060122/users/users.c heirloom-060122-patched/users/users.c
*** heirloom-060122/users/users.c Sun May 29 12:55:46 2005
--- heirloom-060122-patched/users/users.c Fri Oct 20 16:57:43 2006
***************
*** 40,57 ****
  #include <stdio.h>
  #include <pwd.h>
  #include <unistd.h>
! #include <utmpx.h>
  #include <errno.h>
  
  int
  main(int argc, char **argv)
  {
! 	struct utmpx	*u;
  	int	count = 0;
  
  	if (argc > 1 && argv[1][0]=='-' && argv[1][1]=='-' && argv[1][2]=='\0')
  		argc--, argv++;
  	if (argc == 2) {
  		int	fd;
  
  		if ((fd = open(argv[1], O_RDONLY)) < 0) {
--- 40,71 ----
  #include <stdio.h>
  #include <pwd.h>
  #include <unistd.h>
! #ifdef _MINIX
! #include <utmp.h>
! #include <minix/paths.h>
! #else
! #include <utmpx.h>
! #endif
  #include <errno.h>
  
  int
  main(int argc, char **argv)
  {
! #ifdef _MINIX
!     struct utmp ut;
!     char *path_utmp = _PATH_UTMP;
!     int fd, nbytes;
! #else
! 	struct utmpx	*u;
! #endif
  	int	count = 0;
  
  	if (argc > 1 && argv[1][0]=='-' && argv[1][1]=='-' && argv[1][2]=='\0')
  		argc--, argv++;
  	if (argc == 2) {
+ #ifdef _MINIX
+         path_utmp = argv[1];
+ #else
  		int	fd;
  
  		if ((fd = open(argv[1], O_RDONLY)) < 0) {
***************
*** 66,72 ****
  		perror(argv[1]);
  		return 1;
  #endif	/* __hpux, _AIX */
! 	}
  	while ((u = getutxent()) != NULL) {
  		if (u->ut_type == USER_PROCESS) {
  			if (count++)
--- 80,105 ----
  		perror(argv[1]);
  		return 1;
  #endif	/* __hpux, _AIX */
! #endif /* _MINIX */
! 	}
! #ifdef _MINIX
!     fd = open(path_utmp, O_RDONLY);
!     if (fd < 0) {
!         perror(path_utmp);
!         return;
!     }
! 
!     nbytes = read(fd, &ut, sizeof(struct utmp));
!     while (nbytes == sizeof(struct utmp)) {
!         if (ut.ut_type == USER_PROCESS) {
!             if (count ++) write(1, " ", 1);
!             write(1, &ut.ut_user, strlen(ut.ut_user));
!         }
!         nbytes = read(fd, &ut, sizeof(struct utmp));
!     }
!     close(fd);
!     if (count) write(1, "\n", 1);
! #else
  	while ((u = getutxent()) != NULL) {
  		if (u->ut_type == USER_PROCESS) {
  			if (count++)
***************
*** 77,81 ****
--- 110,115 ----
  	endutxent();
  	if (count)
  		putchar('\n');
+ #endif
  	return 0;
  }
Common subdirectories: heirloom-060122/wc and heirloom-060122-patched/wc
Only in heirloom-060122-patched/wc: Makefile
diff -c heirloom-060122/wc/wc.c heirloom-060122-patched/wc/wc.c
*** heirloom-060122/wc/wc.c Sun May 29 12:55:46 2005
--- heirloom-060122-patched/wc/wc.c Fri Oct 20 17:02:18 2006
***************
*** 58,77 ****
  #include	<blank.h>
  #include	<mbtowi.h>
  
  static unsigned		errcnt;		/* count of errors */
  static int		cflag;		/* count bytes only */
  static int		lflag;		/* count lines only */
  static int		mflag;		/* count characters only */
  static int		wflag;		/* count words only */
  static int		illflag;	/* illegal flag given */
! static long long	bytec;		/* byte count */
! static long long	charc;		/* character count */
! static long long	wordc;		/* word count */
! static long long	linec;		/* line count */
! static long long	chart;		/* total character count */
! static long long	bytet;		/* total byte count */
! static long long	wordt;		/* total word count */
! static long long	linet;		/* total line count */
  #if defined (S42)
  static int		putspace;	/* wrote space to output line */
  #endif
--- 58,85 ----
  #include	<blank.h>
  #include	<mbtowi.h>
  
+ #ifdef _MINIX
+ #define LONGLONG long
+ #define NP_LLU "lu"
+ #else
+ #define LONGLONG long long
+ #define NP_LLU "llu"
+ #endif
+ 
  static unsigned		errcnt;		/* count of errors */
  static int		cflag;		/* count bytes only */
  static int		lflag;		/* count lines only */
  static int		mflag;		/* count characters only */
  static int		wflag;		/* count words only */
  static int		illflag;	/* illegal flag given */
! static LONGLONG	bytec;		/* byte count */
! static LONGLONG	charc;		/* character count */
! static LONGLONG	wordc;		/* word count */
! static LONGLONG	linec;		/* line count */
! static LONGLONG	chart;		/* total character count */
! static LONGLONG	bytet;		/* total byte count */
! static LONGLONG wordt;		/* total word count */
! static LONGLONG	linet;		/* total line count */
  #if defined (S42)
  static int		putspace;	/* wrote space to output line */
  #endif
***************
*** 84,97 ****
   * Format output.
   */
  static void
! report(unsigned long long count)
  {
  #if defined (S42)
  	if (putspace++)
  		printf(" ");
! 	printf("%llu", count);
! #else	/* !S42 */
! 	printf("%7llu ", count);
  #endif	/* !S42 */
  }
  
--- 92,105 ----
   * Format output.
   */
  static void
! report(unsigned LONGLONG count)
  {
  #if defined (S42)
  	if (putspace++)
  		printf(" ");
! 	printf("%" NP_LLU, count);
! #else	/* !S42 */
! 	printf("%7" NP_LLU " ", count);
  #endif	/* !S42 */
  }
  
***************
*** 125,131 ****
  static int
  sbwc(struct iblok *ip)
  {
! 	register long long hadspace = 1;
  	register int c, i;
  	size_t sz;
  #ifndef	SUS
--- 133,139 ----
  static int
  sbwc(struct iblok *ip)
  {
! 	register LONGLONG hadspace = 1;
  	register int c, i;
  	size_t sz;
  #ifndef	SUS
***************
*** 157,163 ****
  static int
  mbwc(struct iblok *ip)
  {
! 	register long long hadspace = 1;
  	char	mb[MB_LEN_MAX];
  	wint_t	c;
  	int	i, k, n;
--- 165,171 ----
  static int
  mbwc(struct iblok *ip)
  {
! 	register LONGLONG hadspace = 1;
  	char	mb[MB_LEN_MAX];
  	wint_t	c;
  	int	i, k, n;
Common subdirectories: heirloom-060122/what and heirloom-060122-patched/what
Only in heirloom-060122-patched/what: Makefile
Common subdirectories: heirloom-060122/who and heirloom-060122-patched/who
Only in heirloom-060122-patched/who: Makefile
diff -c heirloom-060122/who/who.c heirloom-060122-patched/who/who.c
*** heirloom-060122/who/who.c Sun Jan 22 19:02:55 2006
--- heirloom-060122-patched/who/who.c Fri Oct 20 18:34:38 2006
***************
*** 49,56 ****
  #include	<errno.h>
  #include	<time.h>
  #include	<libgen.h>
! #include	<utmpx.h>
! #include	<limits.h>
  
  enum okay {
  	OKAY,
--- 49,70 ----
  #include	<errno.h>
  #include	<time.h>
  #include	<libgen.h>
! #ifdef _MINIX
! #include	<utmp.h>
! #include	<minix/paths.h>
! #define UTMPRECORD struct utmp
! #define NEW_TIME 3
! #define OLD_TIME 4
! char *path_utmp = _PATH_UTMP;
! #else
! #include	<utmpx.h>
! #define UTMPRECORD struct utmpx
! #endif
! #include	<limits.h>
! 
! #ifndef LINE_MAX
! #define LINE_MAX 2048 /* POSIX 2 LINE_MAX */
! #endif
  
  enum okay {
  	OKAY,
***************
*** 82,87 ****
--- 96,130 ----
  static char	*whoami;		/* current terminal only */
  static char	*progname;		/* argv[0] to main() */
  
+ #ifdef _MINIX
+ static unsigned long get_boottime(void) {
+     int fd;
+     struct stat st;
+     long nrecs, i;
+     unsigned long boottime = 0UL;
+     UTMPRECORD ut;
+ 
+     stat(path_utmp, &st);
+     if (st.st_size % sizeof(UTMPRECORD) != 0) return 0UL;
+ 
+     fd = open(path_utmp, O_RDONLY);
+     if (fd < 0) return 0UL;
+     nrecs = st.st_size / sizeof(UTMPRECORD);
+ 
+     for (i=nrecs-1; i>=0; i--) {
+         lseek(fd, i*sizeof(UTMPRECORD), SEEK_SET);
+         read(fd, &ut, sizeof(UTMPRECORD));
+         if (ut.ut_type == BOOT_TIME) {
+             boottime = ut.ut_time;
+             break;
+         }
+     }
+ 
+     close(fd);
+     return boottime;
+ }
+ #endif
+ 
  static void
  usage(void)
  {
***************
*** 119,125 ****
  }
  
  static void
! print(const struct utmpx *u)
  {
  	struct tm	*tp;
  	char	buf[LINE_MAX];
--- 162,168 ----
  }
  
  static void
! print(const UTMPRECORD *u)
  {
  	struct tm	*tp;
  	char	buf[LINE_MAX];
***************
*** 158,166 ****
--- 201,214 ----
  	else
  		cp = u->ut_line;
  	printf("%-12.*s ", (int)sizeof u->ut_line, cp);
+ #ifdef _MINIX
+     tp = localtime(&u->ut_time);
+ 	strftime(buf, sizeof buf, "%b %d %H:%M", tp);
+ #else
  	t = u->ut_tv.tv_sec;
  	tp = localtime(&t);
  	strftime(buf, sizeof buf, "%b %e %H:%M", tp);
+ #endif
  	printf("%s", buf);
  	if (uflag && !sflag) {
  		struct stat	st;
***************
*** 203,209 ****
  #endif	/* __hpux */
  		printf("  id=%4.4s term=%-3d exit=%d",
  				u->ut_id,
! #if !defined (_AIX) || !defined (__APPLE__)
  				u->ut_exit.e_termination,
  				u->ut_exit.e_exit
  #else	/* _AIX, __APPLE__ */
--- 251,259 ----
  #endif	/* __hpux */
  		printf("  id=%4.4s term=%-3d exit=%d",
  				u->ut_id,
! #ifdef _MINIX
!                 0, 0
! #elif !defined (_AIX) || !defined (__APPLE__)
  				u->ut_exit.e_termination,
  				u->ut_exit.e_exit
  #else	/* _AIX, __APPLE__ */
***************
*** 222,228 ****
  }
  
  static enum okay
! selected(const struct utmpx *u)
  {
  	enum okay	val = STOP;
  
--- 272,278 ----
  }
  
  static enum okay
! selected(const UTMPRECORD *u)
  {
  	enum okay	val = STOP;
  
***************
*** 271,291 ****
  static void
  who(void)
  {
! 	struct utmpx	*u;
! 	int	users = 0, printed = 0;
  
  	if (Hflag)
  		header();
  	if (uflag) {
! 		struct utmpx	id;
  		setutxent();
  		id.ut_type = BOOT_TIME;
  		if ((u = getutxid(&id)) != NULL)
  			boottime = u->ut_tv.tv_sec;
! 	}
  	setutxent();
  	time(&now);
  	while ((u = getutxent()) != NULL) {
  		if (qflag) {
  			if (u->ut_type == USER_PROCESS) {
  				users++;
--- 321,356 ----
  static void
  who(void)
  {
! 	UTMPRECORD	*u;
! 	int	users = 0, printed = 0;
! #ifdef _MINIX
!     int fd;
!     UTMPRECORD ut;
!     u = &ut;
! #endif
  
  	if (Hflag)
  		header();
  	if (uflag) {
! #ifdef _MINIX
!         boottime = get_boottime();
! #else
! 		UTMPRECORD	id;
  		setutxent();
  		id.ut_type = BOOT_TIME;
  		if ((u = getutxid(&id)) != NULL)
  			boottime = u->ut_tv.tv_sec;
! #endif
! 	}
! #ifdef _MINIX
!     fd = open(path_utmp, O_RDONLY); /* size/open have been checked before */
!     time(&now);
!     while (read(fd, u, sizeof(UTMPRECORD)) == sizeof(UTMPRECORD)) {
! #else
  	setutxent();
  	time(&now);
  	while ((u = getutxent()) != NULL) {
+ #endif
  		if (qflag) {
  			if (u->ut_type == USER_PROCESS) {
  				users++;
***************
*** 301,307 ****
  				print(u);
  		}
  	}
! 	endutxent();
  	if (qflag) {
  		if (printed > 0)
  			putchar('\n');
--- 366,376 ----
  				print(u);
  		}
  	}
! #ifdef _MINIX
!     close(fd);
! #else
! 	endutxent();
! #endif
  	if (qflag) {
  		if (printed > 0)
  			putchar('\n');
***************
*** 398,410 ****
  			exit(1);
  		}
  		close(fd);
! 		if (st.st_size % sizeof (struct utmpx)) {
  			fprintf(stderr, "%s: File '%s' is not a utmp file\n",
  					progname, argv[optind]);
  			exit(1);
  		}
  #if !defined (__hpux) && !defined (_AIX)
! 		utmpxname(argv[optind]);
  #else	/* __hpux, _AIX */
  		fprintf(stderr, "%s: %s\n", progname, strerror(errno));
  		exit(1);
--- 467,483 ----
  			exit(1);
  		}
  		close(fd);
! 		if (st.st_size % sizeof (UTMPRECORD)) {
  			fprintf(stderr, "%s: File '%s' is not a utmp file\n",
  					progname, argv[optind]);
  			exit(1);
  		}
  #if !defined (__hpux) && !defined (_AIX)
! # ifdef _MINIX
!         path_utmp = argv[optind];
! # else
! 		utmpxname(argv[optind]);
! # endif
  #else	/* __hpux, _AIX */
  		fprintf(stderr, "%s: %s\n", progname, strerror(errno));
  		exit(1);
Common subdirectories: heirloom-060122/whoami and heirloom-060122-patched/whoami
Only in heirloom-060122-patched/whoami: Makefile
Common subdirectories: heirloom-060122/whodo and heirloom-060122-patched/whodo
Only in heirloom-060122-patched/whodo: Makefile
diff -c heirloom-060122/whodo/whodo.c heirloom-060122-patched/whodo/whodo.c
*** heirloom-060122/whodo/whodo.c Sun Jan 22 19:02:10 2006
--- heirloom-060122-patched/whodo/whodo.c Fri Oct 20 21:56:59 2006
***************
*** 48,54 ****
  #include	<stdlib.h>
  #include	<errno.h>
  #include	<time.h>
! #include	<utmpx.h>
  #include	<libgen.h>
  #include	<alloca.h>
  #include	<ctype.h>
--- 48,61 ----
  #include	<stdlib.h>
  #include	<errno.h>
  #include	<time.h>
! #ifdef _MINIX
! #include	<utmp.h>
! #include	<minix/paths.h>
! #define UTMPRECORD struct utmp
! #else
! #include	<utmpx.h>
! #define UTMPRECORD struct utmpx
! #endif
  #include	<libgen.h>
  #include	<alloca.h>
  #include	<ctype.h>
***************
*** 80,88 ****
  #include	<procinfo.h>
  #endif
  
! #if !defined (__linux__) && !defined (__FreeBSD__) && !defined (__hpux) && \
! 	!defined (_AIX) && !defined (__NetBSD__) && !defined (__OpenBSD__) && \
! 	!defined (__DragonFly__) && !defined (__APPLE__)
  #ifdef	sun
  #include	<sys/loadavg.h>
  #define	_STRUCTURED_PROC	1
--- 87,115 ----
  #include	<procinfo.h>
  #endif
  
! #ifdef _MINIX
! #include <limits.h>
! #include <timers.h>
! #include <signal.h>
! #include <minix/config.h>
! #include <minix/type.h>
! #include <minix/const.h>
! #include <minix/ipc.h>
! #include <minix/endpoint.h>
! #include <minix/sysutil.h>
! #include <sys/vm.h>
! #define KB_PER_PAGE (PAGE_SIZE / 1024)
! /* You need to have the kernel and servers sources installed to compile this */
! #include "/usr/src/servers/pm/mproc.h"
! #include "/usr/src/servers/fs/fproc.h"
! #include "/usr/src/kernel/const.h"
! #include "/usr/src/kernel/proc.h"
! #define PROCS (NR_TASKS + NR_PROCS)
! #endif
! 
! #if !defined (__linux__) && !defined (__FreeBSD__) && !defined (__hpux) && \
! 	!defined (_AIX) && !defined (__NetBSD__) && !defined (__OpenBSD__) && \
! 	!defined (__DragonFly__) && !defined (__APPLE__) && !defined (_MINIX)
  #ifdef	sun
  #include	<sys/loadavg.h>
  #define	_STRUCTURED_PROC	1
***************
*** 133,139 ****
  static char		*user;			/* look for one user only */
  #if defined (__linux__) || defined (__sun) || defined (__FreeBSD__) || \
  	defined (__hpux) || defined (__NetBSD__) || defined (__OpenBSD__) || \
! 	defined (__DragonFly__) || defined (__APPLE__)
  static char		loadavg[64];		/* load average */
  #endif	/* __linux__ || __sun || __FreeBSD__ || __hpux || __NetBSD__ ||
  		__OpenBSD__ || __DragonFly__ || __APPLE__ */
--- 160,166 ----
  static char		*user;			/* look for one user only */
  #if defined (__linux__) || defined (__sun) || defined (__FreeBSD__) || \
  	defined (__hpux) || defined (__NetBSD__) || defined (__OpenBSD__) || \
! 	defined (__DragonFly__) || defined (__APPLE__) || defined (_MINIX)
  static char		loadavg[64];		/* load average */
  #endif	/* __linux__ || __sun || __FreeBSD__ || __hpux || __NetBSD__ ||
  		__OpenBSD__ || __DragonFly__ || __APPLE__ */
***************
*** 164,171 ****
  	struct pslot	*t_pslot;	/* start of process table */
  	struct tslot	*t_next;	/* next slot */
  	time_t		t_time;		/* login timestamp */
! 	char	t_line[sizeof (((struct utmpx *)0)->ut_line)]; /*tty line name*/
! 	char	t_user[sizeof (((struct utmpx *)0)->ut_user)]; /* user name */
  	dev_t		t_termid;	/* device id of the tty */
  };
  
--- 191,198 ----
  	struct pslot	*t_pslot;	/* start of process table */
  	struct tslot	*t_next;	/* next slot */
  	time_t		t_time;		/* login timestamp */
! 	char	t_line[sizeof (((UTMPRECORD *)0)->ut_line)]; /*tty line name*/
! 	char	t_user[sizeof (((UTMPRECORD *)0)->ut_user)]; /* user name */
  	dev_t		t_termid;	/* device id of the tty */
  };
  
***************
*** 350,355 ****
--- 377,409 ----
  
  	getprocs64(&pi, sizeof pi, NULL, 0, &idx, 1);
  	upsec = now - pi.pi_start;
+ #elif defined (_MINIX)
+     int fd;
+     struct stat st;
+     long nrecs, i;
+     unsigned long boottime = 0UL;
+     UTMPRECORD ut;
+ 
+     stat(_PATH_WTMP, &st);
+     if (st.st_size % sizeof(UTMPRECORD) == 0) {
+ 
+         fd = open(_PATH_WTMP, O_RDONLY);
+         if (fd >= 0) {
+ 
+             nrecs = st.st_size / sizeof(UTMPRECORD);
+             for (i=nrecs-1; i>=0; i--) {
+                 lseek(fd, i*sizeof(UTMPRECORD), SEEK_SET);
+                 read(fd, &ut, sizeof(UTMPRECORD));
+                 if (ut.ut_type == BOOT_TIME) {
+                     boottime = ut.ut_time;
+                     break;
+                 }
+             }
+             close(fd);
+         }
+     }
+     upsec = now - boottime;
+ 
  #else	/* !__linux__, !__FreeBSD__, !__hpux, !_AIX, !__NetBSD__, !__OpenBSD__,
  	!__DragonFly__, !__APPLE__ */
  	FILE *fp;
***************
*** 671,677 ****
   */
  
  #if !defined (__hpux) && !defined (_AIX) && !defined (__NetBSD__) && \
! 	!defined (__OpenBSD__) && !defined (__APPLE__)
  
  #if defined (__linux__) || defined (__FreeBSD__) || defined (__DragonFly__)
  
--- 725,731 ----
   */
  
  #if !defined (__hpux) && !defined (_AIX) && !defined (__NetBSD__) && \
! 	!defined (__OpenBSD__) && !defined (__APPLE__) && !defined (_MINIX)
  
  #if defined (__linux__) || defined (__FreeBSD__) || defined (__DragonFly__)
  
***************
*** 1444,1449 ****
--- 1498,1614 ----
  	free(kp);	
  }
  
+ #elif defined (_MINIX)
+ 
+ /* NOT for tasks */
+ static void getargv(struct pslot *p, int p_nr, struct mproc mp[], int memfd) {
+     vir_bytes procargs = mp[p_nr].mp_procargs;
+     phys_bytes iframe = procargs -
+                         ( mp[p_nr].mp_seg[S].mem_vir << CLICK_SHIFT ) +
+                         ( mp[p_nr].mp_seg[S].mem_phys << CLICK_SHIFT );
+     int cnt = ( mp[p_nr].mp_seg[S].mem_len << CLICK_SHIFT ) -
+               ( iframe - ( mp[p_nr].mp_seg[S].mem_phys << CLICK_SHIFT ) );
+     union stack {
+         vir_bytes i;
+         char *    cp;
+         char      c;
+     } stk[ARG_MAX / sizeof(char*)];
+     union stack *sp = stk;
+     int argc, m;
+     char *argv0;
+ 
+     if (procargs == 0) goto errout; /* servers have no procargs */
+     if (memfd < 0) goto errout;
+ 
+     if (lseek(memfd, (off_t)iframe, 0) < 0) goto errout;
+     cnt = cnt < 0 ? 0 : cnt > ARG_MAX ? ARG_MAX : cnt;
+     if (read(memfd, (char*)stk, cnt) < 0) goto errout;
+ 
+     argc = sp[0].i;
+     if (argc == 0) goto errout; /* should not happen */
+ 
+     m = (long)sp[1].cp - (long)procargs;
+     if (m<0 || m>cnt) goto errout;
+     argv0 = &((char *) stk)[m];
+ 
+     argc--;
+     m=0;
+     while (argc) {
+         if (argv0[m] == '\0') {
+             argv0[m] = ' ';
+             argc--;
+         }
+         if (m == cnt) break; /* should not happen */
+         m++;
+     }
+ 
+     snprintf(p->p_cmdline, sizeof(p->p_cmdline), "%s", argv0);
+ 
+ errout:
+     if (p->p_cmdline[0] == '\0')
+         snprintf(p->p_cmdline, sizeof(p->p_cmdline), "%s", mp[p_nr].mp_name);
+ 
+ }
+ 
+ static struct pslot * readproc(struct proc kp[], struct mproc mp[],
+                     struct fproc fp[], int i, int memfd) {
+     int p_nr = kp[i].p_nr;
+     struct pslot *p;
+ 
+ 	p = smalloc(sizeof *p);
+ 	p->p_next = NULL;
+ 
+     p->p_time = kp[i].p_user_time / ( CLOCKS_PER_SEC * 6 ) +
+                 kp[i].p_sys_time / ( CLOCKS_PER_SEC * 6 );
+     p->p_ctime = 0;
+     snprintf(p->p_name, sizeof(p->p_name), "%s", kp[i].p_name);
+ 
+     if (p_nr < 0 ) {  /* special case for tasks */
+         p->p_pid = p_nr;
+         return p;
+     }
+ 
+     p->p_pid = mp[p_nr].mp_pid;
+     p->p_termid = makedev(major(fp[p_nr].fp_tty), minor(fp[p_nr].fp_tty));
+     getargv(p, p_nr, mp, memfd);
+ 
+     return p;
+ }
+ 
+ 
+ static void
+ findprocs(struct tslot *t0) {
+ 	struct pslot *p;
+     struct proc proc[PROCS];
+     struct mproc mproc[PROCS];
+     struct fproc fproc[PROCS];
+ 	size_t i;
+ 	int	err;
+     int memfd = open("/dev/mem", O_RDONLY);
+ 
+ 	if (getsysinfo(PM_PROC_NR, SI_KPROC_TAB, proc) < 0) {
+ 		fprintf(stderr, "error getting kproc tab\n");
+ 		exit(3);
+ 	}
+ 	if (getsysinfo(PM_PROC_NR, SI_PROC_TAB, mproc) < 0) {
+ 		fprintf(stderr, "error getting mproc tab\n");
+ 		exit(3);
+ 	}
+ 	if (getsysinfo(FS_PROC_NR, SI_PROC_TAB, fproc) < 0) {
+ 		fprintf(stderr, "error getting fproc tab\n");
+ 		exit(3);
+ 	}
+ 	for (i = 0; i < PROCS; i++) {
+         if (proc[i].p_rts_flags & SLOT_FREE)    continue;
+ 
+ /*		getproc(&p, proc, mproc, fproc, i, memfd);*/
+ 		p = readproc(proc, mproc, fproc, i, memfd);
+ 		queueproc(t0, p);
+ 
+ 	}
+     if (memfd) close(memfd);
+ }
+ 
  #endif	/* all */
  
  /*
***************
*** 1492,1498 ****
  	}
  }
  #elif defined (__sun) || defined (__FreeBSD__) || defined (__NetBSD__) || \
! 	defined (__OpenBSD__) || defined (__DragonFly__) || defined (__APPLE__)
  
  #ifndef	LOADAVG_NSTATS
  #define	LOADAVG_NSTATS	3
--- 1657,1664 ----
  	}
  }
  #elif defined (__sun) || defined (__FreeBSD__) || defined (__NetBSD__) || \
! 	defined (__OpenBSD__) || defined (__DragonFly__) || defined (__APPLE__) || \
!     defined (_MINIX)
  
  #ifndef	LOADAVG_NSTATS
  #define	LOADAVG_NSTATS	3
***************
*** 1540,1557 ****
  static void
  getlogins(void)
  {
! 	struct utmpx *ut;
! 	struct tslot *t, *t0 = NULL, *tprev = NULL;
  
  #if defined (__linux__) || defined (__sun) || defined (__FreeBSD__) || \
  	defined (__hpux) || defined (__NetBSD__) || defined (__OpenBSD__) || \
! 	defined (__DragonFly__) || defined (__APPLE__)
  	if (cmd != WHODO)
  		getload();
  #endif	/* __linux__ || __sun || __FreeBSD__ || __hpux || __NetBSD__ ||
  		__OpenBSD__ ||  __DragonFly__ || __APPLE__ */
! 	setutxent();
! 	while ((ut = getutxent()) != NULL) {
  		if (ut->ut_type == USER_PROCESS) {
  			if (user)
  				if (ut->ut_user == NULL
--- 1706,1733 ----
  static void
  getlogins(void)
  {
! 	UTMPRECORD *ut;
! 	struct tslot *t, *t0 = NULL, *tprev = NULL;
! #ifdef _MINIX
!     int fd;
!     UTMPRECORD utr;
!     ut = &utr;
! #endif
  
  #if defined (__linux__) || defined (__sun) || defined (__FreeBSD__) || \
  	defined (__hpux) || defined (__NetBSD__) || defined (__OpenBSD__) || \
! 	defined (__DragonFly__) || defined (__APPLE__) || defined (_MINIX)
  	if (cmd != WHODO)
  		getload();
  #endif	/* __linux__ || __sun || __FreeBSD__ || __hpux || __NetBSD__ ||
  		__OpenBSD__ ||  __DragonFly__ || __APPLE__ */
! #ifdef _MINIX
!     fd = open(_PATH_UTMP, O_RDONLY);
!     while (fd >= 0 && read(fd, ut, sizeof(UTMPRECORD))) {
! #else
! 	setutxent();
! 	while ((ut = getutxent()) != NULL) {
! #endif
  		if (ut->ut_type == USER_PROCESS) {
  			if (user)
  				if (ut->ut_user == NULL
***************
*** 1563,1589 ****
  			else
  				tprev->t_next = t;
  			tprev = t;
! 			if (ut->ut_line) {
  				strcpy(t->t_line, ut->ut_line);
  				t->t_termid = lineno(ut->ut_line);
  			} else {
  				strcpy(t->t_line, unknown);
  				t->t_termid = PRNODEV;
  			}
! 			if (ut->ut_user)
  				strcpy(t->t_user, ut->ut_user);
  			else
  				strcpy(t->t_user, unknown);
  			t->t_time = ut->ut_tv.tv_sec;
  			if (ut->ut_tv.tv_usec >= 500000)
  				t->t_time++;
  			t->t_pslot = NULL;
  			t->t_next = NULL;
  		}
  	}
  	findprocs(t0);
  	printout(t0);
! 	endutxent();
  }
  
  static void
--- 1739,1781 ----
  			else
  				tprev->t_next = t;
  			tprev = t;
! #ifdef _MINIX
!             if (1) {
! #else
! 			if (ut->ut_line) {
! #endif
  				strcpy(t->t_line, ut->ut_line);
  				t->t_termid = lineno(ut->ut_line);
  			} else {
  				strcpy(t->t_line, unknown);
  				t->t_termid = PRNODEV;
  			}
! #ifdef _MINIX
!             if (1)
! #else
! 			if (ut->ut_user)
! #endif
  				strcpy(t->t_user, ut->ut_user);
  			else
  				strcpy(t->t_user, unknown);
+ #ifdef _MINIX
+             t->t_time = ut->ut_time;
+ #else
  			t->t_time = ut->ut_tv.tv_sec;
  			if (ut->ut_tv.tv_usec >= 500000)
  				t->t_time++;
+ #endif
  			t->t_pslot = NULL;
  			t->t_next = NULL;
  		}
  	}
  	findprocs(t0);
  	printout(t0);
! #ifdef _MINIX
!     close(fd);
! #else
! 	endutxent();
! #endif
  }
  
  static void
Common subdirectories: heirloom-060122/xargs and heirloom-060122-patched/xargs
Only in heirloom-060122-patched/xargs: Makefile
diff -c heirloom-060122/xargs/xargs.c heirloom-060122-patched/xargs/xargs.c
*** heirloom-060122/xargs/xargs.c Tue Jun 21 15:27:01 2005
--- heirloom-060122-patched/xargs/xargs.c Fri Oct 20 18:23:27 2006
***************
*** 53,58 ****
--- 53,62 ----
  #include	<blank.h>
  #include	<mbtowi.h>
  
+ #ifndef LINE_MAX
+ #define LINE_MAX 2048 /* POSIX 2 */
+ #endif
+ 
  #if defined (__GLIBC__) && defined(_IO_putc_unlocked)
  #undef	putc
  #define	putc(c, f)	_IO_putc_unlocked(c, f)
Common subdirectories: heirloom-060122/yes and heirloom-060122-patched/yes
Only in heirloom-060122-patched/yes: Makefile
